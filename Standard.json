[{"Function": "Temporal.Numeric.maxSince()", "Signature": "Object maxSince(PropertyAtom pa, long time)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns the maximum history value since the specified time.", "Parameters": [{"Name": "pa", "Type": "PropertyAtom", "Description": "The target property for calculation."}, {"Name": "time", "Type": "long", "Description": "The specified time in millisecond."}], "Returns": [{"Type": "Object", "Description": "The maximum value since the specified time. The return object type is the same as the type of the value of 'pa'."}], "Cautions": "none"},{"Function": "Temporal.Numeric.maxOfLast()", "Signature": "Object maxOfLast(PropertyAtom pa, int last_n_times)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns the maximum value of the last n history entries.", "Parameters": [{"Name": "pa", "Type": "PropertyAtom", "Description": "The target property for calculation."}, {"Name": "last_n_times", "Type": "int", "Description": "The number of last history entries to be compared."}], "Returns": [{"Type": "Object", "Description": "The maximum value of the last n history entries. The return object type is the same as the type of the value of 'pa'."}], "Cautions": "none"},{"Function": "Temporal.Numeric.addAllHistoryLong()", "Signature": "long addAllHistoryLong(PropertyAtomLong pal, long t)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns the sum of all the values in the history of a property atom.", "Parameters": [{"Name": "pal", "Type": "PropertyAtomLong", "Description": "The property to check for the value of."}, {"Name": "t", "Type": "time", "Description": "from which values are added (in milliseconds); 0 uses all values recorded."}], "Returns": [{"Type": "long", "Description": "sum of all values in the history."}], "Cautions": "If the values are too large the sum might overflow."},{"Function": "Temporal.Numeric.totalSince()", "Signature": "Object totalSince(PropertyAtom pa, long time)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method calculates the sum of the history value since the specified time.", "Parameters": [{"Name": "pa", "Type": "PropertyAtom", "Description": "The target property for calculation."}, {"Name": "time", "Type": "long", "Description": "The specified time in millisecond."}], "Returns": [{"Type": "Object", "Description": "The sum of the value since the specified time. The return object type is the same as the type of the value of 'pa'."}], "Cautions": "none"},{"Function": "Temporal.Numeric.avgOfLast()", "Signature": "Object avgOfLast(PropertyAtom pa, int last_n_times)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method calculates the average of the value of the last n history entries.", "Parameters": [{"Name": "pa", "Type": "PropertyAtom", "Description": "The target property for calculation."}, {"Name": "last_n_times", "Type": "int", "Description": "The number of last history entries to calculate."}], "Returns": [{"Type": "Object", "Description": "The average of the value of the last n history entries. The return object type is always Double if any."}], "Cautions": "none"},{"Function": "Temporal.Numeric.interpolateDouble()", "Signature": "double interpolateDouble(PropertyAtomDouble pad, long no_of_milli_seconds_ago)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns interpolated value over the history a given number of msec ago", "Parameters": [{"Name": "pad", "Type": "PropertyAtomDouble", "Description": "The property to check for the value of."}, {"Name": "no_of_milli_seconds_ago", "Type": "long", "Description": "Time at which the interpolated value is required."}], "Returns": [{"Type": "double", "Description": "returns the calculated value."}], "Cautions": "If value did not exist through entire interval an exception is thrown."},{"Function": "Temporal.Numeric.interpolateInt()", "Signature": "double interpolateInt(PropertyAtomInt pai, long no_of_milli_seconds_ago)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns interpolated value over the history a given number of msec ago", "Parameters": [{"Name": "pai", "Type": "PropertyAtomInt", "Description": "The property to check for the value of."}, {"Name": "no_of_milli_seconds_ago", "Type": "long", "Description": "Time at which the interpolated value is required."}], "Returns": [{"Type": "double", "Description": "returns the calculated value."}], "Cautions": "If value did not exist through entire interval an exception is thrown."},{"Function": "Temporal.Numeric.minOfLast()", "Signature": "Object minOfLast(PropertyAtom pa, int last_n_times)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns the minimum value of the last n history entries.", "Parameters": [{"Name": "pa", "Type": "PropertyAtom", "Description": "The target property for calculation."}, {"Name": "last_n_times", "Type": "int", "Description": "The number of last history entries to be compared."}], "Returns": [{"Type": "Object", "Description": "The minimum value of the last n history entries. The return object type is the same as the type of the value of 'pa'."}], "Cautions": "none"},{"Function": "Temporal.Numeric.addAllHistoryDouble()", "Signature": "double addAllHistoryDouble(PropertyAtomDouble pad, long t)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns the sum of all the values in the history of a property atom.", "Parameters": [{"Name": "pad", "Type": "PropertyAtomDouble", "Description": "The property to check for the value of."}, {"Name": "t", "Type": "time", "Description": "from which values are added (in milliseconds); 0 uses all values recorded."}], "Returns": [{"Type": "double", "Description": "sum of all values in the history."}], "Cautions": "If the values are too large the sum might overflow."},{"Function": "Temporal.Numeric.avgSince()", "Signature": "Object avgSince(PropertyAtom pa, long time)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method calculates the average history value since the specified time.", "Parameters": [{"Name": "pa", "Type": "PropertyAtom", "Description": "The target property for calculation."}, {"Name": "time", "Type": "long", "Description": "The specified time in millisecond."}], "Returns": [{"Type": "Object", "Description": "The average of the value since the specified time. The return object type is always Double if any."}], "Cautions": "none"},{"Function": "Temporal.Numeric.minSince()", "Signature": "Object minSince(PropertyAtom pa, long time)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns the minimum history value since the specified time.", "Parameters": [{"Name": "pa", "Type": "PropertyAtom", "Description": "The target property for calculation."}, {"Name": "time", "Type": "long", "Description": "The specified time in millisecond."}], "Returns": [{"Type": "Object", "Description": "The minimum value since the specified time. The return object type is the same as the type of the value of 'pa'."}], "Cautions": "none"},{"Function": "Temporal.Numeric.addAllHistoryInt()", "Signature": "int addAllHistoryInt(PropertyAtomInt pai, long t)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns the sum of all the values in the history of a property atom.", "Parameters": [{"Name": "pai", "Type": "PropertyAtomInt", "Description": "The property to check for the value of."}, {"Name": "t", "Type": "time", "Description": "from which values are added (in milliseconds); 0 uses all values recorded."}], "Returns": [{"Type": "int", "Description": "sum of all values in the history."}], "Cautions": "If the values are too large the sum might overflow."},{"Function": "Temporal.Numeric.totalOfLast()", "Signature": "Object totalOfLast(PropertyAtom pa, int last_n_times)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method calculates the sum of the value of the last n history entries.", "Parameters": [{"Name": "pa", "Type": "PropertyAtom", "Description": "The target property for calculation."}, {"Name": "last_n_times", "Type": "int", "Description": "The number of last history entries to calculate."}], "Returns": [{"Type": "Object", "Description": "The sum of the value of the last n history entries. The return object type is the same as the type of the value of 'pa'."}], "Cautions": "none"},{"Function": "Temporal.Numeric.interpolateLong()", "Signature": "double interpolateLong(PropertyAtomLong pal, long no_of_milli_seconds_ago)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns interpolated value over the history a given number of msec ago", "Parameters": [{"Name": "pal", "Type": "PropertyAtomLong", "Description": "The property to check for the value of."}, {"Name": "no_of_milli_seconds_ago", "Type": "long", "Description": "Time at which the interpolated value is required."}], "Returns": [{"Type": "double", "Description": "returns the calculated value."}], "Cautions": "If value did not exist through entire interval an exception is thrown."},{"Function": "Temporal.History.alwaysDecreasingInt()", "Signature": "boolean alwaysDecreasingInt(PropertyAtomInt pai, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if samples of the property always decrease over a given time interval [stime, etime].\nReturns true only if each sample value is less than the immediately prior sample value in the given time interval.\nAll the times are in milliseconds.", "Parameters": [{"Name": "pai", "Type": "PropertyAtomInt", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "boolean", "Description": "true if samples of the property always decrease, false otherwise."}], "Cautions": "If value did not exist through the entire interval an exception is thrown."},{"Function": "Temporal.History.howOld()", "Signature": "long howOld(PropertyAtom pa)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns how old is the oldest value in the PropertyAtom history.", "Parameters": [{"Name": "pa", "Type": "PropertyAtom", "Description": "The property to check for the value of."}], "Returns": [{"Type": "long", "Description": "time stamp of the oldest value in the history(milliseconds)."}], "Cautions": "none."},{"Function": "Temporal.History.everDecreasingDouble()", "Signature": "boolean everDecreasingDouble(PropertyAtomDouble pad, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if samples of the property ever decrease over a given time interval [stime, etime].\nReturns true only if any sample value is less than any prior sample value in the given time interval.\nAll the times are in milliseconds.", "Parameters": [{"Name": "pad", "Type": "PropertyAtomDouble", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "boolean", "Description": "true if samples of the property ever decrease, false otherwise."}], "Cautions": "If value did not exist through the entire interval an exception is thrown."},{"Function": "Temporal.History.alwaysIncreasingLong()", "Signature": "boolean alwaysIncreasingLong(PropertyAtomLong pal, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if samples of the property always increase over a given time interval [stime, etime].\nReturns true only if each sample value is greater than the immediately prior sample value in the given time interval.\nAll the times are in milliseconds.", "Parameters": [{"Name": "pal", "Type": "PropertyAtomLong", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "boolean", "Description": "true if samples of the property always increase, false otherwise."}], "Cautions": "If value did not exist through the entire interval an exception is thrown."},{"Function": "Temporal.History.everIncreasingDouble()", "Signature": "boolean everIncreasingDouble(PropertyAtomDouble pad, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if samples of the property ever increase over a given time interval [stime, etime].\nReturns true only if any sample value is greater than any prior sample value in the given time interval.\nAll the times are in milliseconds.", "Parameters": [{"Name": "pad", "Type": "PropertyAtomDouble", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "boolean", "Description": "true if samples of the property ever increase, false otherwise."}], "Cautions": "If value did not exist through the entire interval an exception is thrown."},{"Function": "Temporal.History.previous()", "Signature": "Object previous(PropertyAtom pad)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns the previous value of a PropertyAtom.", "Parameters": [{"Name": "pad", "Type": "PropertyAtom", "Description": "The property to check for the value of."}], "Returns": [{"Type": "Object", "Description": "returns the previous value."}], "Cautions": "If this is the first value; PropertyAtomInt default value is returned."},{"Function": "Temporal.History.alwaysIncreasingInt()", "Signature": "boolean alwaysIncreasingInt(PropertyAtomInt pai, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if samples of the property always increase over a given time interval [stime, etime].\nReturns true only if each sample value is greater than the immediately prior sample value in the given time interval.\nAll the times are in milliseconds.", "Parameters": [{"Name": "pai", "Type": "PropertyAtomInt", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "boolean", "Description": "true if samples of the property always increase, false otherwise."}], "Cautions": "If value did not exist through the entire interval an exception is thrown."},{"Function": "Temporal.History.previousDouble()", "Signature": "double previousDouble(PropertyAtomDouble pad)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns the previous value of PropertyAtomDouble", "Parameters": [{"Name": "pad", "Type": "PropertyAtomDouble", "Description": "The property to check for the value of."}], "Returns": [{"Type": "double", "Description": "returns the previous value."}], "Cautions": "If this is the first value; PropertyAtomInt default value is returned."},{"Function": "Temporal.History.howManyInLast()", "Signature": "int howManyInLast(PropertyAtom pa, long num_msec_ago)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns how many history values exist for given property in last number of msec ago.\nThe value is bounded by history size.", "Parameters": [{"Name": "pa", "Type": "PropertyAtom", "Description": "The target property."}, {"Name": "num_msec_ago", "Type": "long", "Description": "Number of msec ago."}], "Returns": [{"Type": "int", "Description": "Number of history values that exist within the last specified msec timeframe."}], "Cautions": "none"},{"Function": "Temporal.History.everDecreasingInt()", "Signature": "boolean everDecreasingInt(PropertyAtomInt pai, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if samples of the property ever decrease over a given time interval [stime, etime].\nReturns true only if any sample value is less than any prior sample value in the given time interval.\nAll the times are in milliseconds.", "Parameters": [{"Name": "pai", "Type": "PropertyAtomInt", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "boolean", "Description": "true if samples of the property ever decrease, false otherwise."}], "Cautions": "If value did not exist through the entire interval an exception is thrown."},{"Function": "Temporal.History.steadyDouble()", "Signature": "boolean steadyDouble(PropertyAtomDouble pad, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if samples of the property value remain steady over a given time interval[stime, etime].", "Parameters": [{"Name": "pad", "Type": "PropertyAtomDouble", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "boolean", "Description": "true if the value was steady false otherwise."}], "Cautions": "If value did not exist through the entire interval an exception is thrown."},{"Function": "Temporal.History.previousLong()", "Signature": "long previousLong(PropertyAtomLong pal)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns the previous value of PropertyAtomLong", "Parameters": [{"Name": "pal", "Type": "PropertyAtomLong", "Description": "The property to check for the value of."}], "Returns": [{"Type": "long", "Description": "returns the previous value."}], "Cautions": "If this is the first value; PropertyAtomInt default value is returned."},{"Function": "Temporal.History.previousInt()", "Signature": "int previousInt(PropertyAtomInt pai)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns the previous value of PropertyAtomInt", "Parameters": [{"Name": "pai", "Type": "PropertyAtomInt", "Description": "The property to check for the value of."}], "Returns": [{"Type": "int", "Description": "returns the previous value."}], "Cautions": "If this is the first value; PropertyAtomInt default value is returned."},{"Function": "Temporal.History.howCurrent()", "Signature": "long howCurrent(PropertyAtom pa)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns how old is the newest value in the PropertyAtom history.", "Parameters": [{"Name": "pa", "Type": "PropertyAtom", "Description": "The property to check for the value of."}], "Returns": [{"Type": "long", "Description": "time stamp of the newest value in the history(milliseconds)."}], "Cautions": "none."},{"Function": "Temporal.History.everIncreasingLong()", "Signature": "boolean everIncreasingLong(PropertyAtomLong pal, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if samples of the property ever increase over a given time interval [stime, etime].\nReturns true only if any sample value is greater than any prior sample value in the given time interval.\nAll the times are in milliseconds.", "Parameters": [{"Name": "pal", "Type": "PropertyAtomLong", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "boolean", "Description": "true if samples of the property ever increase, false otherwise."}], "Cautions": "If value did not exist through the entire interval an exception is thrown."},{"Function": "Temporal.History.everIncreasingInt()", "Signature": "boolean everIncreasingInt(PropertyAtomInt pai, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if samples of the property ever increase over a given time interval [stime, etime].\nReturns true only if any sample value is greater than any prior sample value in the given time interval.\nAll the times are in milliseconds.", "Parameters": [{"Name": "pai", "Type": "PropertyAtomInt", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "boolean", "Description": "true if samples of the property ever increase, false otherwise."}], "Cautions": "If value did not exist through the entire interval an exception is thrown."},{"Function": "Temporal.History.steadyInt()", "Signature": "boolean steadyInt(PropertyAtomInt pai, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if samples of the property value remain steady over a given time interval[stime, etime].", "Parameters": [{"Name": "pai", "Type": "PropertyAtomInt", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "boolean", "Description": "true if the value was steady false otherwise."}], "Cautions": "If value did not exist through the entire interval an exception is thrown."},{"Function": "Temporal.History.history()", "Signature": "Object history(PropertyAtom pad, long no_of_milli_seconds_ago)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns PropertyAtom value a given number of milli seconds ago", "Parameters": [{"Name": "pad", "Type": "PropertyAtom", "Description": "The property to check for the value of."}, {"Name": "no_of_milli_seconds_ago", "Type": "long", "Description": "Time at which the interpolated value is required."}], "Returns": [{"Type": "Object", "Description": "returns the identified value."}], "Cautions": "If value did not exist through entire interval an exception is thrown."},{"Function": "Temporal.History.alwaysDecreasingDouble()", "Signature": "boolean alwaysDecreasingDouble(PropertyAtomDouble pad, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if samples of the property always decrease over a given time interval [stime, etime].\nReturns true only if each sample value is less than the immediately prior sample value in the given time interval.\nAll the times are in milliseconds.", "Parameters": [{"Name": "pad", "Type": "PropertyAtomDouble", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "boolean", "Description": "true if samples of the property always decrease, false otherwise."}], "Cautions": "If value did not exist through the entire interval an exception is thrown."},{"Function": "Temporal.History.alwaysIncreasingDouble()", "Signature": "boolean alwaysIncreasingDouble(PropertyAtomDouble pad, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if samples of the property always increase over a given time interval [stime, etime].\nReturns true only if each sample value is greater than the immediately prior sample value in the given time interval.\nAll the times are in milliseconds.", "Parameters": [{"Name": "pad", "Type": "PropertyAtomDouble", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "boolean", "Description": "true if samples of the property always increase, false otherwise."}], "Cautions": "If value did not exist through the entire interval an exception is thrown."},{"Function": "Temporal.History.everDecreasingLong()", "Signature": "boolean everDecreasingLong(PropertyAtomLong pal, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if samples of the property ever decrease over a given time interval [stime, etime].\nReturns true only if any sample value is less than any prior sample value in the given time interval.\nAll the times are in milliseconds.", "Parameters": [{"Name": "pal", "Type": "PropertyAtomLong", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "boolean", "Description": "true if samples of the property ever decrease, false otherwise."}], "Cautions": "If value did not exist through the entire interval an exception is thrown."},{"Function": "Temporal.History.historyInt()", "Signature": "double historyInt(PropertyAtomInt pai, long no_of_milli_seconds_ago)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns PropertyAtomInt value a given number of milli seconds ago", "Parameters": [{"Name": "pai", "Type": "PropertyAtomInt", "Description": "The property to check for the value of."}, {"Name": "no_of_milli_seconds_ago", "Type": "long", "Description": "Time at which the interpolated value is required."}], "Returns": [{"Type": "int", "Description": "returns the identified value."}], "Cautions": "If value did not exist through entire interval an exception is thrown."},{"Function": "Temporal.History.howMany()", "Signature": "int howMany(PropertyAtom pa, long stime, long etime, boolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns how many values exist in interval [stime, etime].", "Parameters": [{"Name": "pa", "Type": "PropertyAtom", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "int", "Description": "no of values that exist in interval [stime, etime]."}], "Cautions": "If PropertyAtom does not have enough timeline, the oldest value starts it."},{"Function": "Temporal.History.alwaysDecreasingLong()", "Signature": "boolean alwaysDecreasingLong(PropertyAtomLong pal, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if samples of the property always decrease over a given time interval [stime, etime].\nReturns true only if each sample value is less than the immediately prior sample value in the given time interval.\nAll the times are in milliseconds.", "Parameters": [{"Name": "pal", "Type": "PropertyAtomLong", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "boolean", "Description": "true if samples of the property always decrease, false otherwise."}], "Cautions": "If value did not exist through the entire interval an exception is thrown."},{"Function": "Temporal.History.historyDouble()", "Signature": "double historyDouble(PropertyAtomDouble pad, long no_of_milli_seconds_ago)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns PropertyAtomDouble value a given number of milli seconds ago", "Parameters": [{"Name": "pad", "Type": "PropertyAtomDouble", "Description": "The property to check for the value of."}, {"Name": "no_of_milli_seconds_ago", "Type": "long", "Description": "Time at which the interpolated value is required."}], "Returns": [{"Type": "double", "Description": "returns the identified value."}], "Cautions": "If value did not exist through entire interval an exception is thrown."},{"Function": "Temporal.History.steadyLong()", "Signature": "boolean steadyLong(PropertyAtomLong pal, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if samples of the property value remain steady over a given time interval[stime, etime].", "Parameters": [{"Name": "pal", "Type": "PropertyAtomLong", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "boolean", "Description": "true if the value was steady false otherwise."}], "Cautions": "If value did not exist through the entire interval an exception is thrown."},{"Function": "Temporal.History.historyLong()", "Signature": "double historyLong(PropertyAtomLong pal, long no_of_milli_seconds_ago)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns PropertyAtomLong value a given number of milli seconds ago", "Parameters": [{"Name": "pal", "Type": "PropertyAtomLong", "Description": "The property to check for the value of."}, {"Name": "no_of_milli_seconds_ago", "Type": "long", "Description": "Time at which the interpolated value is required."}], "Returns": [{"Type": "long", "Description": "returns the identified value."}], "Cautions": "If value did not exist through entire interval an exception is thrown."},{"Function": "Temporal.History.howManySince()", "Signature": "int howManySince(PropertyAtom pa, long time)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns how many history values exist for given property since\nthe specified time.\nThe value is bounded by history size.", "Parameters": [{"Name": "pa", "Type": "PropertyAtom", "Description": "The target property."}, {"Name": "time", "Type": "long", "Description": "The specified time in millisecond."}], "Returns": [{"Type": "int", "Description": "Number of history values that exist since the specified time."}], "Cautions": "none"},{"Function": "Temporal.Statistic.numMatchSince()", "Signature": "int numMatchSince(PropertyAtom pa, Object matchValue, long time)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method counts the number of object which match a specified value since the specified time.", "Parameters": [{"Name": "pa", "Type": "PropertyAtom", "Description": "The target property."}, {"Name": "matchValue", "Type": "Object", "Description": "The object whose value is to be matched."}, {"Name": "time", "Type": "long", "Description": "The specified time in millisecond."}], "Returns": [{"Type": "int", "Description": "Number of history value which match the specified value."}], "Cautions": "none"},{"Function": "Temporal.Statistic.numMatchOverLast()", "Signature": "int numMatchOverLast(PropertyAtom pa, Object matchValue, int last_n_times)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method counts the number of object which matches a specified value over the last n history entries.", "Parameters": [{"Name": "pa", "Type": "PropertyAtom", "Description": "The target property."}, {"Name": "matchValue", "Type": "Object", "Description": "The object whose value is to be matched."}, {"Name": "last_n_times", "Type": "int", "Description": "The number of last history entry to match."}], "Returns": [{"Type": "int", "Description": "Number of history value which match the specified value."}], "Cautions": "none"},{"Function": "Temporal.Statistic.maxOverTimeDouble()", "Signature": "double maxOverTimeDouble(PropertyAtomDouble pad, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns the maximum value of samples of a PropertyAtomDouble over a given time interval[stime, etime].", "Parameters": [{"Name": "pad", "Type": "PropertyAtomDouble", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "double", "Description": "returns the identified value."}], "Cautions": "If value did not exist through the entire interval an exception is thrown."},{"Function": "Temporal.Statistic.sumDouble()", "Signature": "double sumDouble(PropertyAtomDouble pad, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns the sum of samples of the history of a property atom over a given\ntime interval [stime, etime].", "Parameters": [{"Name": "pad", "Type": "PropertyAtomDouble", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "double", "Description": "sum of all the samples taken."}], "Cautions": "If the values are too large the sum might overflow, also if value did not exist through entire\ninterval an exception is thrown. 'interval' precision is in milliseconds."},{"Function": "Temporal.Statistic.avgOverTimeInt()", "Signature": "double avgOverTimeInt(PropertyAtomInt pai, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method calculates the average of samples of the property over a given time interval[stime, etime].", "Parameters": [{"Name": "pai", "Type": "PropertyAtomInt", "Description": "The property to average the value for."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "double", "Description": "average of all the samples taken."}], "Cautions": "If value did not exist through the entire interval an exception is thrown."},{"Function": "Temporal.Statistic.sumInt()", "Signature": "int sumInt(PropertyAtomInt pai, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns the sum of samples of the history of a property atom over a given\ntime interval [stime, etime].", "Parameters": [{"Name": "pai", "Type": "PropertyAtomInt", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "int", "Description": "sum of all the samples taken."}], "Cautions": "If the values are too large the sum might overflow, also if value did not exist through entire\ninterval an exception is thrown. 'interval' precision is in milliseconds."},{"Function": "Temporal.Statistic.maxOverTimeInt()", "Signature": "int maxOverTimeInt(PropertyAtomInt pai, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns the maximum value of samples of a PropertyAtomInt over a given time interval[stime, etime].", "Parameters": [{"Name": "pai", "Type": "PropertyAtomInt", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "int", "Description": "returns the identified value."}], "Cautions": "If value did not exist through the entire interval an exception is thrown."},{"Function": "Temporal.Statistic.minOverTimeLong()", "Signature": "long minOverTimeLong(PropertyAtomLong pal, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns the minimum value of samples of a PropertyAtomLong over a given time interval[stime, etime].", "Parameters": [{"Name": "pal", "Type": "PropertyAtomLong", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "long", "Description": "returns the identified value."}], "Cautions": "If value did not exist through the entire interval an exception is thrown."},{"Function": "Temporal.Statistic.avgOverTimeDouble()", "Signature": "double avgOverTimeDouble(PropertyAtomDouble pad, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method calculates the average of samples of the property over a given time interval[stime, etime].", "Parameters": [{"Name": "pad", "Type": "PropertyAtomDouble", "Description": "The property to average the value for."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "double", "Description": "average of all the samples taken."}], "Cautions": "If value did not exist through the entire interval an exception is thrown."},{"Function": "Temporal.Statistic.minOverTimeInt()", "Signature": "int minOverTimeInt(PropertyAtomInt pai, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns the minimum value of samples of a PropertyAtomInt over a given time interval[stime, etime].", "Parameters": [{"Name": "pai", "Type": "PropertyAtomInt", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "int", "Description": "returns the identified value."}], "Cautions": "If value did not exist through the entire interval an exception is thrown."},{"Function": "Temporal.Statistic.minOverTimeDouble()", "Signature": "double minOverTimeDouble(PropertyAtomDouble pad, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns the minimum value of samples of a PropertyAtomDouble over a given time interval[stime, etime].", "Parameters": [{"Name": "pad", "Type": "PropertyAtomDouble", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "double", "Description": "returns the identified value."}], "Cautions": "If value did not exist through the entire interval an exception is thrown."},{"Function": "Temporal.Statistic.sumLong()", "Signature": "long sumLong(PropertyAtomLong pal, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns the sum of samples of the history of a property atom over a given\ntime interval [stime, etime].", "Parameters": [{"Name": "pal", "Type": "PropertyAtomLong", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "long", "Description": "sum of all the samples taken."}], "Cautions": "If the values are too large the sum might overflow, also if value did not exist through entire\ninterval an exception is thrown. 'interval' precision is in milliseconds."},{"Function": "Temporal.Statistic.avgOverTimeLong()", "Signature": "double avgOverTimeLong(PropertyAtomLong pal, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method calculates the average of samples of the property over a given time interval[stime, etime].", "Parameters": [{"Name": "pal", "Type": "PropertyAtomLong", "Description": "The property to average the value for."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "double", "Description": "average of all the samples taken."}], "Cautions": "If value did not exist through the entire interval an exception is thrown."},{"Function": "Temporal.Statistic.maxOverTimeLong()", "Signature": "long maxOverTimeLong(PropertyAtomLong pal, long stime, long etime, int sample_interval,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns the maximum value of samples of a PropertyAtomLong over a given time interval[stime, etime].", "Parameters": [{"Name": "pal", "Type": "PropertyAtomLong", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_interval", "Type": "int", "Description": "interval between samples in milliseconds, should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "long", "Description": "returns the identified value."}], "Cautions": "If value did not exist through the entire interval an exception is thrown."},{"Function": "Temporal.Calculus.integralLong()", "Signature": "long integralLong(PropertyAtomLong pal, long stime, long etime, int sample_rate,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns the integral of values in the history of a property atom over a given\ntime interval [stime, etime]. we are dealing with discrete steps so just a summation of all the terms each\nmultiplied with the interval(milliseconds) is sufficient.", "Parameters": [{"Name": "pal", "Type": "PropertyAtomLong", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_rate", "Type": "int", "Description": "sample rate for the interval should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "long", "Description": "returns the calculated value."}], "Cautions": "If the values are too large the sum might overflow, also if value did not exist thourgh entire\ninterval an exception is thrown. 'interval' precision is in milliseconds."},{"Function": "Temporal.Calculus.rateOfChangeLong()", "Signature": "double rateOfChangeLong(PropertyAtomLong pal, long stime, long etime, int sample_rate,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method performs a least-squares fit of a straight line (Y = mX +b) and returns the\nvalue of the slope of the line (m) as the rate of change of the given PorpertyAtomLong over the time\ninterval[stime, etime].  All the times are in (milliseconds).", "Parameters": [{"Name": "pal", "Type": "PropertyAtomLong", "Description": "The property to calculate the rate of change for."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_rate", "Type": "int", "Description": "sample rate for the interval should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "double", "Description": "returns the identified value."}], "Cautions": "If value did not exist thourgh the entire interval an exception is thrown."},{"Function": "Temporal.Calculus.integralDouble()", "Signature": "double integralDouble(PropertyAtomDouble pad, long stime, long etime, int sample_rate,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns the integral of values in the history of a property atom over a given\ntime interval [stime, etime]; we are dealing with discrete steps so just a summation of all the terms each\nmultiplied with the interval(milliseconds) is sufficient.", "Parameters": [{"Name": "pad", "Type": "PropertyAtomDouble", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_rate", "Type": "int", "Description": "sample rate for the interval should be more than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "double", "Description": "returns the calculated value."}], "Cautions": "If the values are too large the sum might overflow, also if value did not exist thourgh entire\ninterval an exception is thrown. 'interval' precision is in milliseconds."},{"Function": "Temporal.Calculus.rateOfChangeDouble()", "Signature": "double rateOfChangeDouble(PropertyAtomDouble pad, long stime, long etime, int sample_rate,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method performs a least-squares fit of a straight line (Y = mX +b) and returns the\nvalue of the slope of the line (m) as the rate of change of the given PorpertyAtomInt over the time\ninterval[stime, etime].  All the times are in (milliseconds).", "Parameters": [{"Name": "pad", "Type": "PropertyAtomDouble", "Description": "The property to calculate the rate of change for."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_rate", "Type": "int", "Description": "sample rate for the interval should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "double", "Description": "returns the identified value."}], "Cautions": "If value did not exist through the entire interval an exception is thrown."},{"Function": "Temporal.Calculus.integralInt()", "Signature": "int integralInt(PropertyAtomInt pai, long stime, long etime, int sample_rate,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns the integral of values in the history of a property atom over a given\ntime interval [stime, etime]; we are dealing with discrete steps so just a summation of all the terms\neach multiplied with the interval(milliseconds) is sufficient.", "Parameters": [{"Name": "pai", "Type": "PropertyAtomInt", "Description": "The property to check for the value of."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_rate", "Type": "int", "Description": "sample rate for the interval should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "int", "Description": "returns the calculated value."}], "Cautions": "If the values are too large the sum might overflow, also if value did not exist through entire\ninterval an exception is thrown. 'interval' precision is in milliseconds."},{"Function": "Temporal.Calculus.rateOfChangeInt()", "Signature": "double rateOfChangeInt(PropertyAtomInt pai, long stime, long etime, int sample_rate,\nboolean bound_by_stime)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method performs a least-squares fit of a straight line (Y = mX +b) and returns the\nvalue of the slope of the line (m) as the rate of change of the given PorpertyAtomInt over the time\ninterval[stime, etime].  All the times are in (milliseconds).", "Parameters": [{"Name": "pai", "Type": "PropertyAtomInt", "Description": "The property to calculate the rate of change for."}, {"Name": "stime", "Type": "long", "Description": "start time of the interval, 0 means use oldest value's timestamp as start time."}, {"Name": "etime", "Type": "long", "Description": "end time of the interval, 0 means use newest value's timestamp as end time."}, {"Name": "sample_rate", "Type": "int", "Description": "sample rate for the interval should be greater than 0."}, {"Name": "bound_by_stime", "Type": "boolean", "Description": "true implies for stime less than oldest value's time stamp[t0] use t0."}], "Returns": [{"Type": "double", "Description": "returns the identified value."}], "Cautions": "If value did not exist thourgh the entire interval an exception is thrown."},{"Function": "Cluster.sendMessagesOverLocalNamedPipe()", "Signature": "void sendMessagesOverLocalNamedPipe(String pipeName, Object collection)", "Domain": "ACTION, CONDITION, QUERY", "Description": "java.util.Collection", "Parameters": [{"Name": "pipeName", "Type": "String", "Description": "Name of the pipe"}, {"Name": "collection", "Type": "Object", "Description": "Collection of messages to be sent over the pipe."}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Cluster.runRuleFunction()", "Signature": "void runRuleFunction(String workMgrName, String ruleFnURI, Object[] args,  boolean bInPreprocessContext)", "Domain": "ACTION", "Description": "This function runs a ruleFunction continously as per the return status of the ruleFunction", "Parameters": [{"Name": "workMgrName", "Type": "String", "Description": "The workMgrName - The thread that will execute the rule Function"}, {"Name": "ruleFnURI", "Type": "String", "Description": "The ruleFn to execute. This ruleFunction should return boolean true to continue, false to stop executing"}, {"Name": "args", "Type": "Object[]", "Description": "The args for ruleFunction"}], "Returns": [{"Type": "void"}]},{"Function": "Cluster.pollMessageFromLocalNamedPipe()", "Signature": "Object pollMessageFromLocalNamedPipe(String pipeName)", "Domain": "ACTION, CONDITION, QUERY", "Description": "null", "Parameters": [{"Name": "pipeName", "Type": "String", "Description": "Name of the pipe"}], "Returns": [{"Type": "Object"}], "Cautions": "none"},{"Function": "Cluster.isEventRecovered()", "Signature": "boolean isEventRecovered(SimpleEvent evt)", "Domain": "ACTION, CONDITION, QUERY", "Description": "This function returns true if the passed event is received from another agent in the cluster.\nThe function will return false if the event was created in this agent.", "Parameters": [{"Name": "evt", "Type": "SimpleEvent", "Description": "The event to be tested"}], "Returns": [{"Type": "boolean", "Description": "true"}], "Cautions": "none", "Example": "String cName = ClusterFunctions.isEventRecovered(SimpleEvent evt);"},{"Function": "Cluster.executeRuleFunction()", "Signature": "void runRuleFunction(String workMgrName, String ruleFnURI, boolean bInPreprocessContext, Object... args)", "Domain": "ACTION", "Description": "This function runs a rule function inside the context of a work manager", "Parameters": [{"Name": "workMgrName", "Type": "String", "Description": "The workMgrName - The thread that will execute the rule Function"}, {"Name": "ruleFnURI", "Type": "String", "Description": "The ruleFn to execute. This ruleFunction should return boolean true to continue, false to stop executing"}, {"Name": "bInPreprocessContext", "Type": "boolean", "Description": "Whether to execute in Pre-processor context"}, {"Name": "args", "Type": "Object[]", "Description": "The args for ruleFunction"}], "Returns": [{"Type": "void"}]},{"Function": "Cluster.createLocalNamedPipe()", "Signature": "boolean createLocalNamedPipe(String pipeName, int capacity)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Creates a per-JVM in-memory blocking queue/pipe for inter-thread communication.", "Parameters": [{"Name": "pipeName", "Type": "String", "Description": "Name of the pipe"}, {"Name": "capacity", "Type": "int", "Description": "Maximum capacity of the pipe"}], "Returns": [{"Type": "boolean", "Description": "true"}], "Cautions": "none"},{"Function": "Cluster.typeIdToURI()", "Signature": "String typeIdToURI(int typeId)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Returns the design time URI for the typeId", "Parameters": [{"Name": "typeId", "Type": "int", "Description": "The type id of the entity.  This comes from the typeId argument of a subscription preprocessor."}], "Returns": [{"Type": "String", "Description": "null"}], "Cautions": "none", "Example": "String eURI = ClusterFunctions.typeIdToURI(int typeId);"},{"Function": "Cluster.registerStateMachineTimeoutCallback()", "Signature": "void registerStateMachineTimeoutCallback(String entityURI, String ruleFunctionURI)", "Domain": "ACTION", "Description": "Register a rule function to pre-process state machine timeouts. The pre-processor should be used to load and/or\nlock associated objects.", "Parameters": [{"Name": "entityURI", "Type": "String", "Description": "URI for the concept. The preprocessor will be called when any states of state machines for these concepts timeout."}, {"Name": "ruleFunctionURI", "Type": "String", "Description": "URI for the pre-processor rulefunction."}], "Returns": [{"Type": "void"}]},{"Function": "Cluster.getSiteId()", "Signature": "long getSiteId()", "Domain": "ACTION, CONDITION, QUERY", "Description": "Returns the site-id of the cluster", "Parameters": "None.", "Returns": [{"Type": "long", "Description": "The site-id of the cluster"}], "Cautions": "none"},{"Function": "Cluster.getAgentId()", "Signature": "int getAgentId()", "Domain": "ACTION, CONDITION, QUERY", "Description": "Returns the unique id of the agent", "Parameters": "None.", "Returns": [{"Type": "int", "Description": "The id of the agent"}], "Cautions": "none", "Example": "int cAgentId = ClusterFunctions.getAgentId();"},{"Function": "Cluster.getAgentName()", "Signature": "String getAgentName()", "Domain": "ACTION, CONDITION, QUERY", "Description": "Returns the name of the BE Agent", "Parameters": "None.", "Returns": [{"Type": "String", "Description": "The name of the agent"}], "Cautions": "none", "Example": "String cName = ClusterFunctions.getAgentName();"},{"Function": "Cluster.stopWorkManager()", "Signature": "void stopWorkManager(String name)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Shuts down the work manager. This call will wait for all the current jobs to finish", "Parameters": [{"Name": "name", "Type": "String", "Description": "A unique name to identify the thread pool."}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Cluster.createWorkManager()", "Signature": "void createWorkManager(String name, int threadPool)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Creates a work manager to schedule background jobs", "Parameters": [{"Name": "name", "Type": "String", "Description": "A unique name to identify the thread pool"}, {"Name": "threadPool", "Type": "int", "Description": "Specify the number of threads in the pool"}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Cluster.createScheduler()", "Signature": "void createScheduler(String schedulerName, long pollInterval, long refreshAhead)", "Domain": "ACTION", "Description": "Creates a cluster wide scheduler for time dependent jobs. If the scheduler is created by another node, then the method can be used to overwrite\nthe pollInterval and refreshAhead", "Parameters": [{"Name": "schedulerName", "Type": "String", "Description": "A unique id"}, {"Name": "pollInterval", "Type": "long", "Description": "The time in milliseconds of polling the cache for due entries"}, {"Name": "refreshAhead", "Type": "long", "Description": "The time in milliseconds that is used to pre-load the entries from the underlying store to the scheduler cache"}], "Returns": [{"Type": "void"}]},{"Function": "Cluster.removeSchedule()", "Signature": "void removeSchedule(String schedulerName, String workKey)", "Domain": "ACTION", "Description": "Removes a previously scheduled task", "Parameters": [{"Name": "schedulerName", "Type": "String", "Description": "A unique id"}, {"Name": "workKey", "Type": "String", "Description": "A unique key"}], "Returns": [{"Type": "void"}]},{"Function": "Cluster.sendMessageOverLocalNamedPipe()", "Signature": "void sendMessageOverLocalNamedPipe(String pipeName, Object message)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Send a message over the pipe. If the pipe is full, then this call blocks until\nspace is available to place this message in the queue.", "Parameters": [{"Name": "pipeName", "Type": "String", "Description": "Name of the pipe"}, {"Name": "message", "Type": "Object", "Description": "The message to be sent over the pipe."}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Cluster.waitForMessageFromLocalNamedPipe()", "Signature": "Object waitForMessageFromLocalNamedPipe(String pipeName, long timeoutMillis)", "Domain": "ACTION, CONDITION, QUERY", "Description": "null", "Parameters": [{"Name": "pipeName", "Type": "String", "Description": "Name of the pipe"}, {"Name": "timeoutMillis", "Type": "long", "Description": "Specified timeout in milliseconds"}], "Returns": [{"Type": "Object"}], "Cautions": "none"},{"Function": "Cluster.getScheduleTime()", "Signature": "long getScheduleTime(String schedulerName, String workKey)", "Domain": "ACTION", "Description": "Returns the scheduled time of the entry identified with the key.", "Parameters": [{"Name": "schedulerName", "Type": "String", "Description": "Scheduler Name to check"}, {"Name": "workKey", "Type": "String", "Description": "Key associated to the entry"}], "Returns": [{"Type": "long", "Description": "Scheduled time of the entry matching the key"}]},{"Function": "Cluster.getLocalNamedPipeCurrentSize()", "Signature": "int getLocalNamedPipeCurrentSize(String pipeName)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Retrieves the current size of the pipe.", "Parameters": [{"Name": "pipeName", "Type": "String", "Description": "Name of the pipe"}], "Returns": [{"Type": "int", "Description": "the current size of the pipe"}], "Cautions": "none"},{"Function": "Cluster.getClusterName()", "Signature": "String getClusterName()", "Domain": "ACTION, CONDITION, QUERY", "Description": "Returns the name of the BE cluster that this agent is connected", "Parameters": "None.", "Returns": [{"Type": "String", "Description": "The name of the BE cluster"}], "Cautions": "none", "Example": "String cName = ClusterFunctions.getClusterName();"},{"Function": "Cluster.scheduleEvent()", "Signature": "void scheduleEvent(String schedulerName, String workKey, SimpleEvent event, long scheduledTime)", "Domain": "ACTION", "Description": "scheduledTime", "Parameters": [{"Name": "schedulerName", "Type": "String", "Description": "A unique id."}, {"Name": "workKey", "Type": "String", "Description": "A unique key that identifies the work item."}, {"Name": "event", "Type": "SimpleEvent", "Description": "The simple event to be scheduled."}, {"Name": "scheduledTime", "Type": "long", "Description": "The time in milliseconds when the event should be scheduled."}], "Returns": [{"Type": "void"}], "Cautions": "Events with default destinations on local channels will be received on the agent where the scheduler is running.  If your configuration allows schedulers to run on cache agents (this is the default), do not schedule events with default destinations on local channels."},{"Function": "Cluster.scheduleRepeatingEvent()", "Signature": "void scheduleRepeatingEvent(String schedulerName, String workKey, SimpleEvent event, DateTime startingDate, long interval)", "Domain": "ACTION", "Description": "startingDate", "Parameters": [{"Name": "schedulerName", "Type": "String", "Description": "A unique id."}, {"Name": "workKey", "Type": "String", "Description": "Cluster.removeSchedule()"}, {"Name": "event", "Type": "SimpleEvent", "Description": "The simple event to be scheduled."}, {"Name": "startingDate", "Type": "DateTime", "Description": "The starting date/time of repeating scheduled event (date/time will be rolled into future, if defined in the past)."}, {"Name": "interval", "Type": "long", "Description": "The repeat interval of the scheduled event (if 0, event will be scheduled once for the exact date/time specified)."}], "Returns": [{"Type": "void"}]},{"Function": "Cluster.DataGrid.CacheLoadEventById()", "Signature": "Event CacheLoadEventById(Object id)", "Domain": "ACTION", "Description": "Retrieve from the cache the event whose identifier is specified", "Parameters": [{"Name": "id", "Type": "Object", "Description": "Identifier for the targeted event, retrieved off"}], "Returns": [{"Type": "Event"}], "Cautions": "none"},{"Function": "Cluster.DataGrid.Index()", "Signature": "void Index(String cacheName, Object property, boolean isOrdered)", "Domain": "ACTION", "Description": "Creates an index on the property", "Parameters": [{"Name": "cacheName", "Type": "String", "Description": "CacheName"}, {"Name": "property", "Type": "Object", "Description": "Field name(s) or definition returned by AtomGetter. Use String[] when creating composite indexes using multiple field names"}, {"Name": "isOrdered", "Type": "boolean", "Description": "true if the contents of the indexed information should be ordered; false otherwise"}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Cluster.DataGrid.UnLock()", "Signature": "void UnLock(String key, boolean localOnly)", "Domain": "ACTION", "Description": "UnLocks the object represented by the key within a rule session.", "Parameters": [{"Name": "key", "Type": "String", "Description": "A key that uniquely identifies a lock"}, {"Name": "localOnly", "Type": "boolean", "Description": "true if the lock is local to the local session, false if the lock is cluster wide"}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Cluster.DataGrid.EvictCache()", "Signature": "void EvictCache(String cacheName, Object filter, boolean deleteFromPersistence)", "Domain": "ACTION", "Description": "Execute a query/filter based eviction from cache. Strictly to be used for entities with cache-only object management.\nIt will work only if \"Store Properties As Individual Fields\" is enabled in the CDD cluster setting.\nIt will not work with the history based properties.", "Parameters": [{"Name": "cacheName", "Type": "String", "Description": "CacheName"}, {"Name": "filter", "Type": "Object", "Description": "null"}, {"Name": "deleteFromPersistence", "Type": "boolean", "Description": "true"}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Cluster.DataGrid.ClassName()", "Signature": "String ClassName(String entityPath)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns the generated class name", "Parameters": [{"Name": "entityPath", "Type": "String", "Description": "Full path of the entity model"}], "Returns": [{"Type": "String", "Description": "entityPath"}], "Cautions": "none"},{"Function": "Cluster.DataGrid.CacheLoadConceptById()", "Signature": "Concept CacheLoadConceptById(Object id, boolean includeContained)", "Domain": "ACTION", "Description": "Retrieve from the cache the concept whose identifier is specified", "Parameters": [{"Name": "id", "Type": "Object", "Description": "Identifier for the targeted concept, retrieved off"}, {"Name": "includeContained", "Type": "boolean", "Description": "If true load the entire complex concept; if false load only the root concept"}], "Returns": [{"Type": "Concept"}], "Cautions": "none"},{"Function": "Cluster.DataGrid.EnableCacheUpdate()", "Signature": "void EnableCacheUpdate(boolean updateCache)", "Domain": "ACTION", "Description": "Set to true if the current RTC changes be replicated to the cache else RTC changes will lead to cache eviction instead of updates", "Parameters": [{"Name": "updateCache", "Type": "boolean", "Description": "true if the current RTC changes be replicated to the cache else RTC changes will lead to cache eviction instead of updates"}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Cluster.DataGrid.CacheReevaluate()", "Signature": "void CacheReevaluate(Entity entity)", "Domain": "ACTION", "Description": "Loads the entity into RETE and reevaluates all rules (allowed only in preprocessor)", "Parameters": "None.", "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Cluster.DataGrid.CacheLoadParent()", "Signature": "void CacheLoadParent(Concept cept, boolean recursive)", "Domain": "ACTION", "Description": "Loads from cache the parent concepts of the given concept.", "Parameters": [{"Name": "cept", "Type": "Concept", "Description": "Concept whose parent need to be loaded"}, {"Name": "recursive", "Type": "boolean", "Description": "If there is more than 1 level of parent hierarchy. Load parents at all levels if recursive=true, else load only immediate parent."}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Cluster.DataGrid.CacheLoadEntity()", "Signature": "void CacheLoadEntity(Entity entity)", "Domain": "ACTION", "Description": "Load the entity into RETE", "Parameters": [{"Name": "entity", "Type": "Entity"}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Cluster.DataGrid.Lock()", "Signature": "boolean Lock(String key, long timeout, boolean localOnly)", "Domain": "ACTION", "Description": "Locks the object within a rule session. This call will wait for timeout . The timeout value of zero indicates wait indefinitely", "Parameters": [{"Name": "key", "Type": "String", "Description": "A key that uniquely identifies a lock."}, {"Name": "timeout", "Type": "long", "Description": "Specify in milliseconds the time to wait for the lock."}, {"Name": "localOnly", "Type": "boolean", "Description": "true if the lock is local to the local session, false if the lock is cluster wide"}], "Returns": [{"Type": "boolean"}], "Cautions": "none"},{"Function": "Cluster.DataGrid.CacheName()", "Signature": "String CacheName(String entityPath)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "entityPath", "Parameters": [{"Name": "entityPath", "Type": "String", "Description": "Full path of the entity model"}], "Returns": [{"Type": "String", "Description": "entityPath"}], "Cautions": "none", "Example": "String cName = Cluster.DataGrid.CacheName($1/Concepts/Customer$1);"},{"Function": "Cluster.Sequence.createSequence()", "Signature": "void createSequence(String sequenceName, long start, long end, int cacheSize, boolean useDB)", "Domain": "ACTION, QUERY", "Description": "Creates a sequence across the cluster. If the sequence already exists, the call is ignored internally.", "Parameters": [{"Name": "sequenceName", "Type": "String", "Description": "A unique key"}, {"Name": "start", "Type": "long", "Description": "The starting point for the sequence"}, {"Name": "end", "Type": "long", "Description": "The end point for the sequence"}, {"Name": "cacheSize", "Type": "int", "Description": "The number of entries that will be cached by local instance"}, {"Name": "useDB", "Type": "boolean", "Description": "true if the database should be used to persist the sequence. This flag is only valid for cache aside"}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Cluster.Sequence.nextSequence()", "Signature": "Long nextSequence(String sequenceName)", "Domain": "ACTION, QUERY", "Description": "Returns the next sequence number", "Parameters": [{"Name": "sequenceName", "Type": "String", "Description": "A unique key"}], "Returns": [{"Type": "Long"}], "Cautions": "none"},{"Function": "Cluster.Sequence.resetSequence()", "Signature": "void resetSequence(String sequenceName, long start)", "Domain": "ACTION, QUERY", "Description": "Resets a sequence across the cluster", "Parameters": [{"Name": "sequenceName", "Type": "String", "Description": "A unique key"}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Cluster.Sequence.removeSequence()", "Signature": "void removeSequence(String sequenceName)", "Domain": "ACTION, QUERY", "Description": "Removes a sequence across the cluster", "Parameters": "None.", "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "XPath.executeWithEvent()", "Signature": "String executeWithEvent (String xpath, Event event, String prefixes)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Evaluate an XPath Expression against the input event.", "Parameters": [{"Name": "xpath", "Type": "String", "Description": "The XPath expression.  $var is required in front of the root element, for example: $1count($var/order/orderlines)$1."}, {"Name": "event", "Type": "Event", "Description": "The Event object on which the XPath expression executes."}, {"Name": "prefixes", "Type": "String", "Description": "The prefixes and namespaces in comma delimiter format, for example: $1xns1=http://www.tibco.com/be,xns2=http://www.tibco.com/support$1."}], "Returns": [{"Type": "String", "Description": "The result of the evaluation."}], "Cautions": "RuntimeException for an undefined property."},{"Function": "XPath.evalAsString()", "Signature": "String evalAsString (String path)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Evaluate the xpath expression on the objects as specified in XPathbuilder.", "Parameters": [{"Name": "path", "Type": "String", "Description": "Formed using XPathBuilder."}], "Returns": [{"Type": "String", "Description": "Returns the value identified by path param as String if exists, null otherwise."}], "Cautions": "Using more than one object is join in the rule's engine."},{"Function": "XPath.execute()", "Signature": "String execute (String xpath, String xml, String prefixes)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Evaluate an XPath Expression against the input XML String.", "Parameters": [{"Name": "xpath", "Type": "String", "Description": "The XPath expression.  $var is required in front of the root element, for example: $1count($var/order/orderlines)$1."}, {"Name": "xml", "Type": "String", "Description": "The XML string for the xpath to be executed on."}, {"Name": "prefixes", "Type": "String", "Description": "The prefixes and namespaces in comma delimiter format, for example: $1xns1=http://www.tibco.com/be,xns2=http://www.tibco.com/support$1."}], "Returns": [{"Type": "String", "Description": "The result of the evaluation."}], "Cautions": "RuntimeException for an undefined property."},{"Function": "XPath.evalAsLong()", "Signature": "long evalAsLong (String path)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Evaluate the xpath expression on the objects as specified in XPathbuilder.", "Parameters": [{"Name": "path", "Type": "String", "Description": "Formed using XPathBuilder."}], "Returns": [{"Type": "long", "Description": "Returns the value identified by path param as long if exists, 0L otherwise."}], "Cautions": "Using more than one object is join in the rule's engine."},{"Function": "XPath.evalAsDateTime()", "Signature": "DateTime evalAsDateTime (String path)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Evaluate the xpath expression on the objects as specified in XPathbuilder.", "Parameters": [{"Name": "path", "Type": "String", "Description": "Formed using XPathBuilder."}], "Returns": [{"Type": "DateTime", "Description": "Returns the value identified by path param as DateTime if exists, null otherwise."}], "Cautions": "Using more than one object is join in the rule's engine."},{"Function": "XPath.evalAsDouble()", "Signature": "double evalAsDouble (String path)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Evaluate the xpath expression on the objects as specified in XPathbuilder.", "Parameters": [{"Name": "path", "Type": "String", "Description": "Formed using XPathBuilder."}], "Returns": [{"Type": "double", "Description": "Returns the value identified by path param as double if exists, 0.0 otherwise."}], "Cautions": "Using more than one object is join in the rule's engine."},{"Function": "XPath.executeXPathWithEvent()", "Signature": "String[] executeXPathWithEvent (String xpath, Event event, String prefixes)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Evaluate an XPath Expression against the input event.", "Parameters": [{"Name": "xpath", "Type": "String", "Description": "$var"}, {"Name": "event", "Type": "Event", "Description": "The Event containing the payload on which the XPath expression executes."}, {"Name": "prefixes", "Type": "String", "Description": "The prefixes and namespaces used in the XPath expression, separated with commas. For example: $1myns=MyNameSpace,xsd=http://www.w3.org/2001/XMLSchema$1."}], "Returns": [{"Type": "String[]", "Description": "The result of the evaluation. Each node is returned as a separate string in the array."}], "Cautions": "RuntimeException for an undefined property."},{"Function": "XPath.evalAsBoolean()", "Signature": "boolean evalAsBoolean (String path)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Evaluate the xpath expression on the objects as specified in XPathbuilder.", "Parameters": [{"Name": "path", "Type": "String", "Description": "Formed using XPathBuilder."}], "Returns": [{"Type": "boolean", "Description": "true if the value identified by path param exists, false otherwise."}], "Cautions": "Using more than one object is join in the rule's engine."},{"Function": "XPath.evalAsInt()", "Signature": "int evalAsInt (String path) and return an int.", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Evaluate the xpath expression on the objects as specified in XPathbuilder.", "Parameters": [{"Name": "path", "Type": "String", "Description": "Formed using XPathBuilder."}], "Returns": [{"Type": "int", "Description": "Returns the value identified by path param as int if exists, 0 otherwise."}], "Cautions": "Using more than one object is join in the rule's engine."},{"Function": "File.fileExists()", "Signature": "boolean fileExists (String path)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Tests whether the file or directory denoted by the specified path exists.", "Parameters": [{"Name": "path", "Type": "String", "Description": "The target file or directory."}], "Returns": [{"Type": "boolean", "Description": "Returns true if the specified file/directory exists; otherwise, returns false."}], "Cautions": "none"},{"Function": "File.readFileAsBytes()", "Signature": "Object readFileAsBytes (String filePath)", "Domain": "ACTION, BUI", "Description": "Read the contents of the specified file and return a", "Parameters": [{"Name": "filePath", "Type": "String", "Description": "The file to read"}], "Returns": [{"Type": "Object", "Description": "Contents of the file as bytes"}], "Cautions": "none"},{"Function": "File.listFiles()", "Signature": "String[] listFiles (String dirPath, String filter)", "Domain": "ACTION", "Description": "Returns an array of files from the target directory that match the specified filter/pattern.", "Parameters": [{"Name": "dirPath", "Type": "String", "Description": "The target directory path."}, {"Name": "filter", "Type": "String", "Description": "An expression used to select the files - i.e., file names - of interest."}], "Returns": [{"Type": "String[]", "Description": "Returns an array of files from the target directory that match the specified filter/pattern."}], "Cautions": "none"},{"Function": "File.fileRename()", "Signature": "boolean fileRename (String srcPath, String destPath)", "Domain": "ACTION", "Description": "Renames the specified file or directory.", "Parameters": [{"Name": "srcPath", "Type": "String", "Description": "The original (/current) file or directory name."}, {"Name": "destPath", "Type": "String", "Description": "The target file or directory name."}], "Returns": [{"Type": "boolean", "Description": "Returns true if the rename is successful; false otherwise."}], "Cautions": "none"},{"Function": "File.fileWriteLine()", "Signature": "void fileWriteLine (Object fileWriter, String str)", "Domain": "ACTION", "Description": "Writes the new line to the file as a sequence of bytes starting at the current file-pointer position.", "Parameters": [{"Name": "fileWriter", "Type": "Object", "Description": "The target file."}, {"Name": "str", "Type": "String", "Description": "String to be written to the targeted file."}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "File.openFile()", "Signature": "Object openFile (String path, String mode)", "Domain": "ACTION", "Description": "Open the specified file for reading, and optionally, writing.", "Parameters": [{"Name": "path", "Type": "String", "Description": "The target directory path."}, {"Name": "mode", "Type": "String", "Description": "The access mode; i.e., $1r$1, $1rw$1, $1rws$1, or $1rwd$1"}], "Returns": [{"Type": "Object", "Description": "Returns a connection to the specified name."}], "Cautions": "none"},{"Function": "File.fileRemove()", "Signature": "boolean fileRemove (String path)", "Domain": "ACTION", "Description": "Deletes the specified file or directory.", "Parameters": [{"Name": "path", "Type": "String", "Description": "The file or directory to be deleted."}], "Returns": [{"Type": "boolean", "Description": "Returns true if the target file/directory is deleted; false otherwise."}], "Cautions": "none"},{"Function": "File.fileTruncateAndWrite()", "Signature": "void fileTruncateAndWrite(Object fileWriter, Object byteContents)", "Domain": "ACTION", "Description": "Truncate existing file and write any new contents.", "Parameters": [{"Name": "fileWriter", "Type": "Object", "Description": "The filewriter object."}, {"Name": "contents", "Type": "Object", "Description": "byte[] representing new contents to write."}], "Returns": [{"Type": "void"}]},{"Function": "File.fileLength()", "Signature": "long fileLength (Object writerReader)", "Domain": "ACTION", "Description": "Returns the length of the specified file (in bytes).", "Parameters": [{"Name": "writerReader", "Type": "Object", "Description": "The file whose current length is of interest."}], "Returns": [{"Type": "long", "Description": "Returns the length of the specified file (in bytes)."}], "Cautions": "none"},{"Function": "File.fileReadLine()", "Signature": "String fileReadLine (Object fileReader)", "Domain": "ACTION", "Description": "Reads the next line of text from the specified file.", "Parameters": [{"Name": "fileReader", "Type": "Object", "Description": "The file whose text line is to be read."}], "Returns": [{"Type": "String", "Description": "Returns the next line of text from the file; or null if EOF is immediately encountered."}], "Cautions": "none"},{"Function": "File.fileClose()", "Signature": "void fileClose (Object writerReader)", "Domain": "ACTION", "Description": "Closes the file that was previously opened with File.openFile().", "Parameters": [{"Name": "writerReader", "Type": "Object", "Description": "The file reader to be closed."}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "File.fileWriteBytes()", "Signature": "void fileWrite (Object fileWriter, Object bytes)", "Domain": "ACTION", "Description": "byte[]", "Parameters": [{"Name": "fileWriter", "Type": "Object", "Description": "The target file."}, {"Name": "bytes", "Type": "Object", "Description": "byte[]"}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "File.fileSeek()", "Signature": "void fileSeek (Object writerReader, long pos)", "Domain": "ACTION", "Description": "Sets the file-pointer offset at which the next read or write will occur.", "Parameters": [{"Name": "writerReader", "Type": "Object", "Description": "The target file."}, {"Name": "pos", "Type": "long", "Description": "The offset from the beginning of the file."}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "File.readFileAsString()", "Signature": "String readFileAsString(String filePath, [String encoding = $1UTF-8$1])", "Domain": "ACTION, BUI", "Description": "Read the contents of the specified file and return a string.", "Parameters": [{"Name": "filePath", "Type": "String", "Description": "The file to read"}, {"Name": "encodingArguments", "Type": "String", "Description": "Encoding used. Optional Parameter. Default value = $1UTF-8$1"}], "Returns": [{"Type": "String", "Description": "Contents of the file"}], "Cautions": "none"},{"Function": "File.createFolders()", "Signature": "boolean createFolders(String directoryPath, String folderPath)", "Domain": "ACTION, CONDITION, BUI", "Description": "Creates a folder structure on the file system for this filepath", "Parameters": [{"Name": "directoryPath", "Type": "String", "Description": "The directory to create folder in"}, {"Name": "filePath", "Type": "String", "Description": "The filePath whose folder structure has to be created"}], "Returns": [{"Type": "boolean", "Description": "Whether folder structure was created or not"}], "Cautions": "The filePath should not point to a directory"},{"Function": "File.createFolder()", "Signature": "boolean createFolder(String directoryPath, String folderName)", "Domain": "ACTION, CONDITION, BUI", "Description": "Creates a folder on the file system", "Parameters": [{"Name": "directoryPath", "Type": "String", "Description": "The directory to create folder in"}, {"Name": "folderName", "Type": "String", "Description": "The name of the folder to create"}], "Returns": [{"Type": "boolean", "Description": "Whether folder was created or not"}], "Cautions": "none"},{"Function": "File.fileWrite()", "Signature": "void fileWrite (Object fileWriter, String str)", "Domain": "ACTION", "Description": "Writes the string to the file as a sequence of bytes starting at the current file-pointer position.", "Parameters": [{"Name": "fileWriter", "Type": "Object", "Description": "The target file."}, {"Name": "str", "Type": "String", "Description": "String to be written to the targeted file."}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "DateTime.addWeek()", "Signature": "DateTime addWeek (DateTime date, int weeks)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Adds a number of weeks to a DateTime and returns the result. The input DateTime is not modified.", "Parameters": [{"Name": "date", "Type": "DateTime", "Description": "A DateTime to add some amount of time to."}, {"Name": "weeks", "Type": "int", "Description": "The number of weeks to add to the DateTime."}], "Returns": [{"Type": "DateTime", "Description": "date"}], "Cautions": "none"},{"Function": "DateTime.format()", "Signature": "String format (DateTime d1, String format)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Return the DateTime passed as a formatted String.", "Parameters": [{"Name": "d1", "Type": "DateTime", "Description": "A DateTime to be formatted."}, {"Name": "format", "Type": "String", "Description": "i.e. $1yyyy-MM-dd HH:mm:ss.SSS$1 is correct, but $1yyyy-MM-dd HH:mm:ss.S$1 is not valid."}], "Returns": [{"Type": "String", "Description": "A String representation of the supplied DateTime in the supplied format."}], "Cautions": "none"},{"Function": "DateTime.parseStringWithTimeZone()", "Signature": "DateTime parseStringWithTimeZone (String date, String format)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "date", "Parameters": [{"Name": "date", "Type": "String", "Description": "The date to parse. Timezone value is required  i.e. $2012-09-30T10:10:10-0600$1"}, {"Name": "format", "Type": "String", "Description": "Format used to parse the date and timezone against.  e.g. $1yyyy-MM-dd'T'HH:mm:ssZ$1"}], "Returns": [{"Type": "DateTime", "Description": "The result DateTime with the given timezone."}], "Cautions": "none", "See Also": "java.time.format.DateTimeFormatter"},{"Function": "DateTime.now()", "Signature": "DateTime now ()", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Return the current system time as a DateTime.", "Parameters": "None.", "Returns": [{"Type": "DateTime", "Description": "The current System time as a DateTime."}], "Cautions": "none"},{"Function": "DateTime.addSecond()", "Signature": "DateTime addSecond (DateTime date, int seconds)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Adds a number of seconds to a DateTime and returns the result. The input DateTime is not modified.", "Parameters": [{"Name": "date", "Type": "DateTime", "Description": "A DateTime to add some amount of time to."}, {"Name": "seconds", "Type": "int", "Description": "The number of seconds to add to the DateTime."}], "Returns": [{"Type": "DateTime", "Description": "date"}], "Cautions": "none"},{"Function": "DateTime.getSecond()", "Signature": "int getSecond(DateTime date)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the second on the DateTime Object passed as input.", "Parameters": [{"Name": "date", "Type": "DateTime", "Description": "A DateTime to get the second of."}], "Returns": [{"Type": "int", "Description": "date"}], "Cautions": "none"},{"Function": "DateTime.createTime()", "Signature": "DateTime createTime(int year, int month, int date, int hrs, int min, int sec, String tz)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Create a DateTime object of a particular timezone.   Month value is 0-based. 0 for January, 11 for December.", "Parameters": [{"Name": "year", "Type": "int", "Description": "The value of the YEAR time field."}, {"Name": "month", "Type": "int", "Description": "The value of the MONTH time field.  Month value is 0-based. e.g., 0 for January."}, {"Name": "date", "Type": "int", "Description": "The value of the DATE time field.  The day of month value between 1-31."}, {"Name": "hour", "Type": "int", "Description": "The value of the HOUR time field.  Hour value between 0-23."}, {"Name": "min", "Type": "int", "Description": "The value of the MINUTE time field.  Minute value between 0-59."}, {"Name": "sec", "Type": "int", "Description": "The value of the SECOND time field.  Second value between 0-59."}, {"Name": "tz", "Type": "String", "Description": "The Time Zone ID.  If null, the default TimeZone will be used."}], "Returns": [{"Type": "DateTime", "Description": "The created DateTime with timezone set to tz."}], "Cautions": "none"},{"Function": "DateTime.getTimeInMillis()", "Signature": "long getTimeInMillis (DateTime date)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns the time in milliseconds since the start of 1970 GMT.", "Parameters": [{"Name": "date", "Type": "DateTime", "Description": "A DateTime date/time which will be converted to milliseconds since the start of 1970 GMT."}], "Returns": [{"Type": "long", "Description": "The UTC time in milliseconds since start of 1970 GMT."}], "Cautions": "none"},{"Function": "DateTime.parseString()", "Signature": "DateTime parseString (String date, String format)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "date", "Parameters": [{"Name": "date", "Type": "String", "Description": "3 digits millisecond is required if parsing millisecond.  i.e. $103-11-2004 14:59:04.250$1 is correct, $103-11-2004 14:59:04.25$1 is not valid."}, {"Name": "format", "Type": "String", "Description": "A String containing a format describing how the date should be parsed.  e.g. $1MM-dd-yyyy HH:mm:ss$1, $1MM-dd-yyyy HH:mm:ss.SSS$1."}], "Returns": [{"Type": "DateTime", "Description": "The result DateTime."}], "Cautions": "none", "See Also": "java.text.SimpleDateFormat"},{"Function": "DateTime.after()", "Signature": "boolean after (DateTime d1, DateTime d2)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "after", "Parameters": [{"Name": "d1", "Type": "DateTime", "Description": "A DateTime (date/time) that will be compared with the second argument."}, {"Name": "d2", "Type": "DateTime", "Description": "A DateTime (date/time) that will be compared with the first argument."}], "Returns": [{"Type": "boolean", "Description": "d1"}], "Cautions": "none"},{"Function": "DateTime.addHour()", "Signature": "DateTime addHour(DateTime date, int hours)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Adds a number of hours to a DateTime and returns the result. The input DateTime is not modified.", "Parameters": [{"Name": "date", "Type": "DateTime", "Description": "A DateTime to add some amount of time to."}, {"Name": "hours", "Type": "int", "Description": "The number of hours to add to the DateTime."}], "Returns": [{"Type": "DateTime", "Description": "date"}], "Cautions": "none"},{"Function": "DateTime.getMinute()", "Signature": "int getMinute(DateTime date)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the minute on the DateTime Object passed as input.", "Parameters": [{"Name": "date", "Type": "DateTime", "Description": "A DateTime to get the minute of."}], "Returns": [{"Type": "int", "Description": "date"}], "Cautions": "none"},{"Function": "DateTime.addYear()", "Signature": "DateTime addYear (DateTime date, int years)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Adds a number of years to a DateTime and returns the result. The input DateTime is not modified.", "Parameters": [{"Name": "date", "Type": "DateTime", "Description": "A DateTime to add some amount of time to."}, {"Name": "years", "Type": "int", "Description": "The number of years to add to the DateTime."}], "Returns": [{"Type": "DateTime", "Description": "date"}], "Cautions": "none"},{"Function": "DateTime.getDate()", "Signature": "int getDate(DateTime date)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the date on the DateTime Object passed as input.", "Parameters": [{"Name": "date", "Type": "DateTime", "Description": "A DateTime to get the date of."}], "Returns": [{"Type": "int", "Description": "date"}], "Cautions": "none"},{"Function": "DateTime.equals()", "Signature": "boolean equals (DateTime d1, DateTime d2)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Test if the first DateTime the same as the second DateTime.", "Parameters": [{"Name": "d1", "Type": "DateTime", "Description": "A DateTime (date/time) that will be compared with the second argument."}, {"Name": "d2", "Type": "DateTime", "Description": "A DateTime (date/time) that will be compared with the first argument."}], "Returns": [{"Type": "boolean", "Description": "d1"}], "Cautions": "none"},{"Function": "DateTime.getYear()", "Signature": "int getYear(DateTime date)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the year on the DateTime Object passed as input.", "Parameters": [{"Name": "date", "Type": "DateTime", "Description": "A DateTime to get the year of."}], "Returns": [{"Type": "int", "Description": "date"}], "Cautions": "none"},{"Function": "DateTime.translateTime()", "Signature": "DateTime translateTime(DateTime date, String tz)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Translate a time to a new timezone and return the new translated DateTime object", "Parameters": [{"Name": "date", "Type": "DateTime", "Description": "The DateTime to be translated."}, {"Name": "tz", "Type": "String", "Description": "The Time Zone ID.  If null, use the default TimeZone."}], "Returns": [{"Type": "DateTime", "Description": "The new translated DateTime of timezone tz."}], "Cautions": "none"},{"Function": "DateTime.parseLong()", "Signature": "DateTime parseLong(long time)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Parses the time in milliseconds since the start of 1970 and return as a DateTime.", "Parameters": [{"Name": "time", "Type": "long", "Description": "The UTC time in milliseconds."}], "Returns": [{"Type": "DateTime", "Description": "The result DateTime."}], "Cautions": "none"},{"Function": "DateTime.getTimeZone()", "Signature": "String getTimeZone(DateTime date, boolean daylight_saving_name)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the timezone id from DateTime object.", "Parameters": [{"Name": "date", "Type": "DateTime", "Description": "A DateTime to get the timezone of."}, {"Name": "daylight_saving_name", "Type": "boolean", "Description": "If true returns the daylight savings name."}], "Returns": [{"Type": "String", "Description": "The timezone id."}], "Cautions": "none"},{"Function": "DateTime.notEquals()", "Signature": "boolean notEquals (DateTime d1, DateTime d2)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Compares the date time values of the arguments.", "Parameters": [{"Name": "d1", "Type": "DateTime", "Description": "A DateTime."}, {"Name": "d2", "Type": "DateTime", "Description": "A DateTime."}], "Returns": [{"Type": "boolean", "Description": "d1"}], "Cautions": "none"},{"Function": "DateTime.getHour()", "Signature": "int getHour(DateTime date)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the hour on the DateTime Object passed as input.", "Parameters": [{"Name": "date", "Type": "DateTime", "Description": "A DateTime to get the hour of."}], "Returns": [{"Type": "int", "Description": "date"}], "Cautions": "none"},{"Function": "DateTime.addMonth()", "Signature": "DateTime addMonth (DateTime date, int months)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Adds a number of months to a DateTime and returns the result. The input DateTime is not modified.", "Parameters": [{"Name": "date", "Type": "DateTime", "Description": "A DateTime to add some amount of time to."}, {"Name": "months", "Type": "int", "Description": "The number of months to add to the DateTime."}], "Returns": [{"Type": "DateTime", "Description": "date"}], "Cautions": "none"},{"Function": "DateTime.getMonth()", "Signature": "int getMonth(DateTime date)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the month on the DateTime Object passed as input.  Month value is 0-based.\ni.e. 0 for January, 11 for December.", "Parameters": [{"Name": "date", "Type": "DateTime", "Description": "A DateTime to get the month of."}], "Returns": [{"Type": "int", "Description": "date"}], "Cautions": "The first month of the year is 0."},{"Function": "DateTime.addDay()", "Signature": "DateTime addDay (DateTime date, int days)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Adds a number of days to a DateTime and returns the result. The input DateTime is not modified.", "Parameters": [{"Name": "date", "Type": "DateTime", "Description": "A DateTime to add some amount of time to."}, {"Name": "days", "Type": "int", "Description": "The number of days to add to the DateTime."}], "Returns": [{"Type": "DateTime", "Description": "date"}], "Cautions": "none"},{"Function": "DateTime.before()", "Signature": "boolean before (DateTime d1, DateTime d2)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Test if the first DateTime passed come before the second DateTime passed.", "Parameters": [{"Name": "d1", "Type": "DateTime", "Description": "A DateTime (date/time) that will be compared with the second argument."}, {"Name": "d2", "Type": "DateTime", "Description": "A DateTime (date/time) that will be compared with the first argument."}], "Returns": [{"Type": "boolean", "Description": "d1"}], "Cautions": "none"},{"Function": "DateTime.addMinute()", "Signature": "DateTime addMinute (DateTime date, int minutes)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Adds a number of minutes to a DateTime and returns the result. The input DateTime is not modified.", "Parameters": [{"Name": "date", "Type": "DateTime", "Description": "A DateTime to add some amount of time to."}, {"Name": "minutes", "Type": "int", "Description": "The number of minutes to add to the DateTime."}], "Returns": [{"Type": "DateTime", "Description": "date"}], "Cautions": "none"},{"Function": "Date.after()", "Signature": "boolean after (DateTime d1, DateTime d2)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Test if the first date come $1after$1 the second date, independently of the time of day.", "Parameters": [{"Name": "d1", "Type": "DateTime", "Description": "A DateTime (date/time) that will be compared with the second argument."}, {"Name": "d2", "Type": "DateTime", "Description": "A DateTime (date/time) that will be compared with the first argument."}], "Returns": [{"Type": "boolean", "Description": "d1"}], "Cautions": "none"},{"Function": "Date.today()", "Signature": "DateTime today ()", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Return the current date time as a DateTime.", "Parameters": "None.", "Returns": [{"Type": "DateTime", "Description": "The current date as a DateTime."}], "Cautions": "none", "Example": "String result = DateTime.format (Date.today (),  $1yyyy-MM-dd HH:mm:ss$1);\nResult is: result contains: $12004-03-11 00:00:0$1."},{"Function": "Date.equals()", "Signature": "boolean equals (DateTime d1, DateTime d2)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Test if the first date the same as the second date, independently of the time of day.", "Parameters": [{"Name": "d1", "Type": "DateTime", "Description": "A DateTime (date/time) that will be compared with the second argument."}, {"Name": "d2", "Type": "DateTime", "Description": "A DateTime (date/time) that will be compared with the first argument."}], "Returns": [{"Type": "boolean", "Description": "true if d1 is the same as d2, otherwise return false."}], "Cautions": "none"},{"Function": "Date.before()", "Signature": "boolean before (DateTime d1, DateTime d2)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Test if the first date come before the second date, independently of the time of day.", "Parameters": [{"Name": "d1", "Type": "DateTime", "Description": "A DateTime (date/time) that will be compared with the second argument."}, {"Name": "d2", "Type": "DateTime", "Description": "A DateTime (date/time) that will be compared with the first argument."}], "Returns": [{"Type": "boolean", "Description": "d1"}], "Cautions": "none"},{"Function": "SOAP.addSOAPBodyPart()", "Signature": "void addSOAPBodyPart (SimpleEvent soapEvent,String bodyXml)", "Domain": "ACTION, BUI", "Description": "Adds a body fragment as a child of the standard SOAP body.\nThis fragment should be a well formed xml.", "Parameters": [{"Name": "soapEvent", "Type": "SimpleEvent", "Description": "SOAP event"}, {"Name": "bodyXml", "Type": "String", "Description": "XML string of body to set"}], "Returns": [{"Type": "void"}]},{"Function": "SOAP.addFaultPart()", "Signature": "void addFaultPart (SimpleEvent soapEvent,String faultCode,String faultMessage,String faultActor,String faultDetailString)", "Domain": "ACTION, BUI", "Description": "Adds a <fault> element to the standard SOAP body", "Parameters": [{"Name": "soapEvent", "Type": "SimpleEvent", "Description": "SOAP event"}, {"Name": "faultCode", "Type": "String", "Description": "The mandatory fault code"}, {"Name": "faultMessage", "Type": "String", "Description": "The mandatory fault message"}, {"Name": "faultActor", "Type": "String", "Description": "The optional Fault actor"}, {"Name": "faultDetailString", "Type": "String", "Description": "Optional XML string representing the fault detail"}], "Returns": [{"Type": "void"}]},{"Function": "SOAP.getAttachmentContentByContentID()", "Signature": "Object getAttachmentContentByContentID(SimpleEvent soapEvent,String contentID)", "Domain": "ACTION, CONDITION, BUI", "Description": "Gets the content of the attachment in byte[] form.\nReturns a null if no attachment is found with the given content ID.", "Parameters": [{"Name": "soapEvent", "Type": "SimpleEvent", "Description": "SOAP event"}, {"Name": "contentID", "Type": "String", "Description": "The contentID to search for"}], "Returns": [{"Type": "Object", "Description": "attachment content in byte[] form"}]},{"Function": "SOAP.getFault()", "Signature": "String getFault (SimpleEvent soapEvent)", "Domain": "ACTION, CONDITION, BUI", "Description": "Gets the SOAP <Fault> element from the SOAP event", "Parameters": [{"Name": "soapEvent", "Type": "SimpleEvent", "Description": "The request SOAP event"}], "Returns": [{"Type": "String", "Description": "matching a SOAP fault"}], "Cautions": "The fault is located only in the body and not anywhere else"},{"Function": "SOAP.getFaultCode()", "Signature": "String getFaultCode (SimpleEvent soapEvent)", "Domain": "ACTION, CONDITION, BUI", "Description": "Gets the <faultcode> from the SOAP event.", "Parameters": [{"Name": "soapEvent", "Type": "SimpleEvent", "Description": "The request SOAP event"}], "Returns": [{"Type": "String", "Description": "The matching fault code"}], "Cautions": "The fault is located only in the body and not anywhere else"},{"Function": "SOAP.getFaultActor()", "Signature": "String getFaultActor (SimpleEvent soapEvent)", "Domain": "ACTION, CONDITION, BUI", "Description": "Gets the <faultactor> from the SOAP event.", "Parameters": [{"Name": "soapEvent", "Type": "SimpleEvent", "Description": "The request SOAP event"}], "Returns": [{"Type": "String", "Description": "matching <faultactor> value"}], "Cautions": "The fault is located only in the body and not anywhere else"},{"Function": "SOAP.getSOAPBodyParts()", "Signature": "String[] getSOAPBodyParts (SimpleEvent soapEvent, String name, String namespace)", "Domain": "ACTION, CONDITION, BUI", "Description": "Gets the SOAP <Body> parts matching the name and namespace from the SOAP event", "Parameters": [{"Name": "soapEvent", "Type": "SimpleEvent", "Description": "The request SOAP event"}, {"Name": "name", "Type": "String", "Description": "The local name of the part."}, {"Name": "namespace", "Type": "String", "Description": "The namespace of the body part."}], "Returns": [{"Type": "String[]", "Description": "An array of matching SOAP body parts."}], "Example": {"_attributes": {"class": ["content"]}, "p": [{"_value": "getSOAPBodyParts(event, $1localname$1, $1http://abc.com/namespace$1) will match all children of body\nwith this name, and namespace"}]}},{"Function": "SOAP.getAttachmentContentType()", "Signature": "String getAttachmentContentType(SimpleEvent soapEvent,int index)", "Domain": "ACTION, CONDITION, BUI", "Description": "Gets the String value content type of the attachment.\nThe attachment is specified using the index.", "Parameters": [{"Name": "soapEvent", "Type": "SimpleEvent", "Description": "SOAP event"}, {"Name": "index", "Type": "int", "Description": "attachment index"}], "Returns": [{"Type": "String", "Description": "attachment content type"}]},{"Function": "SOAP.getNumberOfAttachments()", "Signature": "int getNumberOfAttachments(SimpleEvent soapEvent)", "Domain": "ACTION, CONDITION, BUI", "Description": "Gets a count of SOAP attachments in the incoming SOAP message.", "Parameters": [{"Name": "soapEvent", "Type": "SimpleEvent", "Description": "SOAP event"}], "Returns": [{"Type": "int", "Description": "number of attachments"}]},{"Function": "SOAP.getSOAPHeaderAttribute()", "Signature": "String getSOAPHeaderAttribute (SimpleEvent soapEvent, int index, String attribute)", "Domain": "ACTION, CONDITION, BUI", "Description": "Gets the value of the given attribute for the header part\nat the specified index in header body of the Simple event", "Parameters": [{"Name": "soapEvent", "Type": "SimpleEvent", "Description": "The SOAP Event"}, {"Name": "index", "Type": "int", "Description": "The index of the header required which should be in the range of the list."}, {"Name": "attribute", "Type": "String", "Description": "Name of the header attribute"}], "Returns": [{"Type": "String", "Description": "The value of the specified SOAP header attribute"}]},{"Function": "SOAP.addSOAPHeaderAttribute()", "Signature": "void addSOAPHeaderAttribute(SimpleEvent soapEvent,int index, String attribute, String value)", "Domain": "ACTION, BUI", "Description": "Add attribute to SOAP header", "Parameters": [{"Name": "soapEvent", "Type": "SimpleEvent", "Description": "To add attachment for this event"}, {"Name": "index", "Type": "int", "Description": "The index of the header required which should be in the range of the header parts list."}, {"Name": "attribute", "Type": "String", "Description": "attribute name"}, {"Name": "value", "Type": "String", "Description": "attribute's value"}], "Returns": [{"Type": "void"}]},{"Function": "SOAP.newCorrelationId()", "Signature": "void newCorrelationId(String responseEventUri)", "Domain": "ACTION, BUI", "Description": "Creates a new correlation ID for use in request/response. This is used by some SOAP deserializers to generate events of specific types, instead of using the default event type resolution mechanisms.", "Parameters": [{"Name": "responseEventUri", "Type": "String", "Description": "Path of an event type in the project."}], "Returns": [{"Type": "String", "Description": "Correlation ID."}]},{"Function": "SOAP.removeHeaderParts()", "Signature": "void removeHeaderParts (SimpleEvent soapEvent, String actor)", "Domain": "ACTION, BUI", "Description": "Removes 0 or more children of a SOAP <Header> of a SOAP message.", "Parameters": [{"Name": "soapEvent", "Type": "SimpleEvent", "Description": "SOAP event"}], "Returns": [{"Type": "void"}]},{"Function": "SOAP.signSOAPEnvelope()", "Signature": "void signSOAPEnvelope (SimpleEvent soapEvent, Object clientKeyStore, String trustedCertsFolder, String ksPassword, String alias)", "Domain": "ACTION, QUERY, BUI", "Description": "Signs the entire SOAP Request envelope using the certificate information provided.", "Parameters": [{"Name": "soapEvent", "Type": "SimpleEvent", "Description": "SOAP event"}, {"Name": "keystore", "Type": "Object", "Description": "Keystore object"}, {"Name": "trustedCertsFolder", "Type": "String", "Description": "The relative path of the folder containing the certificates. Certificates folder has to be inside project"}, {"Name": "ksPassword", "Type": "String", "Description": "Obfuscated password for the keystore"}, {"Name": "alias", "Type": "String", "Description": "Alias associated to the keystore"}], "Returns": [{"Type": "void"}]},{"Function": "SOAP.registerEventUri()", "Signature": "void registerEventUri(String eventUri, String destinationUri, String serviceName, String soapAction, String preprocessor)", "Domain": "ACTION", "Description": "Associates an event type to a given input destination, target service, and SOAP action. This is used by some SOAP deserializers to generate events of specific types, instead of using the default event type resolution mechanisms.", "Parameters": [{"Name": "eventUri", "Type": "String", "Description": "Path of an event type in the project."}, {"Name": "destinationUri", "Type": "String", "Description": "Path of the BusinessEvents destination receiving the message. If empty, matches all destinations."}, {"Name": "serviceName", "Type": "String", "Description": "(Optional) name of the target service declared in the message received. If empty, matches all service names."}, {"Name": "soapAction", "Type": "String", "Description": "(Optional) value of the soapAction parameter in the message received."}, {"Name": "preprocessor", "Type": "String", "Description": "(Optional) path to a preprocessor RuleFunction."}], "Returns": [{"Type": "void"}]},{"Function": "SOAP.getAttachmentContentID()", "Signature": "String getAttachmentContentID(SimpleEvent soapEvent,int index)", "Domain": "ACTION, CONDITION, BUI", "Description": "Gets the String value content ID of the attachment.\nThe attachment is specified using the index.", "Parameters": [{"Name": "soapEvent", "Type": "SimpleEvent", "Description": "SOAP event"}, {"Name": "index", "Type": "int", "Description": "attachment index"}], "Returns": [{"Type": "String", "Description": "attachment content ID"}]},{"Function": "SOAP.getEnvelope()", "Signature": "String getEnvelope (SimpleEvent soapEvent)", "Domain": "ACTION, CONDITION, BUI", "Description": "Gets the standard SOAP envelope xml node from the\npayload of this SOAP event.", "Parameters": [{"Name": "soapEvent", "Type": "SimpleEvent", "Description": "The request SOAP event"}], "Returns": [{"Type": "String", "Description": "The matching a SOAP envelope"}]},{"Function": "SOAP.addHeaderPart()", "Signature": "void addHeaderPart (SimpleEvent soapEvent, String headerPartXml)", "Domain": "ACTION, BUI", "Description": "Adds a header fragment as a child of the standard SOAP header.\nThis fragment should be a well formed XML.", "Parameters": [{"Name": "soapEvent", "Type": "SimpleEvent", "Description": "SOAP event"}, {"Name": "headerPartXml", "Type": "String", "Description": "XML string of header to set"}], "Returns": [{"Type": "void"}]},{"Function": "SOAP.getFaultString()", "Signature": "String getFaultString (SimpleEvent soapEvent)", "Domain": "ACTION, CONDITION, BUI", "Description": "Gets the <faultstring> from the SOAP event.", "Parameters": [{"Name": "soapEvent", "Type": "SimpleEvent", "Description": "The request SOAP event"}], "Returns": [{"Type": "String", "Description": "matching fault String"}], "Cautions": "The fault is located only in the body and not anywhere else"},{"Function": "SOAP.getHeaders()", "Signature": "String[] getHeaders(SimpleEvent soapEvent, String actor, boolean removeHeaders)", "Domain": "ACTION, CONDITION, BUI", "Description": "Gets a list of headers inside the <Header> element of a SOAP message.", "Parameters": [{"Name": "soapEvent", "Type": "SimpleEvent", "Description": "The request SOAP event"}, {"Name": "actor", "Type": "String", "Description": "The actor attribute. Use null to get all headers"}, {"Name": "removeHeaders", "Type": "boolean", "Description": "from the SOAP headers. Setting this parameter value to true will remove the header."}], "Returns": [{"Type": "String[]"}]},{"Function": "SOAP.addAttachment()", "Signature": "void addAttachment(SimpleEvent soapEvent,String contentID, Object content,String contentType)", "Domain": "ACTION, BUI", "Description": "Adds a new attachment to the SOAP message.", "Parameters": [{"Name": "soapEvent", "Type": "SimpleEvent", "Description": "To add attachment for this event"}, {"Name": "contentID", "Type": "String", "Description": "Content ID for this attachment"}, {"Name": "content", "Type": "Object", "Description": "String/byte[] representation of the content"}, {"Name": "contentType", "Type": "String", "Description": "Content Type for this attachment"}], "Returns": [{"Type": "void"}]},{"Function": "SOAP.removeHeaderPart()", "Signature": "void removeHeaderPart (SimpleEvent soapEvent, String namespace, String name)", "Domain": "ACTION, BUI", "Description": "Removes 0 or more children of a SOAP <Header> of a SOAP message.", "Parameters": [{"Name": "soapEvent", "Type": "SimpleEvent", "Description": "SOAP event"}, {"Name": "namespace", "Type": "String", "Description": "part with this namespace to be removed."}, {"Name": "name", "Type": "String", "Description": "part with this element name to be removed."}], "Returns": [{"Type": "void"}]},{"Function": "SOAP.getAttachmentContent()", "Signature": "Object getAttachmentContent(SimpleEvent soapEvent,int index)", "Domain": "ACTION, CONDITION, BUI", "Description": "Gets the content of the attachment in byte[] form.\nThe attachment is specified using the index. will return null in case of no attachment", "Parameters": [{"Name": "soapEvent", "Type": "SimpleEvent", "Description": "SOAP event"}, {"Name": "index", "Type": "int", "Description": "attachment index"}], "Returns": [{"Type": "Object", "Description": "attachment content as byte[]"}]},{"Function": "SOAP.getAllSOAPBodyParts()", "Signature": "String[] getAllSOAPBodyParts (SimpleEvent soapEvent)", "Domain": "ACTION, CONDITION, BUI", "Description": "Gets all SOAP <Body> parts from the SOAP event", "Parameters": [{"Name": "soapEvent", "Type": "SimpleEvent", "Description": "The request SOAP event"}], "Returns": [{"Type": "String[]"}]},{"Function": "Math.atan()", "Signature": "double atan (double a)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Returns the arc tangent of an angle, in the range of -pi/2\nthrough pi/ 2.  Special cases:\nIf the argument is NaN, then the result is NaN.\nIf the argument is zero, then the result is a zero with the\nsame sign as the argument.\nA result must be within 1 ulp of the correctly rounded result.  Results\nmust be semi-monotonic.", "Parameters": [{"Name": "a", "Type": "double", "Description": "The value whose arc tangent is to be returned."}], "Returns": [{"Type": "double", "Description": "The arc tangent of the argument."}], "Cautions": "none"},{"Function": "Math.asin()", "Signature": "double asin (double a)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Returns the arc sine of an angle, in the range of -pi/2 through\npi/2. Special cases:\nIf the argument is NaN or its absolute value is greater\nthan 1, then the result is NaN.\nIf the argument is zero, then the result is a zero with the\nsame sign as the argument.\nA result must be within 1 ulp of the correctly rounded result.  Results\nmust be semi-monotonic.", "Parameters": [{"Name": "a", "Type": "double", "Description": "The value whose arc sine is to be returned."}], "Returns": [{"Type": "double", "Description": "The arc sine of the argument."}], "Cautions": "none"},{"Function": "Math.rint()", "Signature": "double rint (double a)", "Domain": "ACTION, CONDITION, QUERY", "Description": "double", "Parameters": [{"Name": "a", "Type": "double", "Description": "double"}], "Returns": [{"Type": "double", "Description": "a"}], "Cautions": "none"},{"Function": "Math.atanRectangularToPolar()", "Signature": "double atanRectangularToPolar (double y, double x)", "Domain": "ACTION, CONDITION, QUERY", "Description": "y/x", "Parameters": [{"Name": "y", "Type": "double", "Description": "The ordinate coordinate."}, {"Name": "x", "Type": "double", "Description": "The abscissa coordinate."}], "Returns": [{"Type": "double"}], "Cautions": "none"},{"Function": "Math.toDegrees()", "Signature": "double toDegrees (double angrad)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "cos(toRadians(90.0))", "Parameters": [{"Name": "angrad", "Type": "double", "Description": "An angle, in radians."}], "Returns": [{"Type": "double", "Description": "angrad"}], "Cautions": "none"},{"Function": "Math.round()", "Signature": "long round (double a)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "long", "Parameters": [{"Name": "a", "Type": "double", "Description": "long"}], "Returns": [{"Type": "long", "Description": "long"}], "Cautions": "none", "See Also": "java.lang.Long#MIN_VALUE"},{"Function": "Math.cos()", "Signature": "double cos (double a)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Returns the trigonometric cosine of an angle. Special cases:\nIf the argument is NaN or an infinity, then the result is NaN.\nA result must be within 1 ulp of the correctly rounded result.  Results\nmust be semi-monotonic.", "Parameters": [{"Name": "a", "Type": "double", "Description": "An angle, in radians."}], "Returns": [{"Type": "double", "Description": "The cosine of the argument."}], "Cautions": "none"},{"Function": "Math.roundFraction()", "Signature": "double roundFraction (double d1, int precision)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "d1", "Parameters": [{"Name": "d1", "Type": "double", "Description": "The number to round."}, {"Name": "precision", "Type": "int", "Description": "Length of precision."}], "Returns": [{"Type": "double", "Description": "The result."}], "Cautions": "none"},{"Function": "Math.sqrt()", "Signature": "double sqrt (double a)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "double", "Parameters": [{"Name": "a", "Type": "double", "Description": "A value."}], "Returns": [{"Type": "double", "Description": "a"}], "Cautions": "none"},{"Function": "Math.pow()", "Signature": "double pow (double a, double b)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "double", "Parameters": [{"Name": "a", "Type": "double", "Description": "The base."}, {"Name": "b", "Type": "double", "Description": "The exponent."}], "Returns": [{"Type": "double", "Description": "a"}], "Cautions": "none"},{"Function": "Math.exp()", "Signature": "double exp (double a)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "double", "Parameters": [{"Name": "a", "Type": "double"}], "Returns": [{"Type": "double"}], "Cautions": "none"},{"Function": "Math.maxDouble()", "Signature": "double maxDouble (double a, double b)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "double", "Parameters": [{"Name": "a", "Type": "double", "Description": "An argument."}, {"Name": "b", "Type": "double", "Description": "Another argument."}], "Returns": [{"Type": "double", "Description": "a"}], "Cautions": "none"},{"Function": "Math.toRadians()", "Signature": "double toRadians (double angdeg)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Converts an angle measured in degrees to an approximately\nequivalent angle measured in radians.  The conversion from\ndegrees to radians is generally inexact.", "Parameters": [{"Name": "angdeg", "Type": "double", "Description": "An angle, in degrees."}], "Returns": [{"Type": "double", "Description": "angdeg"}], "Cautions": "none"},{"Function": "Math.maxInt()", "Signature": "int maxInt (int a, int b)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "int", "Parameters": [{"Name": "a", "Type": "int", "Description": "An argument."}, {"Name": "b", "Type": "int", "Description": "Another argument."}], "Returns": [{"Type": "int", "Description": "a"}], "Cautions": "none", "See Also": "java.lang.Long#MAX_VALUE"},{"Function": "Math.ceil()", "Signature": "double ceil (double a)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "double", "Parameters": [{"Name": "a", "Type": "double", "Description": "A value."}], "Returns": [{"Type": "double", "Description": "The smallest (closest to negative infinity)\nfloating-point value that is not less than the argument\nand is equal to a mathematical integer."}], "Cautions": "none"},{"Function": "Math.minInt()", "Signature": "int minInt (int a, int b)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "int", "Parameters": [{"Name": "a", "Type": "int", "Description": "An argument."}, {"Name": "b", "Type": "int", "Description": "Another argument."}], "Returns": [{"Type": "int", "Description": "a"}], "Cautions": "none", "See Also": "java.lang.Long#MIN_VALUE"},{"Function": "Math.absDouble()", "Signature": "double absDouble (double a)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns the absolute value of a double value.\nIf the argument is not negative, the argument is returned.\nIf the argument is negative, the negation of the argument is returned.\nSpecial cases:\nIf the argument is positive zero or negative zero, the result\nis positive zero.\nIf the argument is infinite, the result is positive infinity.\nIf the argument is NaN, the result is NaN.\nIn other words, the result is the same as the value of the expression:\nDouble.longBitsToDouble((Double.doubleToLongBits(a)<<1)>>>1)", "Parameters": [{"Name": "a", "Type": "double", "Description": "The argument whose absolute value is to be determined."}], "Returns": [{"Type": "double", "Description": "The absolute value of the argument."}], "Cautions": "none"},{"Function": "Math.random()", "Signature": "double random ()", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "double", "Parameters": "None.", "Returns": [{"Type": "double", "Description": "double"}], "Cautions": "none", "See Also": "java.util.Random#nextDouble()"},{"Function": "Math.IEEEremainder()", "Signature": "double IEEEremainder (double f1, double f2)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Computes the remainder operation on two arguments as prescribed\nby the IEEE 754 standard.\nThe remainder value is mathematically equal to\nf1 - f2 X n, \nwhere n is the mathematical integer closest to the exact\nmathematical value of the quotient f1/f2, and if two\nmathematical integers are equally close to f1/f2,\nthen n is the integer that is even. If the remainder is\nzero, its sign is the same as the sign of the first argument.\nSpecial cases:\nIf either argument is NaN, or the first argument is infinite,\nor the second argument is positive zero or negative zero, then the\nresult is NaN.\nIf the first argument is finite and the second argument is\ninfinite, then the result is the same as the first argument.", "Parameters": [{"Name": "f1", "Type": "double", "Description": "The dividend."}, {"Name": "f2", "Type": "double", "Description": "The divisor."}], "Returns": [{"Type": "double", "Description": "f1"}], "Cautions": "none"},{"Function": "Math.maxLong()", "Signature": "long maxLong (long a, long b)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "long", "Parameters": [{"Name": "a", "Type": "long", "Description": "An argument."}, {"Name": "b", "Type": "long", "Description": "Another argument."}], "Returns": [{"Type": "long", "Description": "a"}], "Cautions": "none", "See Also": "java.lang.Long#MAX_VALUE"},{"Function": "Math.log()", "Signature": "double log (double a)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "double", "Parameters": [{"Name": "a", "Type": "double", "Description": "0.0"}], "Returns": [{"Type": "double", "Description": "a"}], "Cautions": "none"},{"Function": "Math.acos()", "Signature": "double acos (double a)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Returns the arc cosine of an angle, in the range of 0.0 through\npi.  Special case:\nIf the argument is NaN or its absolute value is greater\nthan 1, then the result is NaN.\nA result must be within 1 ulp of the correctly rounded result.  Results\nmust be semi-monotonic.", "Parameters": [{"Name": "a", "Type": "double", "Description": "The value whose arc cosine is to be returned."}], "Returns": [{"Type": "double", "Description": "The arc cosine of the argument."}], "Cautions": "none"},{"Function": "Math.floor()", "Signature": "double floor (double a)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "double", "Parameters": [{"Name": "a", "Type": "double", "Description": "A value."}], "Returns": [{"Type": "double", "Description": "The largest (closest to positive infinity)\nfloating-point value that is not greater than the argument\nand is equal to a mathematical integer."}], "Cautions": "none"},{"Function": "Math.minDouble()", "Signature": "double minDouble (double a, double b)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "double", "Parameters": [{"Name": "a", "Type": "double", "Description": "An argument."}, {"Name": "b", "Type": "double", "Description": "Another argument."}], "Returns": [{"Type": "double", "Description": "a"}], "Cautions": "none"},{"Function": "Math.absInt()", "Signature": "int absInt (int a)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns the absolute value of an int value.\nIf the argument is not negative, the argument is returned.\nIf the argument is negative, the negation of the argument is returned.\nNote that if the argument is equal to the value of\nInteger.MIN_VALUE, the most negative representable\nint value, the result is that same value, which is\nnegative.", "Parameters": [{"Name": "a", "Type": "int", "Description": "The argument whose absolute value is to be determined."}], "Returns": [{"Type": "int", "Description": "The absolute value of the argument."}], "Cautions": "none", "See Also": "java.lang.Integer#MIN_VALUE"},{"Function": "Math.sin()", "Signature": "double sin (double a)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Returns the trigonometric sine of an angle.  Special cases:\nIf the argument is NaN or an infinity, then the result is NaN.\nIf the argument is zero, then the result is a zero with the\nsame sign as the argument.\nA result must be within 1 ulp of the correctly rounded result.  Results\nmust be semi-monotonic.", "Parameters": [{"Name": "a", "Type": "double", "Description": "An angle, in radians."}], "Returns": [{"Type": "double", "Description": "The sine of the argument."}], "Cautions": "none"},{"Function": "Math.absLong()", "Signature": "long absLong (long a)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns the absolute value of a long value.\nIf the argument is not negative, the argument is returned.\nIf the argument is negative, the negation of the argument is returned.\nNote that if the argument is equal to the value of\nLong.MIN_VALUE, the most negative representable\nlong value, the result is that same value, which is\nnegative.", "Parameters": [{"Name": "a", "Type": "long", "Description": "The argument whose absolute value is to be determined."}], "Returns": [{"Type": "long", "Description": "The absolute value of the argument."}], "Cautions": "none", "See Also": "java.lang.Long#MIN_VALUE"},{"Function": "Math.tan()", "Signature": "double tan (double a)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Returns the trigonometric tangent of an angle.  Special cases:\nIf the argument is NaN or an infinity, then the result is NaN.\nIf the argument is zero, then the result is a zero with the\nsame sign as the argument.\nA result must be within 1 ulp of the correctly rounded result.  Results\nmust be semi-monotonic.", "Parameters": [{"Name": "a", "Type": "double", "Description": "An angle, in radians."}], "Returns": [{"Type": "double", "Description": "The tangent of the argument."}], "Cautions": "none"},{"Function": "Math.minLong()", "Signature": "long minLong (long a, long b)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "long", "Parameters": [{"Name": "a", "Type": "long", "Description": "An argument."}, {"Name": "b", "Type": "long", "Description": "Another argument."}], "Returns": [{"Type": "long", "Description": "a"}], "Cautions": "none", "See Also": "java.lang.Long#MIN_VALUE"},{"Function": "Number.longValue()", "Signature": "long longValue (String s, int radix)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns an long holding the value extracted from the specified String when\nparsed with the radix given by the second argument. The first argument is\ninterpreted as representing a signed long in the radix specified by the\nsecond argument. The result is a long object that represents the long\nvalue specified by the string.", "Parameters": [{"Name": "s", "Type": "String", "Description": "A String containing a long (in the radix specified) to be converted to an long."}, {"Name": "radix", "Type": "int", "Description": "s"}], "Returns": [{"Type": "long", "Description": "The value of the long in the String passed based on the passed radix (number base)."}], "Cautions": "none"},{"Function": "Number.valueOfString()", "Signature": "int valueOfString (String s, int radix)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns an int holding the value extracted from the specified String when\nparsed with the radix given by the second argument. The first argument is\ninterpreted as representing a signed integer in the radix specified by the\nsecond argument. The result is an Integer object that represents the integer\nvalue specified by the string.", "Parameters": [{"Name": "s", "Type": "String", "Description": "A String containing an integer (in the radix specified) to be converted to an int."}, {"Name": "radix", "Type": "int", "Description": "s"}], "Returns": [{"Type": "int", "Description": "The value of the integer in the String passed based on the passed radix (number base)."}], "Cautions": "none"},{"Function": "Number.MAX_VALUE()", "Signature": "int MAX_VALUE ()", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Return the maximum value an int can have, 2^31-1.", "Parameters": "None.", "Returns": [{"Type": "int", "Description": "The maximum value an int can have, 2^31-1."}], "Cautions": "none", "See Also": "java.lang.Integer#MAX_VALUE"},{"Function": "Number.toHexString()", "Signature": "String toHexString (int i)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Return a String containing the hexadecimal representation of the int passed.", "Parameters": [{"Name": "i", "Type": "int", "Description": "An int to convert to a hexadecimal String."}], "Returns": [{"Type": "String", "Description": "A String containing the hexadecimal representation of the int passed."}], "Cautions": "none"},{"Function": "Number.doubleValue()", "Signature": "double doubleValue (String s)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns an double holding the value extracted from the specified String.\nThe first argument is interpreted as representing a signed double.\nThe result is a double that represents the double value specified by the string.", "Parameters": [{"Name": "s", "Type": "String", "Description": "A String with a double format."}], "Returns": [{"Type": "double", "Description": "The value of the double in the String passed."}], "Cautions": "none"},{"Function": "Number.valueOfFloat()", "Signature": "int valueOfFloat (float f)", "Domain": "ACTION, CONDITION, QUERY", "Description": "f", "Parameters": [{"Name": "f", "Type": "float", "Description": "A float to convert to an int."}], "Returns": [{"Type": "int", "Description": "The value of the float passed in as an int."}], "Cautions": "none", "See Also": "java.lang.Float"},{"Function": "Number.MIN_VALUE()", "Signature": "int MIN_VALUE ()", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Return the minimum value an int can have, -2^31.", "Parameters": "None.", "Returns": [{"Type": "int", "Description": "The minimum value an int can have, -2^31."}], "Cautions": "none", "See Also": "java.lang.Integer#MIN_VALUE"},{"Function": "Number.toOctalString()", "Signature": "String toOctalString (int i)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Return a String containing the octal representation of the int passed.", "Parameters": [{"Name": "i", "Type": "int", "Description": "An int to convert to an octal String."}], "Returns": [{"Type": "String", "Description": "A String containing the octal representation of the int passed."}], "Cautions": "none"},{"Function": "Number.intValue()", "Signature": "int intValue (String s, int radix)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns an int holding the value extracted from the specified String when\nparsed with the radix given by the second argument. The first argument is\ninterpreted as representing a signed integer in the radix specified by the\nsecond argument. The result is an Integer object that represents the integer\nvalue specified by the string.", "Parameters": [{"Name": "s", "Type": "String", "Description": "A String containing an integer (in the radix specified) to be converted to an int."}, {"Name": "radix", "Type": "int", "Description": "s"}], "Returns": [{"Type": "int", "Description": "The value of the integer in the String passed based on the passed radix (number base)."}], "Cautions": "none"},{"Function": "Number.toBinaryString()", "Signature": "String toBinaryString (int i)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Return a String containing the binary representation of the int passed.", "Parameters": [{"Name": "i", "Type": "int", "Description": "An int to convert to a binary String."}], "Returns": [{"Type": "String", "Description": "A String containing the binary representation of the int passed."}], "Cautions": "none"},{"Function": "Number.valueOfLong()", "Signature": "int valueOfLong (long l)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns the value of the long passed in (\nl\n) as an int.\nThe high order bits are simply truncated which can result in sign reversal.", "Parameters": [{"Name": "l", "Type": "long", "Description": "A long that will be returned as an int."}], "Returns": [{"Type": "int", "Description": "l"}], "Cautions": "The high order bits are simply truncated which can result in sign reversal.", "See Also": "java.lang.Long"},{"Function": "Channel.getActiveDestinations()", "Signature": "String[] getActiveDestinations()", "Domain": "ACTION, CONDITION", "Description": "Returns an array of active destinations URI's that are bound to this RuleSession.", "Parameters": "None.", "Returns": [{"Type": "String[]", "Description": "Destinations URI's that are enabled for the current RuleSession, are started, and are not suspended."}], "Cautions": "none"},{"Function": "Channel.suspendDestination()", "Signature": "void suspendDestination(String destinationURI) throws Exception", "Domain": "ACTION", "Description": "Suspend a pre-existing destination.", "Parameters": [{"Name": "destinationURI", "Type": "String", "Description": "The destination URI that is to be suspended"}], "Returns": [{"Type": "void"}], "See Also": "resumeDestination"},{"Function": "Channel.getSuspendedDestinations()", "Signature": "String[] getSuspendedDestinations()", "Domain": "ACTION, CONDITION", "Description": "Returns an array of suspended destinations URI's that are bound to this rule session.", "Parameters": "None.", "Returns": [{"Type": "String[]", "Description": "Destinations URI's that are enabled for the current rule session, are started, and are suspended."}], "Cautions": "none"},{"Function": "Channel.getAllDestinations()", "Signature": "String[] getAllDestinations()", "Domain": "ACTION, CONDITION", "Description": "Returns an array of all active and suspended destinations URI's that are bound to this RuleSession.", "Parameters": "None.", "Returns": [{"Type": "String[]", "Description": "Destinations URI's that are enabled for the current RuleSession, are started, are active or suspended."}], "Cautions": "none"},{"Function": "Channel.resumeDestination()", "Signature": "void resumeDestination(String destinationURI) throws Exception", "Domain": "ACTION", "Description": "Resume a pre-existing destination.", "Parameters": [{"Name": "destinationURI", "Type": "String", "Description": "The destination URI that is to be resumed"}], "Returns": [{"Type": "void"}], "See Also": "suspendDestination"},{"Function": "Channel.getQueueCapacity()", "Signature": "int getQueueCapacity(String destinationURI)", "Domain": "ACTION, CONDITION", "Description": "Return the remaining queue capacity for this local destination", "Parameters": [{"Name": "destinationURI", "Type": "String", "Description": "The local channel's destination URI whose queue capacity is being requested."}], "Returns": [{"Type": "int", "Description": "A value greater than or equal to zero (0) for local channel's destination; else -1 if any other type of destination is specified"}], "See Also": "suspendDestination"},{"Function": "Channel.stopChannel()", "Signature": "boolean stopChannel(String channelURI)", "Domain": "ACTION, CONDITION", "Description": "Stops an active channel based on the specified URI only if the channel is in started state.", "Parameters": [{"Name": "channelURI", "Type": "String", "Description": "The channel URI"}], "Returns": [{"Type": "boolean", "Description": "Returns true if successful else false."}], "Cautions": "none"},{"Function": "Channel.getQueueDepth()", "Signature": "int getQueueDepth(String destinationURI)", "Domain": "ACTION, CONDITION", "Description": "Get the queue depth for this local destination.", "Parameters": [{"Name": "localDestinationURI", "Type": "String", "Description": "The local channel's destination URI whose queue depth is being requested."}], "Returns": [{"Type": "int", "Description": "A value >= 0 for local channel's destination, else -1 if any other type of destination is specified"}], "See Also": "suspendDestination"},{"Function": "Channel.startChannel()", "Signature": "boolean startChannel(String channelURI)", "Domain": "ACTION, CONDITION", "Description": "Starts a channel to active mode based on the specified URI only if the channel is in stopped state.", "Parameters": [{"Name": "channelURI", "Type": "String", "Description": "The channel URI"}], "Returns": [{"Type": "boolean", "Description": "Returns true if successful else false."}], "Cautions": "none"},{"Function": "System.currentTimeMillis()", "Signature": "long currentTimeMillis()", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Return currentTime in milliseconds", "Parameters": "None.", "Returns": [{"Type": "long", "Description": "The current time in millisecond."}]},{"Function": "System.getGlobalVariableAsInt()", "Signature": "int getGlobalVariableAsInt (String propertyKey, int defaultValue)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns the requested global variable's value as an int.", "Parameters": [{"Name": "propertyKey", "Type": "String", "Description": "The property key to get the value for."}, {"Name": "defaultValue", "Type": "int", "Description": "The value to return if the requested value is not present."}], "Returns": [{"Type": "int", "Description": "The requested global variable's value as an int."}], "Cautions": "none"},{"Function": "System.nanoTime()", "Signature": "long nanoTime()", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "The current value of the system timer, in nanoseconds. This does not\nreflect the current time.", "Parameters": "None.", "Returns": [{"Type": "long", "Description": "The current value of the system timer, in nanoseconds. This does not\nreflect the current time."}]},{"Function": "System.getGlobalVariableAsDouble()", "Signature": "double getGlobalVariableAsDouble (String propertyKey, double defaultValue)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns the requested global variable's value as a double.", "Parameters": [{"Name": "propertyKey", "Type": "String", "Description": "The property key to get the value for."}, {"Name": "defaultValue", "Type": "double", "Description": "The value to return if the requested value is not present."}], "Returns": [{"Type": "double", "Description": "The requested global variable's value as a double."}], "Cautions": "none"},{"Function": "System.getSystemPropertyAsLong()", "Signature": "long getSystemPropertyAsLong (String propertyKey, long defaultValue)", "Domain": "ACTION, CONDITION, BUI", "Description": "Returns the requested System property value as a long.", "Parameters": [{"Name": "propertyKey", "Type": "String", "Description": "The property key to set a new value for."}, {"Name": "defaultValue", "Type": "long", "Description": "The value to return if the requested value is not present."}], "Returns": [{"Type": "long", "Description": "The requested System property value as a long."}], "Cautions": "none"},{"Function": "System.getSystemPropertyAsBoolean()", "Signature": "boolean getSystemPropertyAsBoolean (String propertyKey, boolean defaultValue)", "Domain": "ACTION, CONDITION, BUI", "Description": "Returns the requested System property value as a boolean.", "Parameters": [{"Name": "propertyKey", "Type": "String", "Description": "The System property to get the value for."}, {"Name": "defaultValue", "Type": "boolean", "Description": "The value to return if the requested value is not present."}], "Returns": [{"Type": "boolean", "Description": "The requested System property value as a boolean."}], "Cautions": "none"},{"Function": "System.debugOut()", "Signature": "void debugOut (String str)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Outputs the String passed to the USER sink.", "Parameters": [{"Name": "str", "Type": "String", "Description": "A value to be output to the USER sink."}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "System.execJava()", "Signature": "Object execJava(String className, String method, String[] parameterTypes, Object object, Object[] parameters)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Executes the specified Java method with the object instance and parameters.", "Parameters": [{"Name": "className", "Type": "String", "Description": "the class name of the Java method."}, {"Name": "method", "Type": "String", "Description": "the name of the method."}, {"Name": "parameterTypes", "Type": "String[]", "Description": "an array of Class in String format that identify the method's formal parameter types in declared order, use null if no arguments."}, {"Name": "object", "Type": "Object", "Description": "the object the underlying method is invoked from, use null for static method."}, {"Name": "parameters", "Type": "Object[]", "Description": "the arguments used for the method call, use null if no arguments."}], "Returns": [{"Type": "Object", "Description": "the result of the java method."}]},{"Function": "System.getSystemPropertyAsString()", "Signature": "String getSystemPropertyAsString (String propertyKey, String defaultValue)", "Domain": "ACTION, CONDITION, BUI", "Description": "Returns the requested System property value as a String.", "Parameters": [{"Name": "propertyKey", "Type": "String", "Description": "The property key to set a new value for."}, {"Name": "defaultValue", "Type": "String", "Description": "The value to return if the requested value is not present."}], "Returns": [{"Type": "String", "Description": "The requested System property value as a String."}], "Cautions": "none"},{"Function": "System.getSystemPropertyAsDouble()", "Signature": "double getSystemPropertyAsDouble (String propertyKey, double defaultValue)", "Domain": "ACTION, CONDITION, BUI", "Description": "Returns the requested System property value as an double.", "Parameters": [{"Name": "propertyKey", "Type": "String", "Description": "The property key to set a new value for."}, {"Name": "defaultValue", "Type": "double", "Description": "The value to return if the requested value is not present."}], "Returns": [{"Type": "double", "Description": "The requested System property value as an double."}], "Cautions": "none"},{"Function": "System.getGlobalVariableAsLong()", "Signature": "long getGlobalVariableAsLong (String propertyKey, long defaultValue)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns the requested global variable's value as a long.", "Parameters": [{"Name": "propertyKey", "Type": "String", "Description": "The property key to get the value for."}, {"Name": "defaultValue", "Type": "long", "Description": "The value to return if the requested value is not present."}], "Returns": [{"Type": "long", "Description": "The requested global variable's value as a long."}], "Cautions": "none"},{"Function": "System.getSystemPropertyAsInt()", "Signature": "int getSystemPropertyAsInt (String propertyKey, int defaultValue)", "Domain": "ACTION, CONDITION, BUI", "Description": "Returns the requested System property value as an int.", "Parameters": [{"Name": "propertyKey", "Type": "String", "Description": "The property key to set a new value for."}, {"Name": "defaultValue", "Type": "int", "Description": "The value to return if the requested value is not present."}], "Returns": [{"Type": "int", "Description": "The requested System property value as an int."}], "Cautions": "none"},{"Function": "System.exec()", "Signature": "void exec(String command)", "Domain": "ACTION, BUI", "Description": "Executes the specified string command in a separate process. The command argument is parsed\ninto tokens and then executed as a command in a separate process.", "Parameters": [{"Name": "command", "Type": "String", "Description": "a specified system command."}], "Returns": [{"Type": "void"}]},{"Function": "System.getGlobalVariableAsString()", "Signature": "String getGlobalVariableAsString (String propertyKey, String defaultValue)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns the requested global variable's value as a String.", "Parameters": [{"Name": "propertyKey", "Type": "String", "Description": "The property key to get the value for."}, {"Name": "defaultValue", "Type": "String", "Description": "The value to return if the requested value is not present."}], "Returns": [{"Type": "String", "Description": "The requested global variable's value as a String."}], "Cautions": "none"},{"Function": "System.getGlobalVariableAsBoolean()", "Signature": "boolean getGlobalVariableAsBoolean (String propertyKey, boolean defaultValue)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns the requested global variable's value as a boolean.", "Parameters": [{"Name": "propertyKey", "Type": "String", "Description": "The property key to get the value for."}, {"Name": "defaultValue", "Type": "boolean", "Description": "The value to return if the requested value is not present."}], "Returns": [{"Type": "boolean", "Description": "The requested global variable's value as a boolean."}], "Cautions": "none"},{"Function": "System.IO.fileClose()", "Signature": "void fileClose(String fileName)", "Domain": "ACTION, BUI", "Description": "fileName", "Parameters": [{"Name": "fileName", "Type": "String", "Description": "The name of the file for closing."}], "Returns": [{"Type": "void"}], "Cautions": "none", "See Also": "fileWrite"},{"Function": "System.IO.fileWrite()", "Signature": "void fileWrite (String fileName, String str, boolean append, boolean flush)", "Domain": "ACTION, BUI", "Description": "str", "Parameters": [{"Name": "fileName", "Type": "String", "Description": "The name of the file to write to."}, {"Name": "str", "Type": "String", "Description": "Data to be written."}, {"Name": "append", "Type": "boolean", "Description": "Is this write to be treated as an append to an existing file?"}, {"Name": "flush", "Type": "boolean", "Description": "Should the data be flushed to the file immediately?"}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "System.ID.reset()", "Signature": "void reset(String name, long value)", "Domain": "ACTION, CONDITION, BUI", "Description": "Sets the sequence identified by the given name to the given value if the given value is greater than the current value.", "Parameters": [{"Name": "name", "Type": "String", "Description": "a specified sequence name."}, {"Name": "value", "Type": "sequence", "Description": "id value"}], "Returns": [{"Type": "void"}]},{"Function": "System.ID.nextId()", "Signature": "long nextId(String name)", "Domain": "ACTION, CONDITION, BUI", "Description": "For In Memory object management, it returns a system generated unique id for a given sequence name. It is only supported for in-memory objects, not cache-based.", "Parameters": [{"Name": "name", "Type": "String", "Description": "a specified sequence name."}], "Returns": [{"Type": "long"}]},{"Function": "System.ID.remove()", "Signature": "void remove(String name)", "Domain": "ACTION, CONDITION, BUI", "Description": "Removes the sequence identified by the given name.", "Parameters": [{"Name": "name", "Type": "String", "Description": "a specified sequence name."}], "Returns": [{"Type": "void"}]},{"Function": "JSON.isObjectNode()", "Signature": "boolean isObjectNode(Object jsonNode)", "Domain": "ACTION, CONDITION, BUI", "Description": "Returns if the passed JsonNode is of Object type", "Parameters": [{"Name": "jsonNode", "Type": "Object", "Description": "JsonNode Object"}], "Returns": [{"Type": "boolean", "Description": "True if node is Object type else false"}]},{"Function": "JSON.findValueNode()", "Signature": "Object getValueNode(Object baseNode, String fieldName)", "Domain": "ACTION, CONDITION, BUI", "Description": "Looks for and returns any value Json node associated to the field name under the given baseNode tree", "Parameters": [{"Name": "baseNode", "Type": "Object", "Description": "Base JsonNode Object"}, {"Name": "fieldName", "Type": "String", "Description": "Field name"}], "Returns": [{"Type": "Object", "Description": "Json value node object"}]},{"Function": "JSON.getFields()", "Signature": "Object getFields(Object jsonNode)", "Domain": "ACTION, CONDITION, BUI", "Description": "Returns the Map of keys to JsonNode", "Parameters": [{"Name": "jsonNode", "Type": "Object", "Description": "JsonNode Object"}], "Returns": [{"Type": "Object", "Description": "Iterator Map Entry of key to JsonNode"}]},{"Function": "JSON.getNodeType()", "Signature": "String getNodeType(Object jsonNode)", "Domain": "ACTION, CONDITION, BUI", "Description": "Returns the type of JsonNode i.e. ARRAY/OBJECT/etc", "Parameters": [{"Name": "jsonNode", "Type": "Object", "Description": "JsonNode Object"}], "Returns": [{"Type": "String", "Description": "JSON node type"}]},{"Function": "JSON.getNode()", "Signature": "Object getNode(Object baseNode, String fieldName)", "Domain": "ACTION, CONDITION, BUI", "Description": "Returns the JsonNode associated to the fieldName directly under the baseNode i.e. immediate children", "Parameters": [{"Name": "baseNode", "Type": "Object", "Description": "Base JsonNode Object"}, {"Name": "fieldName", "Type": "String", "Description": "Field name"}], "Returns": [{"Type": "Object", "Description": "Json node associated to the field name"}]},{"Function": "JSON.getAllElements()", "Signature": "Object getAllElements(Object jsonNode)", "Domain": "ACTION, CONDITION, BUI", "Description": "Returns the Iterator of all the nodes in the given JsonNode Object", "Parameters": [{"Name": "jsonNode", "Type": "Object", "Description": "JsonNode Object"}], "Returns": [{"Type": "Object", "Description": "Iterator of JsonNode Objects"}]},{"Function": "JSON.getTextValue()", "Signature": "String getTextValue(Object jsonNode)", "Domain": "ACTION, CONDITION, BUI", "Description": "Returns the text value of the JSON node passed", "Parameters": [{"Name": "jsonNode", "Type": "Object", "Description": "JsonNode Object"}], "Returns": [{"Type": "String", "Description": "Text value of the JsonNode"}]},{"Function": "JSON.hasField()", "Signature": "boolean hasField(Object baseNode, String fieldName)", "Domain": "ACTION, CONDITION, BUI", "Description": "Returns if the field name exists in the given json base node", "Parameters": [{"Name": "baseNode", "Type": "Object", "Description": "Base JsonNode Object"}, {"Name": "fieldName", "Type": "String", "Description": "Field name"}], "Returns": [{"Type": "boolean", "Description": "True if fieldname exists, else false"}]},{"Function": "JSON.isValueNode()", "Signature": "boolean isValueNode(Object jsonNode)", "Domain": "ACTION, CONDITION, BUI", "Description": "Returns if the JsonNode is a value node or not", "Parameters": [{"Name": "jsonNode", "Type": "Object", "Description": "JsonNode Object"}], "Returns": [{"Type": "Object", "Description": "True if JsonNode is a value node, else false"}]},{"Function": "JSON.findParent()", "Signature": "Object findParent(Object baseNode, String fieldName)", "Domain": "ACTION, CONDITION, BUI", "Description": "Looks for and returns the parent node associated to the field name under the given baseNode tree", "Parameters": [{"Name": "baseNode", "Type": "Object", "Description": "Base JsonNode Object"}, {"Name": "fieldName", "Type": "String", "Description": "Field name"}], "Returns": [{"Type": "Object", "Description": "Parent JsonNode Object"}]},{"Function": "JSON.getFieldNames()", "Signature": "Object getFieldNames(Object jsonNode)", "Domain": "ACTION, CONDITION, BUI", "Description": "Returns the Iterator of field names in a JsonNode", "Parameters": [{"Name": "jsonNode", "Type": "Object", "Description": "JsonNode Object"}], "Returns": [{"Type": "Object", "Description": "String Iterator containing JSON Object keys"}]},{"Function": "JSON.findNode()", "Signature": "Object findNode(Object baseNode, String fieldName)", "Domain": "ACTION, CONDITION, BUI", "Description": "Looks for and returns any Json node associated to the field name under the given baseNode tree", "Parameters": [{"Name": "baseNode", "Type": "Object", "Description": "Base JsonNode Object"}, {"Name": "fieldName", "Type": "String", "Description": "Field name"}], "Returns": [{"Type": "Object", "Description": "Json Node"}]},{"Function": "JSON.parseJSON()", "Signature": "Object parseJSON(String jsonContent)", "Domain": "ACTION, CONDITION, BUI", "Description": "Parse the JSON content. If its a valid JSON, the API returns a parsed JsonNode Object, else throws a exception.", "Parameters": [{"Name": "jsonContent", "Type": "String", "Description": "Json Content"}], "Returns": [{"Type": "Object", "Description": "Parsed JSON Object"}]},{"Function": "JSON.isArrayNode()", "Signature": "boolean isArrayNode(Object jsonNode)", "Domain": "ACTION, CONDITION, BUI", "Description": "Returns if the Json node is an Array or not", "Parameters": [{"Name": "jsonNode", "Type": "Object", "Description": "JsonNode Object"}], "Returns": [{"Type": "boolean", "Description": "True if JsonNode is array, else false"}]},{"Function": "HTTP.getRequestURI()", "Signature": "String getRequestURI(SimpleEvent requestEvent)", "Domain": "ACTION", "Description": "Get the request URI", "Parameters": [{"Name": "requestEvent", "Type": "SimpleEvent", "Description": "The input event to send"}], "Returns": [{"Type": "String", "Description": "Request URI"}]},{"Function": "HTTP.encodeURL()", "Signature": "String encodeURL(String url, String encoding)", "Domain": "ACTION", "Description": "Encodes a URL", "Parameters": [{"Name": "url", "Type": "String", "Description": "The URL content to encode."}, {"Name": "encoding", "Type": "String", "Description": "The encoding which will be $1UTF-8$1 if null or empty value specified."}], "Returns": [{"Type": "String", "Description": "The encoded url."}]},{"Function": "HTTP.sendRequest()", "Signature": "Event sendRequest(String url, SimpleEvent requestEvent, String responseEventURI, long timeoutMillis, Object httpConnectionInfo)", "Domain": "ACTION", "Description": "Sends a secure/non secure synchronous HTTP request. The event properties are converted to HTTP headers. The event payload is converted to POST data. Default behavior, if the event payload is null, HTTP GET will be used, else HTTP POST will be used. Alternatively, if HTTP.ConnectionInfo.setHttpMethod is set, then that method type will be used.This will return an event of type responseEventURI as a response encapsulating response headers as properties and post data if any as event payload.", "Parameters": [{"Name": "url", "Type": "String", "Description": "The URL for the endpoint."}, {"Name": "requestEvent", "Type": "SimpleEvent", "Description": "The input event to send"}, {"Name": "responseEventURI", "Type": "String", "Description": "URI of event to be created once response received"}, {"Name": "timeoutMillis", "Type": "long", "Description": "time out for the operation, -1 signifies wait forever."}, {"Name": "httpConnectionInfo", "Type": "Object", "Description": "HTTP Connection Info object"}], "Returns": [{"Type": "Event", "Description": "event The response event"}]},{"Function": "HTTP.loadTrustedCertificates()", "Signature": "Object loadTrustedCertificates(String trustedCertsFolder, String passwordToSet)", "Domain": "ACTION", "Description": "Loads and returns a KeyStore from the trusted certificates folder.", "Parameters": [{"Name": "trustedCertsFolder", "Type": "String", "Description": "The relative path of the folder containing the certificates. Certificates folder has to be inside project"}, {"Name": "passwordToSet", "Type": "String", "Description": "The password to check the integrity of the keystore"}], "Returns": [{"Type": "Object", "Description": "certificates keystore object"}]},{"Function": "HTTP.toBase64()", "Signature": "String toBase64(String content)", "Domain": "ACTION", "Description": "Encodes a String to Base64.", "Parameters": [{"Name": "content", "Type": "String", "Description": "The content to encode into base64."}], "Returns": [{"Type": "String", "Description": "Base64 encoded string."}]},{"Function": "HTTP.sendAsynchronousRequest()", "Signature": "String sendAsynchronousRequest(String url, SimpleEvent requestEvent, String correlationId, String successCallbackRuleFunctionURL, String errorCallbackRuleFunctionURL, Object httpConnectionInfo)", "Domain": "ACTION", "Description": "Sends an secure/non secure asynchronous HTTP request. The event payload is converted to POST data. Default behavior, if the event payload is null, HTTP GET will be used, else HTTP POST will be used. Alternatively, if HTTP.ConnectionInfo.setHttpMethod is set, then that method type will be used.The requesting thread continues processing. The response is handled asynchronously in the callback rule function. The signature of the success RuleFunction should be $1void ruleFunction (String correlationId, Event request, Event response$1) whereas that of the error RuleFunction should be $1void ruleFunction (String correlationId, Event request, Exception exception)$1 where the request event is the event that initiated the request, the response event is the HTTP response mapped to an Event and correlationId is the correlationId that was specified in the original request or that was returned by the sendAsynchronousRequest function.", "Parameters": [{"Name": "url", "Type": "String", "Description": "The URL for the endpoint."}, {"Name": "requestEvent", "Type": "SimpleEvent", "Description": "The input event to send"}, {"Name": "correlationId", "Type": "String", "Description": "An optional id to correlate request and response."}, {"Name": "successCallbackRuleFunctionURL", "Type": "String", "Description": "The fully qualified path of a rule function to be invoked for success case."}, {"Name": "errorCallbackRuleFunctionURL", "Type": "String", "Description": "Error case callback rulefunction. Can be null."}, {"Name": "httpConnectionInfo", "Type": "Object", "Description": "HTTP Connection Info object"}], "Returns": [{"Type": "String", "Description": "the correlation id"}]},{"Function": "HTTP.createKeystore()", "Signature": "Object createKeystore(String ksFilePath, String ksType, String ksPassword)", "Domain": "ACTION", "Description": "Creates and returns a Keystore object using the given parameters.", "Parameters": [{"Name": "ksFilePath", "Type": "String", "Description": "The absolute path of keystore file."}, {"Name": "ksType", "Type": "String", "Description": "The type of keystore. JKS, and PKCS12 supported."}, {"Name": "ksPassword", "Type": "String", "Description": "Obfuscated password for the keystore"}], "Returns": [{"Type": "Object", "Description": "the Keystore object"}]},{"Function": "HTTP.fromBase64()", "Signature": "String fromBase64(String content, String encoding)", "Domain": "ACTION", "Description": "Decodes a String from Base64.", "Parameters": [{"Name": "content", "Type": "String", "Description": "The base64 content to decode"}, {"Name": "encoding", "Type": "String", "Description": "The encoding which will be $1UTF-8$1 if null or empty value specified."}], "Returns": [{"Type": "String", "Description": "Decoded from base64."}]},{"Function": "HTTP.decodeURL()", "Signature": "String decodeURL(String url, String encoding)", "Domain": "ACTION", "Description": "Decodes a URL.", "Parameters": [{"Name": "url", "Type": "String", "Description": "The URL content to decode."}, {"Name": "encoding", "Type": "String", "Description": "The encoding which will be $1UTF-8$1 if null or empty value specified."}], "Returns": [{"Type": "String", "Description": "The decoded url."}]},{"Function": "HTTP.getPayloadData()", "Signature": "Object getPayloadData(SimpleEvent event)", "Domain": "ACTION, CONDITION, BUI", "Description": "Gets the payload of a SimpleEvent as a byte[] object that can be used as HTTP POST/PUT data.", "Parameters": [{"Name": "event", "Type": "SimpleEvent", "Description": "Request event on HTTP channel/destination"}], "Returns": [{"Type": "Object", "Description": "The payload data"}]},{"Function": "HTTP.WebSocket.isConnectionOpen()", "Signature": "boolean isConnectionOpen(Object eventOrSessionContext)", "Domain": "ACTION, CONDITION, BUI", "Description": "Returns if the underlying websocket endpoint connection is open", "Parameters": [{"Name": "eventOrSessionContext", "Type": "Object", "Description": "Accepts a SimpleEvent associated to WebSocket destination or the underlying websocket endpoint context retreived via getSessionContext api."}], "Returns": [{"Type": "boolean", "Description": "Returns if the underlying websocket endpoint connection is open"}]},{"Function": "HTTP.WebSocket.getSessionContext()", "Signature": "Object getSessionContext(SimpleEvent event)", "Domain": "ACTION, CONDITION, BUI", "Description": "Gets the underlying websocket session context", "Parameters": [{"Name": "event", "Type": "SimpleEvent", "Description": "Accepts a SimpleEvent associated to WebSocket destination"}], "Returns": [{"Type": "Object", "Description": "Websocket session context"}]},{"Function": "HTTP.WebSocket.sendMessage()", "Signature": "void sendMessage(Object eventOrSessionContext, Object message, boolean broadcast)", "Domain": "ACTION, CONDITION, BUI", "Description": "Sends message to current session or broadcasts to all sessions associated to the underlying websocket endpoint", "Parameters": [{"Name": "eventOrSessionContext", "Type": "Object", "Description": "Accepts a SimpleEvent associated to WebSocket destination or the underlying websocket session context retrieved via getSessionContext api."}, {"Name": "message", "Type": "String", "Description": "The message to send."}, {"Name": "broadcast", "Type": "boolean", "Description": "Send to only the current session or all session associated to this endpoint"}], "Returns": [{"Type": "void"}]},{"Function": "HTTP.WebSocket.getQueryString()", "Signature": "String getQueryString(Object eventOrSessionContext)", "Domain": "ACTION, CONDITION, BUI", "Description": "Returns the query string", "Parameters": [{"Name": "eventOrSessionContext", "Type": "Object", "Description": "Accepts a SimpleEvent associated to WebSocket destination or the underlying websocket endpoint context retreived via getSessionContext api."}], "Returns": [{"Type": "String", "Description": "Returns the query string"}]},{"Function": "HTTP.WebSocket.getRequestParameters()", "Signature": "Object getRequestParameters(Object eventOrSessionContext)", "Domain": "ACTION, CONDITION, BUI", "Description": "Returns a map of the request parameters", "Parameters": [{"Name": "eventOrSessionContext", "Type": "Object", "Description": "Accepts a SimpleEvent associated to WebSocket destination or the underlying websocket endpoint context retreived via getSessionContext api."}], "Returns": [{"Type": "Object", "Description": "Returns a map of the request parameters"}]},{"Function": "HTTP.WebSocket.closeConnection()", "Signature": "void closeConnection(Object eventOrSessionContext, int closeCode, String closeReason, boolean all)", "Domain": "ACTION, CONDITION, BUI", "Description": "Closes single/all websocket connection/s to the underlying endpoint", "Parameters": [{"Name": "eventOrSessionContext", "Type": "Object", "Description": "Accepts a SimpleEvent associated to WebSocket destination or the underlying websocket session context retrieved via getSessionContext api."}, {"Name": "closeCode", "Type": "int", "Description": "Valid Websocket close code for closure.Few valid codes are 1001,1002,1003."}, {"Name": "closeReason", "Type": "String", "Description": "Reason for the websocket close connection"}, {"Name": "all", "Type": "boolean", "Description": "Closes the current or all websocket connections associated to the underlying endpoint"}], "Returns": [{"Type": "void"}]},{"Function": "HTTP.Servlet.getServletRequest()", "Signature": "Object getServletRequest(Object context)", "Domain": "ACTION", "Description": "Get servlet request from the context object.", "Parameters": [{"Name": "context", "Type": "Object", "Description": "The context (AsyncContext) associated with a servlet request."}], "Returns": [{"Type": "Object", "Description": "HttpServletRequest"}]},{"Function": "HTTP.Servlet.getServletResponse()", "Signature": "Object getServletResponse(Object context)", "Domain": "ACTION, CONDITION, BUI", "Description": "Get servlet response from the context object.", "Parameters": [{"Name": "context", "Type": "Object", "Description": "The context (AsyncContext) associated with a servlet request."}], "Returns": [{"Type": "Object", "Description": "HttpServletResponse"}]},{"Function": "HTTP.Servlet.Response.sendRedirectTo()", "Signature": "void sendRedirectTo(Object context, String redirectURL)", "Domain": "ACTION, CONDITION, BUI", "Description": "Responds by redirecting the client to a different URL.", "Parameters": [{"Name": "context", "Type": "Object", "Description": "The context (AsyncContext) associated with a servlet request."}, {"Name": "redirectURL", "Type": "String", "Description": "The redirection URL."}], "Returns": [{"Type": "void"}]},{"Function": "HTTP.Servlet.Response.setCookie()", "Signature": "void setCookie(Object response, Object cookie)", "Domain": "ACTION, CONDITION, BUI", "Description": "Adds a cookie object to the response.", "Parameters": [{"Name": "response", "Type": "Object", "Description": "The servlet response."}, {"Name": "cookie", "Type": "Object", "Description": "The cookie object."}], "Returns": [{"Type": "void"}], "See Also": "getCookie"},{"Function": "HTTP.Servlet.Response.setResponseStatusCode()", "Signature": "void setResponseStatusCode(Object context, int statusCode)", "Domain": "ACTION, CONDITION, BUI", "Description": "Sets the status code in the servlet response.", "Parameters": [{"Name": "response", "Type": "Object", "Description": "The servlet response."}, {"Name": "statusCode", "Type": "int", "Description": "The status code."}], "Returns": [{"Type": "void"}]},{"Function": "HTTP.Servlet.Response.setResponseHeader()", "Signature": "void setResponseHeader(Object response, String headerName, String headerValue)", "Domain": "ACTION, CONDITION, BUI", "Description": "Sets a response header.", "Parameters": [{"Name": "response", "Type": "Object", "Description": "The servlet response."}, {"Name": "headerName", "Type": "String", "Description": "The header name."}, {"Name": "headerValue", "Type": "String", "Description": "Value of the header."}], "Returns": [{"Type": "void"}]},{"Function": "HTTP.Servlet.Response.setResponseContent()", "Signature": "void setResponseContent(Object context, Object content, boolean commitResponse)", "Domain": "ACTION, CONDITION, BUI", "Description": "Sets the String or byte[] response content in the servlet response, and sends the response.", "Parameters": [{"Name": "context", "Type": "Object", "Description": "The context (AsyncContext) associated with a servlet request/response."}, {"Name": "content", "Type": "Object", "Description": "The String/byte[] response content."}, {"Name": "commitResponse", "Type": "boolean", "Description": "Whether response should be immediately committed or not."}], "Returns": [{"Type": "void"}]},{"Function": "HTTP.Servlet.Response.getCookie()", "Signature": "Object getCookie(String cookieName, String cookieValue, String domain, String path, int expiry)", "Domain": "ACTION, CONDITION, BUI", "Description": "Creates a cookie object to be set on the response.", "Parameters": [{"Name": "cookieName", "Type": "String", "Description": "The name of the cookie."}, {"Name": "cookieValue", "Type": "String", "Description": "The cookie value."}, {"Name": "domain", "Type": "String", "Description": "Optional domain for the cookie."}, {"Name": "path", "Type": "String", "Description": "Optional path for the cookie."}, {"Name": "expiry", "Type": "int", "Description": "Max age for the cookie in seconds."}], "Returns": [{"Type": "cookie", "Description": "object"}]},{"Function": "HTTP.Servlet.Request.getSessionId()", "Signature": "String getSessionId(Object session)", "Domain": "ACTION, CONDITION, BUI", "Description": "Get Http Session Id", "Parameters": [{"Name": "session", "Type": "Object", "Description": "Http Session object."}], "Returns": [{"Type": "String", "Description": "Session Id"}]},{"Function": "HTTP.Servlet.Request.getRequestURI()", "Signature": "String getRequestURI(Object request)", "Domain": "ACTION, CONDITION, BUI", "Description": "Get servlet request URI.", "Parameters": [{"Name": "request", "Type": "Object", "Description": "The servlet request URI including query parameters if any."}], "Returns": [{"Type": "String", "Description": "The value of the URI."}]},{"Function": "HTTP.Servlet.Request.getServerPort()", "Signature": "int getServerPort(Object request)", "Domain": "ACTION", "Description": "Gets the port number.", "Parameters": [{"Name": "request", "Type": "Object", "Description": "The servlet request object."}], "Returns": [{"Type": "int", "Description": "The http port of the web server."}]},{"Function": "HTTP.Servlet.Request.startAsync()", "Signature": "Object startAsync(Object servletRequest)", "Domain": "ACTION, CONDITION, BUI", "Description": "Starts asynchronous processing of servlet requests.", "Parameters": [{"Name": "servletRequest", "Type": "Object", "Description": "Servlet Request object"}], "Returns": [{"Type": "Object", "Description": "Async Context"}]},{"Function": "HTTP.Servlet.Request.getSessionAttribute()", "Signature": "Object getSessionAttribute(Object session, String key)", "Domain": "ACTION, CONDITION, BUI", "Description": "Get Http Session attribute", "Parameters": [{"Name": "session", "Type": "Object", "Description": "Http Session object."}, {"Name": "key", "Type": "String", "Description": "Attribute name/key"}], "Returns": [{"Type": "Object", "Description": "Attribute value"}]},{"Function": "HTTP.Servlet.Request.invalidateSession()", "Signature": "void invalidateSession(Object session)", "Domain": "ACTION, CONDITION, BUI", "Description": "Invalidate Http sesion", "Parameters": [{"Name": "session", "Type": "Object", "Description": "Http Session object."}], "Returns": [{"Type": "void"}]},{"Function": "HTTP.Servlet.Request.getRequestContent()", "Signature": "byte[] getRequestContent(Object request)", "Domain": "ACTION", "Description": "Gets the servlet request post data.", "Parameters": [{"Name": "request", "Type": "Object", "Description": "The servlet request object."}], "Returns": [{"Type": "byte[]", "Description": "The post content."}]},{"Function": "HTTP.Servlet.Request.getSessionAttributeNames()", "Signature": "String[] getSessionAttributeNames(Object session)", "Domain": "ACTION, CONDITION, BUI", "Description": "Get Http Session attribute names", "Parameters": [{"Name": "session", "Type": "Object", "Description": "Http Session object."}], "Returns": [{"Type": "String[]", "Description": "Session Attribute Names"}]},{"Function": "HTTP.Servlet.Request.setSessionTimeout()", "Signature": "void setSessionTimeout(Object session, int timeout)", "Domain": "ACTION, CONDITION, BUI", "Description": "Set Http Session timeout", "Parameters": [{"Name": "session", "Type": "Object", "Description": "Http Session object."}, {"Name": "timeout", "Type": "int", "Description": "Timeout"}], "Returns": [{"Type": "void"}]},{"Function": "HTTP.Servlet.Request.getSession()", "Signature": "Object getSession(Object request)", "Domain": "ACTION, CONDITION, BUI", "Description": "Get Http Session", "Parameters": [{"Name": "request", "Type": "Object", "Description": "The servlet request object."}], "Returns": [{"Type": "Object", "Description": "Http Session"}]},{"Function": "HTTP.Servlet.Request.getRequestHeader()", "Signature": "String getRequestHeader(Object request, String headerName)", "Domain": "ACTION, CONDITION, BUI", "Description": "Gets a servlet request header value.", "Parameters": [{"Name": "request", "Type": "Object", "Description": "The servlet request object."}, {"Name": "headerName", "Type": "String", "Description": "The name of the request header."}], "Returns": [{"Type": "String", "Description": "The value of the header."}]},{"Function": "HTTP.Servlet.Request.setSessionAttribute()", "Signature": "void setSessionAttribute(Object session, String key, Object value)", "Domain": "ACTION, CONDITION, BUI", "Description": "Set Http Session timeout", "Parameters": [{"Name": "session", "Type": "Object", "Description": "Http Session object."}, {"Name": "key", "Type": "String", "Description": "Attribute name/key"}, {"Name": "value", "Type": "Object", "Description": "Attribute value"}], "Returns": [{"Type": "void"}]},{"Function": "HTTP.Servlet.Request.getRequestorAddress()", "Signature": "String getRequestorAddress(Object request)", "Domain": "ACTION, CONDITION, BUI", "Description": "Gets the address of the remote requestor.", "Parameters": [{"Name": "request", "Type": "Object", "Description": "The servlet request object."}], "Returns": [{"Type": "String", "Description": "The value of the remote requestor address."}]},{"Function": "HTTP.Servlet.Request.getMethod()", "Signature": "String getMethod(Object request)", "Domain": "ACTION, CONDITION, BUI", "Description": "Gets the servlet request method.", "Parameters": [{"Name": "request", "Type": "Object", "Description": "The servlet request object."}], "Returns": [{"Type": "String", "Description": "The value of the method."}]},{"Function": "HTTP.Servlet.Request.getMultipartContent()", "Signature": "Object getMultipartContent(Object request)", "Domain": "ACTION", "Description": "Gets the complete Multipart Content as a Map.", "Parameters": [{"Name": "request", "Type": "Object", "Description": "The servlet request object."}], "Returns": [{"Type": "Object", "Description": "Byte Array of the part contents."}]},{"Function": "HTTP.Servlet.Request.getServerScheme()", "Signature": "String getServerScheme(Object request)", "Domain": "ACTION", "Description": "Gets the protocol name used in the request.", "Parameters": [{"Name": "request", "Type": "Object", "Description": "The servlet request object."}], "Returns": [{"Type": "String", "Description": "The protocol of the web server."}]},{"Function": "HTTP.Servlet.Request.getRequestBrowserName()", "Signature": "String getRequestBrowserName(Object request)", "Domain": "ACTION", "Description": "Gets the browser name from where the request is generated.", "Parameters": [{"Name": "request", "Type": "Object", "Description": "The servlet request object."}], "Returns": [{"Type": "String", "Description": "Browser name from where the request originated, i.e. MSIE/FIREFOX/CHROME/SAFARI"}]},{"Function": "HTTP.Servlet.Request.getCookieValue()", "Signature": "String getCookieValue(Object[] allCookies, String cookieName)", "Domain": "ACTION", "Description": "Gets the cookie value for the given cookie name", "Parameters": [{"Name": "allCookies", "Type": "Object[]", "Description": "All request cookies"}, {"Name": "cookieName", "Type": "String", "Description": "The name of the cookie whose value is desired."}], "Returns": [{"Type": "String", "Description": "Get servlet request cookie value."}], "See Also": "getRequestCookies"},{"Function": "HTTP.Servlet.Request.removeSessionAttribute()", "Signature": "void removeSessionAttribute(Object session, String key)", "Domain": "ACTION, CONDITION, BUI", "Description": "Remove Http Session attribute", "Parameters": [{"Name": "session", "Type": "Object", "Description": "Http Session object."}, {"Name": "key", "Type": "String", "Description": "Attribute name/key"}], "Returns": [{"Type": "void"}]},{"Function": "HTTP.Servlet.Request.getRequestHeaders()", "Signature": "Object getRequestHeaders(Object request)", "Domain": "ACTION, CONDITION, BUI", "Description": "Get servlet request header names.", "Parameters": [{"Name": "request", "Type": "Object", "Description": "The servlet request object."}], "Returns": [{"Type": "Object", "Description": "The collection of header names."}]},{"Function": "HTTP.Servlet.Request.getServerName()", "Signature": "String getServerName(Object request)", "Domain": "ACTION", "Description": "Gets the server name used in the request.", "Parameters": [{"Name": "request", "Type": "Object", "Description": "The servlet request object."}], "Returns": [{"Type": "String", "Description": "The name of the web server."}]},{"Function": "HTTP.Servlet.Request.getRequestParameters()", "Signature": "String getRequestParameters(Object request)", "Domain": "ACTION", "Description": "Gets the names of all the servlet request parameters.", "Parameters": [{"Name": "request", "Type": "Object", "Description": "The servlet request object."}], "Returns": [{"Type": "String[]", "Description": "The names of all the parameters."}]},{"Function": "HTTP.Servlet.Request.getRequestParameterValues()", "Signature": "String[] getRequestParameterValues(Object request, String paramName)", "Domain": "ACTION", "Description": "Gets the values of all the servlet request parameters.", "Parameters": [{"Name": "request", "Type": "Object", "Description": "The servlet request object."}, {"Name": "paramName", "Type": "String", "Description": "The name of the request parameter."}], "Returns": [{"Type": "String[]", "Description": "The values of the parameter."}]},{"Function": "HTTP.Servlet.Request.getRequestCookies()", "Signature": "Object[] getRequestCookies(Object request)", "Domain": "ACTION", "Description": "Get servlet request cookies", "Parameters": [{"Name": "request", "Type": "Object", "Description": "The servlet request object."}], "Returns": [{"Type": "Object[]", "Description": "All cookies"}]},{"Function": "HTTP.Servlet.Request.getPartContent()", "Signature": "Object getPartContent(Object multipartContent, String partName)", "Domain": "ACTION", "Description": "Gets the specified part of a Multipart content.", "Parameters": [{"Name": "multipartContent", "Type": "Object", "Description": "Multipart content."}, {"Name": "partName", "Type": "String", "Description": "The Part name."}], "Returns": [{"Type": "Object", "Description": "Part content."}]},{"Function": "HTTP.Servlet.Request.getProtocol()", "Signature": "String getProtocol(Object request)", "Domain": "ACTION, CONDITION, BUI", "Description": "Gets the protocol used by the servlet request.", "Parameters": [{"Name": "request", "Type": "Object", "Description": "The servlet request."}], "Returns": [{"Type": "String", "Description": "The name and version of the protocol the request uses."}]},{"Function": "HTTP.Servlet.Request.getRequestParameter()", "Signature": "String getRequestParameter(Object request, String paramName)", "Domain": "ACTION", "Description": "Gets a servlet request parameter value.", "Parameters": [{"Name": "request", "Type": "Object", "Description": "The servlet request object."}, {"Name": "paramName", "Type": "String", "Description": "The name of the request parameter."}], "Returns": [{"Type": "String", "Description": "The value of the parameter."}]},{"Function": "HTTP.ConnectionInfo.setSecureInfo()", "Signature": "Object setSecureInfo(Object connectionInfo, String sslProtocol, Object clientIdKeyStore, String clientIdPassword, Object trustedCertsKeystore, String trustedCertsPassword)", "Domain": "ACTION", "Description": "Update HTTPConnectionInfo Object with secure/SSL usage details.", "Parameters": [{"Name": "connectionInfo", "Type": "Object", "Description": "HTTP Connection Info Object"}, {"Name": "sslProtocol", "Type": "String", "Description": "SSL Protocol to use. Valid values TLSv1.1/TLSv1.2/TLSv1.3. Defaults to TLS(TLSv1.1) if not specified."}, {"Name": "clientIdKeystore", "Type": "Object", "Description": "Keystore Object for client identity, not required for 1 way SSL"}, {"Name": "clientIdPassword", "Type": "String", "Description": "Password for client id keystore, not required for 1 way SSL"}, {"Name": "trustedCertsKeystore", "Type": "Object", "Description": "Keystore Object for trusted certificates"}, {"Name": "trustedCertsPassword", "Type": "String", "Description": "Password for trusted certificates keystore"}], "Returns": [{"Type": "Object", "Description": "HTTP ConnectionInfo Object"}]},{"Function": "HTTP.ConnectionInfo.createHTTPConnectionInfo()", "Signature": "Object createHTTPConnectionInfo(boolean isSecure)", "Domain": "ACTION", "Description": "Creates a HTTPConnectionInfo object.", "Parameters": [{"Name": "isSecure", "Type": "boolean", "Description": "Is Secure communication"}], "Returns": [{"Type": "Object", "Description": "HTTP ConnectionInfo Object"}]},{"Function": "HTTP.ConnectionInfo.setProxy()", "Signature": "Object setProxy(Object connectionInfo, String proxyHost, int proxyPort)", "Domain": "ACTION", "Description": "Update HTTPConnectionInfo Object with proxy details.", "Parameters": [{"Name": "connectionInfo", "Type": "Object", "Description": "HTTP Connection Info Object"}, {"Name": "proxyHost", "Type": "String", "Description": "Proxy Host"}, {"Name": "proxyPort", "Type": "int", "Description": "Proxy Port"}], "Returns": [{"Type": "Object", "Description": "HTTP ConnectionInfo Object"}]},{"Function": "HTTP.ConnectionInfo.setHttpMethod()", "Signature": "void setHttpMethod(Object connectionInfo, String httpMethod)", "Domain": "ACTION", "Description": "Configures HTTP Connection to use specified HTTP method during invocation.", "Parameters": [{"Name": "connectionInfo", "Type": "Object", "Description": "HTTP Connection Info Object"}, {"Name": "httpMethod", "Type": "String", "Description": "Http methods i.e. GET/POST/PUT/DELETE/TRACE/HEAD/OPTIONS/PATCH"}], "Returns": [{"Type": "void", "Description": "void"}]},{"Function": "HTTP.ConnectionInfo.disableExpectContinueHeader()", "Signature": "Object disableExpectContinueHeader(Object connectionInfo, boolean expectContinueHeaderDisabled)", "Domain": "ACTION", "Description": "Configure HTTP Connection to enable/disable Expect-Continue Header.", "Parameters": [{"Name": "connectionInfo", "Type": "Object", "Description": "HTTP Connection Info Object"}, {"Name": "disableExpectContinueHeader", "Type": "boolean", "Description": "True to disable use. False by default"}], "Returns": [{"Type": "Object", "Description": "HTTP ConnectionInfo Object"}]},{"Function": "HTTP.ConnectionInfo.disableCookie()", "Signature": "void disableCookie(Object connectionInfo, boolean disableCookie)", "Domain": "ACTION", "Description": "Configures HTTP Connection to enable/disable cookies. Disable will ignore cookies both ways i.e. accepting from the server or sending back to the server.", "Parameters": [{"Name": "connectionInfo", "Type": "Object", "Description": "HTTP Connection Info Object"}, {"Name": "disableCookie", "Type": "boolean", "Description": "True to disable. False by default."}], "Returns": [{"Type": "void", "Description": "void"}]},{"Function": "Instance.createTransientInstanceFromEvent()", "Signature": "Concept createTransientInstanceFromEvent (String uri, SimpleEvent event)", "Domain": "ACTION", "Description": "This function returns a concept instance using the event's payload. Returned\ninstance is not asserted to WM", "Parameters": [{"Name": "uri", "Type": "String", "Description": "URI of the concept as defined in the project. uri cannot be null."}, {"Name": "SimpleEvent", "Type": "Event", "Description": "received"}], "Returns": [{"Type": "Concept", "Description": "The newly created concept."}], "Cautions": "none. The function does not assert the created concept."},{"Function": "Instance.startStateMachine()", "Signature": "void startStateMachine(Concept instance, boolean startChildren)", "Domain": "ACTION, BUI", "Description": "Start a Concept instance's main state machine, and optionally, the main state machines of its contained concepts.", "Parameters": [{"Name": "instance", "Type": "Concept", "Description": "A Concept instance"}, {"Name": "startChildren", "Type": "boolean", "Description": "instance"}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Instance.getById()", "Signature": "Concept getById (Object Id)", "Domain": "ACTION, BUI", "Description": "id", "Parameters": [{"Name": "id", "Type": "Object", "Description": "The id of the Concept instance to be returned, retrieved off"}], "Returns": [{"Type": "Concept", "Description": "id"}], "Cautions": "none"},{"Function": "Instance.createTransientInstanceFromXML()", "Signature": "Concept createTransientInstanceFromXML (String uri, String xml)", "Domain": "ACTION", "Description": "uri", "Parameters": [{"Name": "uri", "Type": "String", "Description": "concept."}, {"Name": "xml", "Type": "String", "Description": "XML string to be parsed"}], "Returns": [{"Type": "Concept", "Description": "The newly created concept"}], "Cautions": "none. The function does not assert the created concept."},{"Function": "Instance.createInstanceFromXML()", "Signature": "Concept createInstanceFromXML (String uri, String xml)", "Domain": "ACTION, BUI", "Description": "uri", "Parameters": [{"Name": "uri", "Type": "URI", "Description": "concept."}, {"Name": "xml", "Type": "String", "Description": "XML string to be parsed"}], "Returns": [{"Type": "Concept", "Description": "The newly created concept"}], "Cautions": "none. This function asserts the created concept but this assert will not fire any rules."},{"Function": "Instance.getExpandedName()", "Signature": "String getExpandedName (Concept instance)", "Domain": "ACTION, CONDITION, BUI, QUERY", "Description": "instance", "Parameters": [{"Name": "instance", "Type": "Concept", "Description": "A Concept instance"}], "Returns": [{"Type": "String", "Description": "instance"}], "Cautions": "none"},{"Function": "Instance.getStateMachineOwner()", "Signature": "Concept getStateMachineOwner (Concept instance)", "Domain": "ACTION, BUI", "Description": "instance", "Parameters": [{"Name": "instance", "Type": "Concept", "Description": "Concept instance"}], "Returns": [{"Type": "Concept", "Description": "instance"}], "Cautions": "none"},{"Function": "Instance.getByExtIdByUri()", "Signature": "Concept getByExtIdByURI (String extId, String uri)", "Domain": "ACTION, BUI", "Description": "extId", "Parameters": [{"Name": "extId", "Type": "String", "Description": "The extId of the Concept instance to be returned"}, {"Name": "uri", "Type": "String", "Description": "URI of a Concept in the project"}], "Returns": [{"Type": "Concept", "Description": "extId"}], "Cautions": "none"},{"Function": "Instance.updateInstanceFromXML()", "Signature": "Concept updateInstanceFromXML (String xml)", "Domain": "ACTION", "Description": "Update a Concept instance with data contained in an XML serialization of concept data.\nThe Concept instance to be updated is identified by an extId attribute in the serialized concept data.\nAn Exception will be thrown if the extId provided does not match any existing Concept instance.", "Parameters": [{"Name": "xml", "Type": "String", "Description": "An XML string to be deserialized"}], "Returns": [{"Type": "Concept", "Description": "The updated Concept instance"}], "Cautions": "none"},{"Function": "Instance.deleteInstance()", "Signature": "Concept deleteInstance (Concept instance)", "Domain": "ACTION, BUI", "Description": "instance", "Parameters": [{"Name": "instance", "Type": "Concept", "Description": "Concept instance to be retracted from the working memory and deleted."}], "Returns": [{"Type": "Concept", "Description": "instance"}], "Cautions": "none"},{"Function": "Instance.serializeToJSON()", "Signature": "String serializeToJSON (Concept instance, boolean pretty, String root)", "Domain": "ACTION", "Description": "Serializes a Concept instance into an JSON string.", "Parameters": [{"Name": "instance", "Type": "Concept", "Description": "The Concept instance to serialize."}, {"Name": "pretty", "Type": "boolean", "Description": "If true, the output will be formatted for human-readability."}, {"Name": "root", "Type": "String", "Description": "The name of the root element for the serialized data."}], "Returns": [{"Type": "String", "Description": "instance"}], "Cautions": "none"},{"Function": "Instance.updateInstanceFromJSON()", "Signature": "Concept updateInstanceFromJSON (String uri, String json)", "Domain": "ACTION", "Description": "Update a Concept instance with data contained in an JSON serialization of concept data.\nThe Concept instance to be updated is identified by an extId attribute in the serialized concept data.\nAn Exception will be thrown if the extId provided does not match any existing Concept instance.", "Parameters": [{"Name": "uri", "Type": "String", "Description": "URI of the Concept to be updated"}, {"Name": "json", "Type": "String", "Description": "An JSON string to be deserialized"}], "Returns": [{"Type": "Concept", "Description": "The updated Concept instance"}], "Cautions": "none"},{"Function": "Instance.createInstanceFromJSON()", "Signature": "Concept createInstanceFromJSON (String uri, String json)", "Domain": "ACTION, BUI", "Description": "serialize()", "Parameters": [{"Name": "uri", "Type": "URI", "Description": "Concept URI."}, {"Name": "json", "Type": "String", "Description": "JSON string to be parsed"}], "Returns": [{"Type": "Concept", "Description": "The newly created concept"}], "Cautions": "none. This function asserts the created concept but this assert will not fire any rules."},{"Function": "Instance.isModified()", "Signature": "boolean isModified (Concept instance)", "Domain": "ACTION, CONDITION, BUI", "Description": "instance", "Parameters": [{"Name": "instance", "Type": "Concept", "Description": "The Concept instance to test for modification."}], "Returns": [{"Type": "boolean", "Description": "instance"}], "Cautions": "This function works differently with scorecards than with concept instances. There is only one instance of a scorecard per agent, rather than one per RTC. So after a scorecard is modified it will return true until the agent is restarted."},{"Function": "Instance.getReverseReferences()", "Signature": "Object[] getReverseReferences(Concept instance)", "Domain": "ACTION", "Description": "instance", "Parameters": [{"Name": "instance", "Type": "Concept", "Description": "A Concept instance."}], "Returns": [{"Type": "Object[]", "Description": "instance"}], "Cautions": "none"},{"Function": "Instance.isStateMachine()", "Signature": "boolean isStateMachine (Concept instance)", "Domain": "ACTION, BUI", "Description": "Checks if a concept is a state machine.  Concepts that have state machines are state machine owners but are not state machines themselves.", "Parameters": [{"Name": "instance", "Type": "Concept", "Description": "Concept instance"}], "Returns": [{"Type": "boolean", "Description": "instance"}], "Cautions": "none"},{"Function": "Instance.isNew()", "Signature": "boolean isNew (Concept instance)", "Domain": "ACTION, CONDITION, BUI", "Description": "instance", "Parameters": [{"Name": "instance", "Type": "Concept", "Description": "The Concept instance to test."}], "Returns": [{"Type": "boolean", "Description": "instance"}], "Cautions": "none"},{"Function": "Instance.filterAndSerializeUsingDefaults()", "Signature": "String filterAndSerializeUsingDefaults (Concept instance, String propertyNameRegexFilter)", "Domain": "ACTION", "Description": "Serializes a Concept instance into an XML String with the default namespace URI for concepts,\nand with the inclusion of properties controlled by a regex filter", "Parameters": [{"Name": "instance", "Type": "Concept", "Description": "The Concept instance to serialize."}, {"Name": "propertyNameRegexFilter", "Type": "String", "Description": "java.util.regex.Pattern."}], "Returns": [{"Type": "String", "Description": "instance"}], "Cautions": "none"},{"Function": "Instance.updateInstance()", "Signature": "void updateInstance (String xslt-template)", "Domain": "ACTION", "Description": "Updates a Concept instance based on the data provided in the XSLT \nMapper. Modifying the instance in the working memory will\ncause any rule conditions that depend on the concept to be evaluated.", "Parameters": [{"Name": "xslt-template", "Type": "String", "Description": "String formed using the XSLT Mapper."}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Instance.createTransientInstanceFromJSON()", "Signature": "Concept createTransientInstanceFromJSON (String uri, String json)", "Domain": "ACTION", "Description": "serialize()", "Parameters": [{"Name": "uri", "Type": "String", "Description": "Concept URI."}, {"Name": "json", "Type": "String", "Description": "JSON string to be parsed"}], "Returns": [{"Type": "Concept", "Description": "The newly created concept"}], "Cautions": "none. The function does not assert the created concept."},{"Function": "Instance.serializeUsingDefaults()", "Signature": "String serializeUsingDefaults (Concept instance)", "Domain": "ACTION", "Description": "Serializes a Concept instance into an XML string using the default namespace URI for Concepts.", "Parameters": [{"Name": "instance", "Type": "Concept", "Description": "The Concept instance to serialize."}], "Returns": [{"Type": "String", "Description": "instance"}], "Cautions": "none"},{"Function": "Instance.serialize()", "Signature": "String serialize (Concept instance, boolean changedOnly, String nameSpace, String root)", "Domain": "ACTION", "Description": "Serializes a Concept instance into an XML string.", "Parameters": [{"Name": "instance", "Type": "Concept", "Description": "The Concept instance to serialize."}, {"Name": "changedOnly", "Type": "boolean", "Description": "ignored"}, {"Name": "nameSpace", "Type": "String", "Description": "The namespace for the serialized data."}, {"Name": "root", "Type": "String", "Description": "The name of the root element for the serialized data."}], "Returns": [{"Type": "String", "Description": "instance"}], "Cautions": "none"},{"Function": "Instance.newInstance()", "Signature": "Concept newInstance (String uri, String extId)", "Domain": "ACTION, BUI", "Description": "uri", "Parameters": [{"Name": "uri", "Type": "String", "Description": "URI in the project of the Concept to create"}, {"Name": "extId", "Type": "String", "Description": "extId of the newly created Concept instance"}], "Returns": [{"Type": "Concept", "Description": "The newly created Concept instance."}], "Cautions": "none"},{"Function": "Instance.newTransientInstance()", "Signature": "Concept newTransientInstance (String uri)", "Domain": "ACTION, BUI", "Description": "uri", "Parameters": [{"Name": "uri", "Type": "String", "Description": "URI in the project of the Concept to create"}], "Returns": [{"Type": "Concept", "Description": "The newly created Concept instance."}], "Cautions": "none"},{"Function": "Instance.createInstance()", "Signature": "Concept createInstance (String xslt-template)", "Domain": "ACTION", "Description": "Creates a new Concept instance based on the data provided in the XSLT \nMapper and adds it to the working memory. Adding the instance to the working memory will\ncause any rule conditions that depend on the concept to be evaluated.", "Parameters": [{"Name": "xslt-template", "Type": "String", "Description": "String formed using the XSLT Mapper."}], "Returns": [{"Type": "Concept", "Description": "The newly created Concept instance."}], "Cautions": "none"},{"Function": "Instance.PropertyArray.removeDateTime()", "Signature": "boolean removeDateTime (PropertyArrayDateTime arr, DateTime value)", "Domain": "ACTION, BUI", "Description": "value", "Parameters": [{"Name": "arr", "Type": "PropertyArrayDateTime", "Description": "A PropertyArrayDateTime for the action to be performed on."}, {"Name": "value", "Type": "DateTime", "Description": "Current value of the PropertyAtomDateTime for removal."}], "Returns": [{"Type": "boolean", "Description": "if a PropertyAtomDateTime is removed."}], "Cautions": "none"},{"Function": "Instance.PropertyArray.toArrayConcept()", "Signature": "Concept[] toArrayConcept(PropertyArrayConcept arr)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Returns a Concept[] containing all of the instances in a PropertyArrayConcept in the correct order", "Parameters": [{"Name": "arr", "Type": "PropertyArrayConcept", "Description": "A PropertyArray of type ConceptReference or ContainedConcept."}], "Returns": [{"Type": "Concept[]", "Description": "A Concept array containing all of the instances in PropertyArrayConcept in the correct order."}], "Cautions": "none"},{"Function": "Instance.PropertyArray.toArrayLong()", "Signature": "long[] toArrayLong(PropertyArray arr)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Returns a long[] containing all of the values in a PropertyArray in the correct order", "Parameters": [{"Name": "arr", "Type": "PropertyArray", "Description": "A PropertyArray of type double, int, or long."}], "Returns": [{"Type": "long[]", "Description": "A long array.  Returns null if pass in Array type can't be casted to long."}], "Cautions": "none"},{"Function": "Instance.PropertyArray.indexOfString()", "Signature": "int indexOfString(PropertyArrayString arr, String value)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns the index in the PropertyArrayString of the first occurrence of the specified String value,\nor -1 if the PropertyArrayString does not contain this String value.", "Parameters": [{"Name": "arr", "Type": "PropertyArrayString", "Description": "PropertyArrayString"}, {"Name": "value", "Type": "String", "Description": "String"}], "Returns": [{"Type": "int", "Description": "value"}], "Cautions": "none"},{"Function": "Instance.PropertyArray.removeLong()", "Signature": "boolean removeLong (PropertyArrayLong arr, long value)", "Domain": "ACTION, BUI", "Description": "value", "Parameters": [{"Name": "arr", "Type": "PropertyArrayLong", "Description": "A PropertyArrayLong for the action to be performed on."}, {"Name": "value", "Type": "long", "Description": "Current value of the PropertyAtomLong for removal."}], "Returns": [{"Type": "boolean", "Description": "if a PropertyAtomLong is removed."}], "Cautions": "none"},{"Function": "Instance.PropertyArray.toArrayBoolean()", "Signature": "boolean[] toArrayBoolean(PropertyArrayBoolean arr)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Returns a boolean[] containing all of the boolean values in a PropertyArrayBoolean in the correct order", "Parameters": [{"Name": "arr", "Type": "PropertyArrayBoolean", "Description": "A PropertyArray of boolean type."}], "Returns": [{"Type": "boolean[]", "Description": "A boolean array."}], "Cautions": "none"},{"Function": "Instance.PropertyArray.removeConceptReference()", "Signature": "boolean removeConceptReference (PropertyArrayConceptReference arr, Concept instance)", "Domain": "ACTION, BUI", "Description": "instance", "Parameters": [{"Name": "arr", "Type": "PropertyArrayConceptReference", "Description": "A PropertyArrayConceptReference for the action to be performed on."}, {"Name": "instance", "Type": "Concept", "Description": "Current value of the PropertyAtomConceptReference for removal."}], "Returns": [{"Type": "boolean", "Description": "if a PropertyAtomConceptReference is removed."}], "Cautions": "none"},{"Function": "Instance.PropertyArray.appendInt()", "Signature": "void appendInt (PropertyArrayInt arr, int value, long time)", "Domain": "ACTION, BUI", "Description": "Creates a new propertyAtomInt of value with initial history timestamp time and appends to the end of the\nPropertyArray. Use instanceX.arr[instanceX.arr@length] = value for appending with system current time", "Parameters": [{"Name": "arr", "Type": "PropertyArray", "Description": "A PropertyArray to append an element to."}, {"Name": "value", "Type": "int", "Description": "arr"}, {"Name": "time", "Type": "long", "Description": "The initial history timestamp."}], "Returns": [{"Type": "void"}], "Cautions": "Use instanceX.arr[instanceX.arr@length] = value for appending with system current time"},{"Function": "Instance.PropertyArray.toArrayInt()", "Signature": "int[] toArrayInt(PropertyArray arr)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Returns a int[] containing all of the values in a PropertyArray in the correct order", "Parameters": [{"Name": "arr", "Type": "PropertyArray", "Description": "A PropertyArray of type double, int, or long."}], "Returns": [{"Type": "int[]", "Description": "A int array.  Returns null if pass in Array type can't be casted to int."}], "Cautions": "none"},{"Function": "Instance.PropertyArray.appendLong()", "Signature": "void appendLong (PropertyArrayLong arr, long value, long time)", "Domain": "ACTION, BUI", "Description": "Creates a new propertyAtomLong of value with initial history timestamp time and appends to the end of the\nPropertyArray. Use instanceX.arr[instanceX.arr@length] = value for appending with system current time", "Parameters": [{"Name": "arr", "Type": "PropertyArray", "Description": "A PropertyArray to append an element to."}, {"Name": "value", "Type": "long", "Description": "arr"}, {"Name": "time", "Type": "long", "Description": "The initial history timestamp."}], "Returns": [{"Type": "void"}], "Cautions": "Use instanceX.arr[instanceX.arr@length] = value for appending with system current time"},{"Function": "Instance.PropertyArray.indexOfConceptReference()", "Signature": "int indexOfConceptReference(PropertyArrayConceptReference arr, Concept instance)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns the index in the PropertyArrayConceptReference of the first occurrence of the specified Concept instance,\nor -1 if the PropertyArrayConceptReference does not contain this Concept instance.", "Parameters": [{"Name": "arr", "Type": "PropertyArrayConceptReference", "Description": "PropertyArrayConceptReference"}, {"Name": "instance", "Type": "Concept", "Description": "Concept instance"}], "Returns": [{"Type": "int", "Description": "value"}], "Cautions": "none"},{"Function": "Instance.PropertyArray.appendContainedConcept()", "Signature": "void appendContainedConcept (PropertyArrayContainedConcept arr, ContainedConcept instance, long time)", "Domain": "ACTION, BUI", "Description": "PropertyAtomContainedConcept", "Parameters": [{"Name": "arr", "Type": "PropertyArray", "Description": "PropertyArray"}, {"Name": "instance", "Type": "ContainedConcept", "Description": "PropertyArray arr"}, {"Name": "time", "Type": "long", "Description": "The initial history timestamp."}], "Returns": [{"Type": "void"}], "Cautions": "Use instanceY.arr[instanceY.arr@length] = instanceX for appending with system current time"},{"Function": "Instance.PropertyArray.toArrayString()", "Signature": "String[] toArrayString(PropertyArray arr)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Returns a String[] containing all of the values in a PropertyArray in the correct order", "Parameters": [{"Name": "arr", "Type": "PropertyArray", "Description": "Any of the PropertyArray type e.g. PropertyArrayString, PropertyArrayInt, etc..."}], "Returns": [{"Type": "String[]", "Description": "A String array."}], "Cautions": "none"},{"Function": "Instance.PropertyArray.removeDouble()", "Signature": "boolean removeDouble (PropertyArrayDouble arr, double value)", "Domain": "ACTION, BUI", "Description": "value", "Parameters": [{"Name": "arr", "Type": "PropertyArrayDouble", "Description": "A PropertyArrayDouble for the action to be performed on."}, {"Name": "value", "Type": "double", "Description": "Current value of the PropertyAtomDouble for removal."}], "Returns": [{"Type": "boolean", "Description": "if a PropertyAtomDouble is removed."}], "Cautions": "none"},{"Function": "Instance.PropertyArray.appendBoolean()", "Signature": "void appendBoolean (PropertyArrayBoolean arr, boolean value, long time)", "Domain": "ACTION, BUI", "Description": "Creates a new propertyAtomBoolean of value with initial history timestamp time and appends to the end of the\nPropertyArray. Use instanceX.arr[instanceX.arr@length] = value for appending with system current time.", "Parameters": [{"Name": "arr", "Type": "PropertyArray", "Description": "A PropertyArray to append an element to."}, {"Name": "value", "Type": "boolean", "Description": "arr"}, {"Name": "time", "Type": "long", "Description": "The initial history timestamp."}], "Returns": [{"Type": "void"}], "Cautions": "Use instanceX.arr[instanceX.arr@length] = value for appending with system current time"},{"Function": "Instance.PropertyArray.appendDouble()", "Signature": "void appendDouble (PropertyArrayDouble arr, double value, long time)", "Domain": "ACTION, BUI", "Description": "Creates a new propertyAtomDouble of value with initial history timestamp time and appends to the end of the\nPropertyArray. Use instanceX.arr[instanceX.arr@length] = value for appending with system current time", "Parameters": [{"Name": "arr", "Type": "PropertyArray", "Description": "A PropertyArray to append an element to."}, {"Name": "value", "Type": "double", "Description": "arr"}, {"Name": "time", "Type": "long", "Description": "The initial history timestamp."}], "Returns": [{"Type": "void"}], "Cautions": "Use instanceX.arr[instanceX.arr@length] = value for appending with system current time"},{"Function": "Instance.PropertyArray.toArrayDouble()", "Signature": "double[] toArrayDouble(PropertyArray arr)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Returns a double[] containing all of the values in a PropertyArray in the correct order", "Parameters": [{"Name": "arr", "Type": "PropertyArray", "Description": "A PropertyArray of type double, int, or long."}], "Returns": [{"Type": "double[]", "Description": "A double array.  Returns null if pass in Array type can't be casted to double."}], "Cautions": "none"},{"Function": "Instance.PropertyArray.removeString()", "Signature": "boolean removeString (PropertyArrayString arr, String value)", "Domain": "ACTION, BUI", "Description": "value", "Parameters": [{"Name": "arr", "Type": "PropertyArrayString", "Description": "A PropertyArrayString for the action to be performed on."}, {"Name": "value", "Type": "String", "Description": "Current value of the PropertyAtomString for removal."}], "Returns": [{"Type": "boolean", "Description": "if a PropertyAtomString is removed."}], "Cautions": "none"},{"Function": "Instance.PropertyArray.appendString()", "Signature": "void appendString (PropertyArrayString arr, String value, long time)", "Domain": "ACTION, BUI", "Description": "Creates a new propertyAtomString of value with initial history timestamp time and appends to the end of the\nPropertyArray. Use instanceX.arr[instanceX.arr@length] = value for appending with system current time", "Parameters": [{"Name": "arr", "Type": "PropertyArray", "Description": "A PropertyArray to append an element to."}, {"Name": "value", "Type": "String", "Description": "arr"}, {"Name": "time", "Type": "long", "Description": "The initial history timestamp."}], "Returns": [{"Type": "void"}], "Cautions": "Use instanceX.arr[instanceX.arr@length] = value for appending with system current time"},{"Function": "Instance.PropertyArray.indexOfBoolean()", "Signature": "int indexOfBoolean(PropertyArrayBoolean arr, boolean value)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns the index in the PropertyArrayBoolean of the first occurrence of the specified boolean value,\nor -1 if the PropertyArrayBoolean does not contain this boolean value.", "Parameters": [{"Name": "arr", "Type": "PropertyArrayBoolean", "Description": "PropertyArrayBoolean"}, {"Name": "value", "Type": "boolean", "Description": "boolean"}], "Returns": [{"Type": "int", "Description": "value"}], "Cautions": "none"},{"Function": "Instance.PropertyArray.removeBoolean()", "Signature": "boolean removeBoolean (PropertyArrayBoolean arr, boolean value)", "Domain": "ACTION, BUI", "Description": "value", "Parameters": [{"Name": "arr", "Type": "PropertyArrayBoolean", "Description": "A PropertyArrayBoolean for the action to be performed on."}, {"Name": "value", "Type": "boolean", "Description": "Current value of the PropertyAtomBoolean for removal."}], "Returns": [{"Type": "boolean", "Description": "if a PropertyAtomBoolean is removed."}], "Cautions": "none"},{"Function": "Instance.PropertyArray.appendDateTime()", "Signature": "void appendDateTime (PropertyArrayDateTime arr, DateTime value, long time)", "Domain": "ACTION, BUI", "Description": "Creates a new propertyAtomDateTime of value with initial history timestamp time and appends to the end of the\nPropertyArray. Use instanceX.arr[instanceX.arr@length] = value for appending with system current time", "Parameters": [{"Name": "arr", "Type": "PropertyArray", "Description": "A PropertyArray to append an element to."}, {"Name": "value", "Type": "DateTime", "Description": "arr"}, {"Name": "time", "Type": "long", "Description": "The initial history timestamp."}], "Returns": [{"Type": "void"}], "Cautions": "Use instanceX.arr[instanceX.arr@length] = value for appending with system current time"},{"Function": "Instance.PropertyArray.removeContainedConcept()", "Signature": "boolean removeContainedConcept (PropertyArrayContainedConcept arr, ContainedConcept instance)", "Domain": "ACTION, BUI", "Description": "instance", "Parameters": [{"Name": "arr", "Type": "PropertyArrayContainedConcept", "Description": "A PropertyArrayContainedConcept for the action to be performed on."}, {"Name": "instance", "Type": "ContainedConcept", "Description": "Current value of the PropertyAtomContainedConcept for removal."}], "Returns": [{"Type": "boolean", "Description": "if a PropertyAtomContainedConcept is removed."}], "Cautions": "none"},{"Function": "Instance.PropertyArray.clear()", "Signature": "void clear (PropertyArray arr)", "Domain": "ACTION, BUI", "Description": "arr", "Parameters": [{"Name": "arr", "Type": "PropertyArray", "Description": "A PropertyArray to clear all elements from."}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Instance.PropertyArray.indexOfDateTime()", "Signature": "int indexOfDateTime(PropertyArrayDateTime arr, DateTime value)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns the index in the PropertyArrayDateTime of the first occurrence of the specified DateTime value,\nor -1 if the PropertyArrayDateTime does not contain this DateTime value.", "Parameters": [{"Name": "arr", "Type": "PropertyArrayDateTime", "Description": "PropertyArrayDateTime"}, {"Name": "value", "Type": "DateTime", "Description": "DateTime"}], "Returns": [{"Type": "int", "Description": "value"}], "Cautions": "none"},{"Function": "Instance.PropertyArray.toArrayDateTime()", "Signature": "DateTime[] toArrayDateTime(PropertyArrayDateTime arr)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Returns a DateTime[] containing all of the DateTime values in a PropertyArrayDateTime in the correct order", "Parameters": [{"Name": "arr", "Type": "PropertyArrayDateTime", "Description": "A PropertyArray of DateTime type."}], "Returns": [{"Type": "DateTime[]", "Description": "A DateTime array."}], "Cautions": "none"},{"Function": "Instance.PropertyArray.appendConceptReference()", "Signature": "void appendConceptReference (PropertyArrayConceptReference arr, Concept instance, long time)", "Domain": "ACTION, BUI", "Description": "PropertyAtomConceptReference", "Parameters": [{"Name": "arr", "Type": "PropertyArray", "Description": "A PropertyArray to append an element to."}, {"Name": "instance", "Type": "Concept", "Description": "arr"}, {"Name": "time", "Type": "long", "Description": "The initial history timestamp."}], "Returns": [{"Type": "void"}], "Cautions": "Use instanceY.arr[instanceY.arr@length] = instanceX for appending with system current time"},{"Function": "Instance.PropertyArray.indexOfContainedConcept()", "Signature": "int indexOfContainedConcept(PropertyArrayContainedConcept arr, ContainedConcept instance)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns the index in the PropertyArrayContainedConcept of the first occurrence of the specified ContainedConcept instance,\nor -1 if the PropertyArrayContainedConcept does not contain this ContainedConcept instance.", "Parameters": [{"Name": "arr", "Type": "PropertyArrayContainedConcept", "Description": "PropertyArrayContainedConcept"}, {"Name": "instance", "Type": "ContainedConcept", "Description": "ContainedConcept instance"}], "Returns": [{"Type": "int", "Description": "value"}], "Cautions": "none"},{"Function": "Instance.PropertyArray.removeInt()", "Signature": "boolean removeInt (PropertyArrayInt arr, int value)", "Domain": "ACTION, BUI", "Description": "value", "Parameters": [{"Name": "arr", "Type": "PropertyArrayInt", "Description": "A PropertyArrayInt for the action to be performed on."}, {"Name": "value", "Type": "int", "Description": "Current value of the PropertyAtomInt for removal."}], "Returns": [{"Type": "boolean", "Description": "if a PropertyAtomInt is removed."}], "Cautions": "none"},{"Function": "Instance.PropertyArray.delete()", "Signature": "void delete (PropertyArray arr, int index)", "Domain": "ACTION, BUI", "Description": "arr", "Parameters": [{"Name": "arr", "Type": "PropertyArray", "Description": "A PropertyArray to delete an element from."}, {"Name": "index", "Type": "int", "Description": "arr"}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Instance.PropertyArray.indexOfInt()", "Signature": "int indexOfInt(PropertyArrayInt arr, int value)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns the index in the PropertyArrayInt of the first occurrence of the specified int value,\nor -1 if the PropertyArrayInt does not contain this int value.", "Parameters": [{"Name": "arr", "Type": "PropertyArrayInt", "Description": "PropertyArrayInt"}, {"Name": "value", "Type": "int", "Description": "int"}], "Returns": [{"Type": "int", "Description": "value"}], "Cautions": "none"},{"Function": "Instance.PropertyArray.toArrayContainedConcept()", "Signature": "ContainedConcept[] toArrayContainedConcept(PropertyArrayContainedConcept arr)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Returns a ContainedConcept[] containing all of the instances in a PropertyArrayContainedConcept in the correct order", "Parameters": [{"Name": "arr", "Type": "PropertyArrayContainedConcept", "Description": "A PropertyArray of ContainedConcept type."}], "Returns": [{"Type": "ContainedConcept[]", "Description": "A ContainedConcept array containing all of the instances in PropertyArrayContainedConcept in the correct order."}], "Cautions": "none"},{"Function": "Instance.PropertyArray.indexOfLong()", "Signature": "int indexOfLong(PropertyArrayLong arr, long value)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns the index in the PropertyArrayLong of the first occurrence of the specified long value,\nor -1 if the PropertyArrayLong does not contain this long value.", "Parameters": [{"Name": "arr", "Type": "PropertyArrayLong", "Description": "PropertyArrayLong"}, {"Name": "value", "Type": "long", "Description": "long"}], "Returns": [{"Type": "int", "Description": "value"}], "Cautions": "none"},{"Function": "Instance.PropertyArray.indexOfDouble()", "Signature": "int indexOfDouble(PropertyArrayDouble arr, double value)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns the index in the PropertyArrayDouble of the first occurrence of the specified double value,\nor -1 if the PropertyArrayDouble does not contain this double value.", "Parameters": [{"Name": "arr", "Type": "PropertyArrayDouble", "Description": "PropertyArrayDouble"}, {"Name": "value", "Type": "double", "Description": "double"}], "Returns": [{"Type": "int", "Description": "value"}], "Cautions": "none"},{"Function": "Instance.StateMachine.getCurrentStateNames()", "Signature": "String[] getCurrentStateNames(Concept instance)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns an array of the current states (if any). The state machine could\nconcurrently be in many states so all the active states names are returned. The state name returned\nis the name defined at design time without the path. If the state machine is in a sub-state of the\ncomposite state then both the composite state as well as the sub-state are returned.", "Parameters": [{"Name": "instance", "Type": "Concept", "Description": "The Concept instance on which to get the state machine state names."}], "Returns": [{"Type": "String[]", "Description": "An array of all the current state names."}], "Cautions": "none"},{"Function": "Instance.StateMachine.getCurrentStatePaths()", "Signature": "String[] getCurrentStatePaths(Concept instance)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns an array of the full paths of current states (if any). The state machine could be\nconcurrently in many states so all the active state paths are returned.\nThe returned paths are the runtime paths which could be different from their design time equivalents.\nThe state name is nested; e.g., A$B implies B as a sub-state within A.", "Parameters": [{"Name": "instance", "Type": "Concept", "Description": "The Concept instance on which to get the state machine state paths."}], "Returns": [{"Type": "String[]", "Description": "An array of all the current state paths."}], "Cautions": "none"},{"Function": "Instance.Reflection.isPropertyInt()", "Signature": "boolean isPropertyInt(Object obj)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if an object is a PropertyInt object.", "Parameters": [{"Name": "obj", "Type": "Object", "Description": "The object to be checked"}], "Returns": [{"Type": "boolean", "Description": "Returns if it is a PropertyInt object"}], "Cautions": "none"},{"Function": "Instance.Reflection.isPropertyString()", "Signature": "boolean isPropertyString(Object obj)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if an object is a PropertyString object.", "Parameters": [{"Name": "obj", "Type": "Object", "Description": "The object to be checked"}], "Returns": [{"Type": "boolean", "Description": "Returns if it is a PropertyString object"}], "Cautions": "none"},{"Function": "Instance.Reflection.isPropertyArray()", "Signature": "boolean isPropertyArray(Object obj)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if an object is a PropertyArray object.", "Parameters": [{"Name": "obj", "Type": "Object", "Description": "The object to be checked"}], "Returns": [{"Type": "boolean", "Description": "Returns if it is a PropertyArray object"}], "Cautions": "none"},{"Function": "Instance.Reflection.getAllPropertyNames()", "Signature": "String[] getAllPropertyNames(Concept instance)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns all property names of a Concept Instance.", "Parameters": [{"Name": "instance", "Type": "Concept", "Description": "the concept instance"}], "Returns": [{"Type": "String[]", "Description": "The property names of the concept instance"}], "Cautions": "none"},{"Function": "Instance.Reflection.isPropertyConcept()", "Signature": "boolean isPropertyConcept(Object obj)", "Domain": "ACTION, CONDITION, QUERY", "Description": "This method checks if an object is a PropertyConcept object.", "Parameters": [{"Name": "obj", "Type": "Object", "Description": "The object to be checked"}], "Returns": [{"Type": "boolean", "Description": "Returns if it is a PropertyConcept object"}], "Cautions": "none"},{"Function": "Instance.Reflection.isPropertyContainedConcept()", "Signature": "boolean isPropertyContainedConcept(Object obj)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if an object is a PropertyContainedConcept object.", "Parameters": [{"Name": "obj", "Type": "Object", "Description": "The object to be checked"}], "Returns": [{"Type": "boolean", "Description": "Returns if it is a PropertyContainedConcept object"}], "Cautions": "none"},{"Function": "Instance.Reflection.setPropertyArrayValue()", "Signature": "boolean setPropertyArrayValue(Concept instance, String name, int index, Object value)", "Domain": "ACTION, BUI", "Description": "Given the concept instance and property name, set the value of a PropertyArray at index to the value passed.", "Parameters": [{"Name": "instance", "Type": "Concept", "Description": "the concept instance"}, {"Name": "name", "Type": "String", "Description": "The name of the propertyArray"}, {"Name": "index", "Type": "int", "Description": "The position in the propertyArray"}, {"Name": "value", "Type": "Object", "Description": "The new value, the type has to be matched the property type."}], "Returns": [{"Type": "boolean", "Description": "true if property is set to new value, false otherwise.  e.g. mismatched type, no such property exception."}], "Cautions": "none"},{"Function": "Instance.Reflection.getPropertyArrayLength()", "Signature": "int getPropertyArrayLength(Concept instance, String name)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns the length of a PropertyArray given the Concept instance and the property name.\nIt returns -1 if the length can't be determined. e.g. no such propertyArray exception", "Parameters": [{"Name": "instance", "Type": "Concept", "Description": "the concept instance"}, {"Name": "name", "Type": "String", "Description": "the propertyArray name"}], "Returns": [{"Type": "int", "Description": "The length of a PropertyArray."}], "Cautions": "none"},{"Function": "Instance.Reflection.isPropertyBoolean()", "Signature": "boolean isPropertyBoolean(Object obj)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if an object is a PropertyBoolean object.", "Parameters": [{"Name": "obj", "Type": "Object", "Description": "The object to be checked"}], "Returns": [{"Type": "boolean", "Description": "Returns if it is a PropertyBoolean object"}], "Cautions": "none"},{"Function": "Instance.Reflection.getPropertyArrayValue()", "Signature": "Object getPropertyArrayValue(Concept instance, String name, int index)", "Domain": "ACTION, BUI", "Description": "Given the concept instance and property name, get the value of a PropertyArray at the index passed.", "Parameters": [{"Name": "instance", "Type": "Concept", "Description": "The concept instance"}, {"Name": "name", "Type": "String", "Description": "The name of the propertyArray"}, {"Name": "index", "Type": "int", "Description": "The position in the propertyArray"}], "Returns": [{"Type": "Object", "Description": "The value of the named property"}], "Cautions": "none"},{"Function": "Instance.Reflection.isProperty()", "Signature": "boolean isProperty(Object obj)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if an object is a Property object.", "Parameters": [{"Name": "obj", "Type": "Object", "Description": "The object to be checked"}], "Returns": [{"Type": "boolean", "Description": "Returns if it is a Property object"}], "Cautions": "none"},{"Function": "Instance.Reflection.getProperty()", "Signature": "Object getProperty(Concept instance, String propertyName)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns a property of a Concept Instance given the property name.", "Parameters": [{"Name": "instance", "Type": "Concept", "Description": "the concept instance"}, {"Name": "propertyName", "Type": "String", "Description": "the property name"}], "Returns": [{"Type": "Object", "Description": "The property of the concept instance with the given property name"}], "Cautions": "none"},{"Function": "Instance.Reflection.isPropertyLong()", "Signature": "boolean isPropertyLong(Object obj)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if an object is a PropertyLong object.", "Parameters": [{"Name": "obj", "Type": "Object", "Description": "The object to be checked"}], "Returns": [{"Type": "boolean", "Description": "Returns if it is a PropertyLong object"}], "Cautions": "none"},{"Function": "Instance.Reflection.getAllProperties()", "Signature": "Object[] getAllProperties(Concept instance)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns all properties of a Concept Instance.", "Parameters": [{"Name": "instance", "Type": "Concept", "Description": "the concept instance"}], "Returns": [{"Type": "Object[]", "Description": "The properties of the concept instance"}], "Cautions": "none"},{"Function": "Instance.Reflection.isPropertyDateTime()", "Signature": "boolean isPropertyDateTime(Object obj)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if an object is a PropertyDateTime object.", "Parameters": [{"Name": "obj", "Type": "Object", "Description": "The object to be checked"}], "Returns": [{"Type": "boolean", "Description": "Returns if it is a PropertyDateTime object"}], "Cautions": "none"},{"Function": "Instance.Reflection.isPropertyConceptReference()", "Signature": "boolean isPropertyConceptReference(Object obj)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if an object is a PropertyConceptReference object.", "Parameters": [{"Name": "obj", "Type": "Object", "Description": "The object to be checked"}], "Returns": [{"Type": "boolean", "Description": "Returns if it is a PropertyConceptReference object"}], "Cautions": "none"},{"Function": "Instance.Reflection.toObject()", "Signature": "Object toObject(Property pa)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method explicitly casts the property to an object. It returns the property object, not the value in the property.", "Parameters": [{"Name": "pa", "Type": "Property", "Description": "The target property."}], "Returns": [{"Type": "Object", "Description": "The casted Property object."}], "Cautions": "none"},{"Function": "Instance.Reflection.setPropertyAtomValue()", "Signature": "boolean setPropertyAtomValue(Concept instance, String name, Object value)", "Domain": "ACTION, BUI", "Description": "Given the concept instance and property name, set the value of a PropertyAtom to the value passed.", "Parameters": [{"Name": "instance", "Type": "Concept", "Description": "the concept instance"}, {"Name": "name", "Type": "String", "Description": "The name of the propertyAtom"}, {"Name": "value", "Type": "Object", "Description": "The new value for the property. Its type has to be matched the property type."}], "Returns": [{"Type": "boolean", "Description": "true if property is set to new value, false otherwise.  e.g. mismatched type, no such property exception."}], "Cautions": "none"},{"Function": "Instance.Reflection.isPropertyAtom()", "Signature": "boolean isPropertyAtom(Object obj)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if an object is a PropertyAtom object.", "Parameters": [{"Name": "obj", "Type": "Object", "Description": "The object to be checked"}], "Returns": [{"Type": "boolean", "Description": "Returns if it is a PropertyAtom object"}], "Cautions": "none"},{"Function": "Instance.Reflection.isPropertyDouble()", "Signature": "boolean isPropertyDouble(Object obj)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method checks if an object is a PropertyDouble object.", "Parameters": [{"Name": "obj", "Type": "Object", "Description": "The object to be checked"}], "Returns": [{"Type": "boolean", "Description": "Returns if it is a PropertyDouble object"}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.setPropertyValue()", "Signature": "boolean setPropertyValue (PropertyAtom pa, Object value)", "Domain": "ACTION, BUI", "Description": "Sets the value of the PropertyAtom to the value passed.", "Parameters": [{"Name": "pa", "Type": "PropertyAtom", "Description": "The property atom to set a new value for."}, {"Name": "value", "Type": "Object", "Description": "The new value for the property. Its type has to be matched the property type."}], "Returns": [{"Type": "boolean", "Description": "true if property is set to new value with the given time, false otherwise."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.getBooleanHistoryValue()", "Signature": "boolean getBooleanHistoryValue (PropertyAtomBoolean propertyAtomBoolean, int idx)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the value of the PropertyAtomBoolean passed, at the specified index in the ring buffer.\noldest value is at index 0.", "Parameters": [{"Name": "propertyAtomBoolean", "Type": "PropertyAtomBoolean", "Description": "The property atom to get the value for."}, {"Name": "idx", "Type": "int", "Description": "Index of the value needed in the ring buffer."}], "Returns": [{"Type": "boolean", "Description": "The result, meaning get the property value at the given index."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.getHistoryValue()", "Signature": "Object getHistoryValue(PropertyAtom propertyAtom, int idx)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the value of the PropertyAtom passed, at the specified index in the ring buffer.\noldest value is at index 0.", "Parameters": [{"Name": "propertyAtom", "Type": "PropertyAtom", "Description": "The property atom to get the value for."}, {"Name": "idx", "Type": "int", "Description": "Index of the value needed in the ring buffer."}], "Returns": [{"Type": "Object", "Description": "The result, meaning get the property value at the given index."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.getLong()", "Signature": "long getLong (PropertyAtomLong propertyAtomLong, long time)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the value of the PropertyAtomLong passed, at the time stamp specified.", "Parameters": [{"Name": "propertyAtomLong", "Type": "PropertyAtomLong", "Description": "The property atom to get the value for."}, {"Name": "time", "Type": "long", "Description": "With history tracking enabled, a property's value can change over time. The function returns the value of the property at the specified time. For example to get the current property value, use System.currentTimeMillis()."}], "Returns": [{"Type": "long", "Description": "the result."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.getDateTimeHistoryValue()", "Signature": "DateTime getDateTimeHistoryValue (PropertyAtomDateTime propertyAtomDateTime, int idx)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the value of the PropertyAtomDateTime passed, at the specified index in the ring buffer.\nOldest value is at index 0.", "Parameters": [{"Name": "propertyAtomDateTime", "Type": "PropertyAtomDateTime", "Description": "The property atom to get the value for."}, {"Name": "idx", "Type": "int", "Description": "Index of the value needed in the ring buffer in the ring buffer."}], "Returns": [{"Type": "DateTime", "Description": "the result."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.getDouble()", "Signature": "double getDouble (PropertyAtomDouble propertyAtomDouble, long time)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the value of the PropertyAtomDouble passed, at the time stamp specified.", "Parameters": [{"Name": "propertyAtomDouble", "Type": "PropertyAtomDouble", "Description": "The property atom to get the value for."}, {"Name": "time", "Type": "long", "Description": "With history tracking enabled, a property's value can change over time. The function returns the value of the property at the specified time. For example to get the current property value, use System.currentTimeMillis()."}], "Returns": [{"Type": "double", "Description": "the result."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.getPropertyValue()", "Signature": "Object getPropertyValue(PropertyAtom propertyAtom)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the current value of a PropertyAtom.", "Parameters": [{"Name": "propertyAtom", "Type": "PropertyAtom", "Description": "The property atom to get the value for."}], "Returns": [{"Type": "Object", "Description": "the result."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.getInt()", "Signature": "int getInt (PropertyAtomInt propertyAtomInt, long time)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the value of the PropertyAtomInt passed, at the time stamp specified.", "Parameters": [{"Name": "propertyAtomInt", "Type": "PropertyAtomInt", "Description": "The property atom to get the value for."}, {"Name": "time", "Type": "long", "Description": "With history tracking enabled, a property's value can change over time. The function returns the value of the property at the specified time. For example to get the current property value, use System.currentTimeMillis()."}], "Returns": [{"Type": "int", "Description": "the result."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.setLong()", "Signature": "boolean setLong (PropertyAtomLong pal, long value, long time)", "Domain": "ACTION, BUI", "Description": "propertyAtomLong", "Parameters": [{"Name": "pal", "Type": "PropertyAtomLong", "Description": "The property atom to set a new value for."}, {"Name": "value", "Type": "long", "Description": "The new value for the property."}, {"Name": "time", "Type": "long", "Description": "The time stamp describing when this property changed."}], "Returns": [{"Type": "boolean", "Description": "true if property is set to new value with the given time, false otherwise."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.getContainedConcept()", "Signature": "Concept getContainedConcept (PropertyAtomContainedConcept pacc, long time)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the value of the PropertyAtomContainedConcept at a particular time.", "Parameters": [{"Name": "pacc", "Type": "PropertyAtomContainedConcept", "Description": "The property atom to get the value for."}, {"Name": "time", "Type": "long", "Description": "With history tracking enabled, a property's value can change over time. The function returns the value of the property at the specified time. For example to get the current property value, use System.currentTimeMillis()."}], "Returns": [{"Type": "Concept", "Description": "The result."}]},{"Function": "Instance.PropertyAtom.setConceptReference()", "Signature": "boolean setConceptReference (PropertyAtomConceptReference parc, Concept value, long time)", "Domain": "ACTION, BUI", "Description": "Sets the value of the PropertyAtom to the value passed with the time stamp specified.", "Parameters": [{"Name": "parc", "Type": "PropertyAtomConceptReference", "Description": "The property atom to set a new value for."}, {"Name": "value", "Type": "Concept", "Description": "The new value for the property."}, {"Name": "time", "Type": "long", "Description": "The time stamp describing when this property changed."}], "Returns": [{"Type": "boolean", "Description": "true if property is set to new value with the given time, false otherwise."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.getDoubleHistoryValue()", "Signature": "double getDoubleHistoryValue (PropertyAtomDouble propertyAtomDouble, int idx)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the value of the PropertyAtomDouble passed, at the specified index in the ring buffer.\nOldest value is at index 0.", "Parameters": [{"Name": "propertyAtomDouble", "Type": "PropertyAtomDouble", "Description": "The property atom to get the value for."}, {"Name": "idx", "Type": "int", "Description": "Index of the value needed in the ring buffer."}], "Returns": [{"Type": "double", "Description": "the result."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.getDateTime()", "Signature": "DateTime getDateTime (PropertyAtomDateTime propertyAtomDateTime, long time)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the value of the PropertyAtomDateTime passed, at the time stamp specified.", "Parameters": [{"Name": "propertyAtomDateTime", "Type": "PropertyAtomDateTime", "Description": "The property atom to get the value for."}, {"Name": "time", "Type": "long", "Description": "With history tracking enabled, a property's value can change over time. The function returns the value of the property at the specified time. For example to get the current property value, use System.currentTimeMillis()."}], "Returns": [{"Type": "DateTime", "Description": "the result.\nMeaning get the property value at the given time."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.setDouble()", "Signature": "boolean setDouble (PropertyAtomDouble pad, double value, long time)", "Domain": "ACTION, BUI", "Description": "Sets the value of the PropertyAtom to the value passed with the time stamp specified.", "Parameters": [{"Name": "pad", "Type": "PropertyAtomDouble", "Description": "The property atom to set a new value for."}, {"Name": "value", "Type": "double", "Description": "The new value for the property."}, {"Name": "time", "Type": "long", "Description": "The time stamp describing when this property changed."}], "Returns": [{"Type": "boolean", "Description": "true if property is set to new value with the given time, false otherwise."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.getValueAt()", "Signature": "Object getValueAt(PropertyAtom propertyAtom, long time)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the value of the PropertyAtom passed, at the time stamp specified.", "Parameters": [{"Name": "propertyAtom", "Type": "PropertyAtom", "Description": "The property atom to get the value for."}, {"Name": "time", "Type": "long", "Description": "With history tracking enabled, a property's value can change over time. The function returns the value of the property at the specified time. For example to get the current property value, use System.currentTimeMillis()."}], "Returns": [{"Type": "Object", "Description": "the result.\nMeaning get the property value at the given time."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.setInt()", "Signature": "boolean setInt (PropertyAtomInt pai, int value, long time)", "Domain": "ACTION, BUI", "Description": "Sets the value of the PropertyAtom to the value passed with the time stamp specified.", "Parameters": [{"Name": "pai", "Type": "PropertyAtomInt", "Description": "The property atom to set a new value for."}, {"Name": "value", "Type": "int", "Description": "The new value for the property."}, {"Name": "time", "Type": "long", "Description": "The time stamp describing when this property changed."}], "Returns": [{"Type": "boolean", "Description": "true if property is set to new value with the given time, false otherwise."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.getBoolean()", "Signature": "boolean getBoolean (PropertyAtomBoolean propertyAtomBoolean, long time)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the value of the PropertyAtomBoolean passed, at the time stamp specified.", "Parameters": [{"Name": "propertyAtomBoolean", "Type": "PropertyAtomBoolean", "Description": "The property atom to get the value for."}, {"Name": "time", "Type": "long", "Description": "With history tracking enabled, a property's value can change over time. The function returns the value of the property at the specified time. For example to get the current property value, use System.currentTimeMillis()."}], "Returns": [{"Type": "boolean", "Description": "The result, meaning get the property value at the given time."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.setValueAt()", "Signature": "boolean setValueAt (PropertyAtom pa, Object value, long time)", "Domain": "ACTION, BUI", "Description": "Sets the value of the PropertyAtom to the value passed with the time stamp specified.", "Parameters": [{"Name": "pa", "Type": "PropertyAtom", "Description": "The property atom to set a new value for."}, {"Name": "value", "Type": "Object", "Description": "The new value for the property. Its type has to be matched the property type."}, {"Name": "time", "Type": "long", "Description": "The time stamp describing when this property changed."}], "Returns": [{"Type": "boolean", "Description": "true if property is set to new value with the given time, false otherwise."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.numHistoryValues()", "Signature": "int numHistoryValues(PropertyAtom pa)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns how many history values exist for given property.\nThe value is bounded by history size.", "Parameters": [{"Name": "pa", "Type": "PropertyAtom", "Description": "The property to get the history value count on."}], "Returns": [{"Type": "int", "Description": "Number of history values that exist."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.setBoolean()", "Signature": "boolean setBoolean (PropertyAtomBoolean pab, boolean value, long time)", "Domain": "ACTION, BUI", "Description": "Sets the value of the PropertyAtom to the value passed with the time stamp specified.", "Parameters": [{"Name": "pab", "Type": "PropertyAtomBoolean", "Description": "The property atom to set a new value for."}, {"Name": "value", "Type": "boolean", "Description": "The new value for the property."}, {"Name": "time", "Type": "long", "Description": "The time stamp describing when this property changed."}], "Returns": [{"Type": "boolean", "Description": "true if property is set to new value with the given time, false otherwise."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.getContainedConceptHistoryValue()", "Signature": "Concept getContainedConceptHistoryValue (PropertyAtomContainedConcept pacc, int idx)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the value of the PropertyAtomContainedConcept at a specified index in the ring buffer.\nOldest value is at index 0.", "Parameters": [{"Name": "pacc", "Type": "PropertyAtomContainedConcept", "Description": "The property atom to get the value for."}, {"Name": "idx", "Type": "int", "Description": "Index of the value needed in the ring buffer."}], "Returns": [{"Type": "Concept", "Description": "The result."}]},{"Function": "Instance.PropertyAtom.setString()", "Signature": "boolean setString (PropertyAtomString pas, String value, long time)", "Domain": "ACTION, BUI", "Description": "Sets the value of the PropertyAtom to the value passed with the time stamp specified.", "Parameters": [{"Name": "pas", "Type": "PropertyAtomString", "Description": "The property atom to set a new value for."}, {"Name": "value", "Type": "String", "Description": "The new value for the property."}, {"Name": "time", "Type": "long", "Description": "The time stamp describing when this property changed."}], "Returns": [{"Type": "boolean", "Description": "true if property is set to new value with the given time, false otherwise."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.getConceptReferenceHistoryValue()", "Signature": "Concept getConceptReferenceHistoryValue (PropertyAtomConceptReference parc, int idx)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the value of the PropertyAtomConceptReference at a given specified index in the ring buffer.\nOldest value is at index 0", "Parameters": [{"Name": "parc", "Type": "PropertyAtomConceptReference", "Description": "The property atom to get the value for."}, {"Name": "idx", "Type": "int", "Description": "Index of the value needed in the ring buffer."}], "Returns": [{"Type": "Concept", "Description": "The result."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.setDateTime()", "Signature": "boolean setDateTime (PropertyAtomDateTime padt, DateTime value, long time)", "Domain": "ACTION, BUI", "Description": "Sets the value of the PropertyAtom to the value passed with the time stamp specified.", "Parameters": [{"Name": "padt", "Type": "PropertyAtomDateTime", "Description": "The property atom to set a new value for."}, {"Name": "value", "Type": "DateTime", "Description": "The new value for the property."}, {"Name": "time", "Type": "long", "Description": "The time stamp describing when this property changed."}], "Returns": [{"Type": "boolean", "Description": "true if property is set to new value with the given time, false otherwise."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.getIntHistoryValue()", "Signature": "int getIntHistoryValue (PropertyAtomInt propertyAtomInt, int idx)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the value of the PropertyAtomInt passed, at the specified index in the ring buffer.\nOldest value is at index 0.", "Parameters": [{"Name": "propertyAtomInt", "Type": "PropertyAtomInt", "Description": "The property atom to get the value for."}, {"Name": "idx", "Type": "int", "Description": "Index of the value needed in the ring buffer."}], "Returns": [{"Type": "int", "Description": "the result."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.historySize()", "Signature": "int historySize(PropertyAtom pa)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "This method returns the size of the history buffer as specified in the design environment.", "Parameters": [{"Name": "pa", "Type": "PropertyAtom", "Description": "The property to get the history size from."}], "Returns": [{"Type": "int", "Description": "Size of the history buffer."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.getStringHistoryValue()", "Signature": "String getStringHistoryValue (PropertyAtomString propertyAtomString, int idx)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the value of the PropertyAtomString passed, at the specified index in the ring buffer.\nOldest value is at index 0.", "Parameters": [{"Name": "propertyAtomString", "Type": "PropertyAtomString", "Description": "The property atom to get the value for."}, {"Name": "idx", "Type": "int", "Description": "Index of the value needed in the ring buffer."}], "Returns": [{"Type": "String", "Description": "the result."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.getString()", "Signature": "String getString (PropertyAtomString propertyAtomString, long time)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the value of the PropertyAtomString passed, at the time stamp specified.", "Parameters": [{"Name": "propertyAtomString", "Type": "PropertyAtomString", "Description": "The property atom to get the value for."}, {"Name": "time", "Type": "long", "Description": "With history tracking enabled, a property's value can change over time. The function returns the value of the property at the specified time. For example to get the current property value, use System.currentTimeMillis()."}], "Returns": [{"Type": "String", "Description": "the result."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.getHistoryTime()", "Signature": "long getHistoryTime(PropertyAtom propertyAtom, int idx)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Get the history timestamp of this PropertyAtom value for a given index. Returns 0 if the index has not yet been used.", "Parameters": [{"Name": "propertyAtom", "Type": "PropertyAtom", "Description": "The property atom to get the timestamp for."}, {"Name": "idx", "Type": "Index", "Description": "of the value timestamp is needed for."}], "Returns": [{"Type": "long", "Description": "the timestamp of the PropertyAtom."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.getConceptReference()", "Signature": "Concept getConceptReference (PropertyAtomConceptReference parc, long time)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the value of the PropertyAtomConceptReference at a particular time.", "Parameters": [{"Name": "parc", "Type": "PropertyAtomConceptReference", "Description": "The property atom to get the value for."}, {"Name": "time", "Type": "long", "Description": "With history tracking enabled, a property's value can change over time. The function returns the value of the property at the specified time. For example to get the current property value, use System.currentTimeMillis()."}], "Returns": [{"Type": "Concept", "Description": "The result."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.getLongHistoryValue()", "Signature": "long getLongHistoryValue (PropertyAtomLong propertyAtomLong, int idx)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the value of the PropertyAtomLong passed, at the specified index in the ring buffer.\nOldest value is at index 0.", "Parameters": [{"Name": "propertyAtomLong", "Type": "PropertyAtomLong", "Description": "The property atom to get the value for."}, {"Name": "idx", "Type": "int", "Description": "Index of the value needed in the ring buffer."}], "Returns": [{"Type": "long", "Description": "the result."}], "Cautions": "none"},{"Function": "Instance.PropertyAtom.setContainedConcept()", "Signature": "boolean setContainedConcept (PropertyAtomContainedConcept pacc, ContainedConcept value, long time)", "Domain": "ACTION, BUI", "Description": "Sets the value of the PropertyAtom to the value passed with the time stamp specified.", "Parameters": [{"Name": "pacc", "Type": "PropertyAtomContainedConcept", "Description": "The property atom to set a new value for."}, {"Name": "value", "Type": "ContainedConcept", "Description": "The new value for the property."}, {"Name": "time", "Type": "long", "Description": "The time stamp describing when this property changed."}], "Returns": [{"Type": "boolean", "Description": "true if property is set to new value with the given time, false otherwise."}], "Cautions": "If a new ContainedConcept is set to the current value of PropertyContainedConcept, the\nold one will be retracted automatically from the working memory."},{"Function": "VRF.invokeAllVRFImpls()", "Signature": "Object invokeAllVRFImpls (String vrfURI, Object[] args)", "Domain": "ACTION, BUI", "Description": "Invoke all implementations of a virtual rule function.", "Parameters": [{"Name": "vrfURI", "Type": "String", "Description": "The URI of the virtual rule function."}, {"Name": "args", "Type": "Object[]", "Description": "The input arguments."}], "Returns": [{"Type": "Object", "Description": "Result Map containing the matched rules associated to the executed Decision Table. Key-Value pair structure, with Key being the Decision Table name and value being the integer array containing the matched rule Ids."}], "Cautions": "none", "Example": "Object[] sample_args = {arg1, arg2};  VRF.invokeAllVRFImpls(\"/Virtual_RF/Sample_VirtualRuleFunction\",sample_args);"},{"Function": "VRF.getVRFImpls()", "Signature": "Object[] getVRFImpls (String vrfURI)", "Domain": "ACTION, BUI", "Description": "Get all the available implementations of a virtual rule function.", "Parameters": [{"Name": "vrfURI", "Type": "String", "Description": "The URI of the virtual rule function."}], "Returns": [{"Type": "Object[]", "Description": "List of available implementations.  Null if none found."}], "Cautions": "none", "Example": "Object[] vrfImplArray = VRF.getVRFImpls(\"/Virtual_RF/Sample_VirtualRuleFunction\");  Here vrfImplArray variable have all implementations of virtual rule function."},{"Function": "VRF.invokeVRFImplByName()", "Signature": "int[] invokeVRFImplByName (String vrfURI, String implName, Object[] args)", "Domain": "ACTION, BUI", "Description": "Invoke a virtual rule function implementation by name.", "Parameters": [{"Name": "vrfURI", "Type": "String", "Description": "The URI of the virtual rule function."}, {"Name": "implName", "Type": "String", "Description": "The name of the virtual rule function implementation."}, {"Name": "args", "Type": "Object[]", "Description": "The input arguments."}], "Returns": [{"Type": "int[]", "Description": "Integer array containing the matched rule Ids."}], "Cautions": "none", "Example": "Object[] sample_args = {arg1, arg2};  VRF.invokeVRFImplByName(\"/Virtual_RF/Sample_VirtualRuleFunction\",\"Sample_Impl_Name\",sample_args);"},{"Function": "VRF.invokeVRFImpls()", "Signature": "Object invokeVRFImpls (Object[] vrfImpls, Object[] args, Object[] returnValues)", "Domain": "ACTION, BUI", "Description": "Invoke an array of virtual rule function implementations.", "Parameters": [{"Name": "vrfImpls", "Type": "Object[]", "Description": "An array of virtual rule function implementation objects (gotten from getVRFImpls or getVRFImplByName)."}, {"Name": "args", "Type": "Object[]", "Description": "The input arguments."}, {"Name": "returnValues", "Type": "Object[]", "Description": "Optional.  If non-null, the result of invoking each element of vrfImpls will be placed into returnValues in the same order as vrfImpls.  Functions returning void will add null entries to returnValues."}], "Returns": [{"Type": "Object", "Description": "Result Map containing the matched rules associated to the executed Decision Table. Key-Value pair structure, with Key being the Decision Table name and value being the integer array containing the matched rule Ids."}], "Cautions": "none", "Example": "Object[] vrfImplArray = VRF.getVRFImpls(\"/Virtual_RF/Sample_VirtualRuleFunction\");  Object[] sample_args = {arg1, arg2};  VRF.invokeVRFImpls (vrfImplArray, sample_args, null);"},{"Function": "VRF.getVRFImplNames()", "Signature": "String[] getVRFImplNames (String vrfURI)", "Domain": "ACTION, BUI", "Description": "Get the names of all available implementations of a virtual rule function.", "Parameters": [{"Name": "vrfURI", "Type": "String", "Description": "The URI of the virtual rule function."}], "Returns": [{"Type": "String[]", "Description": "List of names of available implementations.  Null if none found."}], "Cautions": "none", "Example": "String[] implNames = VRF.getVRFImplNames(\"/Virtual_RF/Sample_VirtualRuleFunction\");  Here implNames is array of names of all available implementations of a virtual rule function."},{"Function": "VRF.invokeVRFImpl()", "Signature": "int[] invokeVRFImpl (Object vrfImpl, Object[] args)", "Domain": "ACTION, BUI", "Description": "Invoke a virtual rule function implementation.", "Parameters": [{"Name": "vrfImpl", "Type": "Object", "Description": "A virtual rule function implementation object (gotten from getVRFImplByName or getVRFImpls)."}, {"Name": "args", "Type": "Object[]", "Description": "The input arguments."}], "Returns": [{"Type": "int[]", "Description": "Integer array containing the matched rule Ids."}], "Cautions": "none", "Example": "Object vrfImpl = VRF.getVRFImplByName(\"/Virtual_RF/Sample_VirtualRuleFunction\",\"Sample_Impl\");  Object[] sample_args = {arg1, arg2};  VRF.invokeVRFImpl (vrfImpl, sample_args);"},{"Function": "VRF.getVRFImplByName()", "Signature": "Object getVRFImplByName (String vrfURI, String implName)", "Domain": "ACTION, BUI", "Description": "Get an implementation of a virtual rule function.", "Parameters": [{"Name": "vrfURI", "Type": "String", "Description": "The URI of the virtual rule function."}, {"Name": "implName", "Type": "String", "Description": "The name of the virtual rule function implementation."}], "Returns": [{"Type": "Object", "Description": "The implementation.  Null if none found."}], "Cautions": "none", "Example": "Object vrfImpl = VRF.getVRFImplByName(\"/Virtual_RF/Sample_VirtualRuleFunction\",\"Sample_Impl\");  Here vrfImpl object is the implementation of a virtual rule function."},{"Function": "Log.logException()", "Signature": "void logException(Object logger, String level, String message, BEException thrown, Object... arguments)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Logs a message with an exception.", "Parameters": [{"Name": "logger", "Type": "Object", "Description": "The logger obtained from getLogger(..)"}, {"Name": "level", "Type": "String", "Description": "The log level. Defaults to \"debug\"."}, {"Name": "message", "Type": "String", "Description": "The message to log, with optional argument placeholders."}, {"Name": "thrown", "Type": "BEException", "Description": "An exception to be logged."}, {"Name": "arguments", "Type": "Object...", "Description": "The argument values to be substituted in the message."}], "Returns": [{"Type": "void"}], "Cautions": "none", "Example": "Object logger = Log.getLogger(\"Rules.VerifyCreditRF\");\nLog.logException(logger, \"error\", \"Logged this message with argument %s\", Exception.newException(....), myArgument);"},{"Function": "Log.setLevel()", "Signature": "void setLevel(Object oLogger, String logLevel)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Change the level.", "Parameters": [{"Name": "oLogger", "Type": "Object", "Description": "The logger obtained from getLogger(..)"}, {"Name": "logLevel", "Type": "String", "Description": "The log level. defaults to debug."}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Log.setLevelByName()", "Signature": "void setLevelByName(String loggerNamePattern, String logLevel)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Change the level.", "Parameters": [{"Name": "loggerNamePattern", "Type": "String", "Description": "The name pattern to use to find the logger(s). Use * for all loggers"}, {"Name": "logLevel", "Type": "String", "Description": "The log level. defaults to debug."}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Log.log()", "Signature": "void log(Object logger, String logLevel, String message, Object... arguments)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Logs a message.", "Parameters": [{"Name": "logger", "Type": "Object", "Description": "The logger obtained from getLogger(..)"}, {"Name": "level", "Type": "String", "Description": "The log level. Defaults to \"debug\"."}, {"Name": "message", "Type": "String", "Description": "The message to log, with optional argument placeholders."}, {"Name": "arguments", "Type": "Object...", "Description": "The argument values to be substituted in the message."}], "Returns": [{"Type": "void"}], "Cautions": "none", "Example": "Object logger = Log.getLogger(\"Rules.VerifyCreditRF\");\nLog.log(logger, \"info\", \"Logged this message with argument %s\", myArgument);"},{"Function": "Log.getLevel()", "Signature": "String getLevel(Object oLogger)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Get the log level.", "Parameters": [{"Name": "oLogger", "Type": "Object", "Description": "The logger obtained from getLogger(..)"}], "Returns": [{"Type": "String"}], "Cautions": "none"},{"Function": "Log.getLogger()", "Signature": "Object getLogger(String loggerName)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Get a logger to be used inside a rule/rulefunction name.", "Parameters": [{"Name": "loggerName", "Type": "String", "Description": "Name of the Logger to get. Use the project path of the current rule or rulefunction."}], "Returns": [{"Type": "Object"}], "Cautions": "none", "Example": "Object logger = Log.getLogger(\"Rules.VerifyCreditRF\");"},{"Function": "Log.getName()", "Signature": "String getName(Object oLogger)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Get the name of logger.", "Parameters": [{"Name": "oLogger", "Type": "Object", "Description": "The logger obtained from getLogger(..)"}], "Returns": [{"Type": "String"}], "Cautions": "none"},{"Function": "Binary.Base64.decode()", "Signature": "Object decode(String base64String)", "Domain": "ACTION", "Description": "Decodes a base64 encoded string into a byte array.", "Parameters": [{"Name": "base64String", "Type": "String", "Description": "A base64 encoded string."}], "Returns": [{"Type": "Object", "Description": "Returns a byte array."}], "Cautions": "none"},{"Function": "Binary.Base64.encode()", "Signature": "String encode(Object bytes)", "Domain": "ACTION", "Description": "Encodes a byte array into Base64 notation.", "Parameters": [{"Name": "bytes", "Type": "Object", "Description": "A byte array."}], "Returns": [{"Type": "String", "Description": "Returns a base64 encoded string."}], "Cautions": "none"},{"Function": "String.toUpperCase()", "Signature": "String toUpperCase (String s1)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Converts all of the characters in the String passed to upper case\nusing the rules of the default locale.", "Parameters": [{"Name": "s1", "Type": "String", "Description": "A String to convert to upper case."}], "Returns": [{"Type": "String", "Description": "A String identical to the String passed in except that all\nchars have been converted to upper case."}], "Cautions": "none"},{"Function": "String.contains()", "Signature": "boolean contains (String s1, String s2)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "s1", "Parameters": [{"Name": "s1", "Type": "String", "Description": "A String to test."}, {"Name": "s2", "Type": "String", "Description": "s1"}], "Returns": [{"Type": "boolean", "Description": "s1"}], "Cautions": "none"},{"Function": "String.format()", "Signature": "String format(String message, Object... arguments)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns the message string formatted with arguments. Arguments are substituted in the order\nthe patterns are found.", "Parameters": [{"Name": "message", "Type": "String", "Description": "The String that contains the pattern(s) specified by %s."}, {"Name": "arguments", "Type": "Object[]", "Description": "The argument values to substitute.."}], "Returns": [{"Type": "String", "Description": "with parameters substituted."}], "Cautions": "none"},{"Function": "String.lastIndexOfString()", "Signature": "int lastIndexOfString (String s1, int fromIndex, String s2)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "s2", "Parameters": [{"Name": "s1", "Type": "String", "Description": "A String to search."}, {"Name": "fromIndex", "Type": "int", "Description": "s1"}, {"Name": "s2", "Type": "String", "Description": "s1"}], "Returns": [{"Type": "int", "Description": "s1"}], "Cautions": "none", "Example": "int  result = String.lastIndexOfString(\"This is a test. This is a test.\", 3, \"is \");\nResult is: 21"},{"Function": "String.indexOfString()", "Signature": "int indexOfString (String s1, int fromIndex, String s2)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "s2", "Parameters": [{"Name": "s1", "Type": "String", "Description": "A String to search."}, {"Name": "fromIndex", "Type": "int", "Description": "s1"}, {"Name": "s2", "Type": "String", "Description": "s1"}], "Returns": [{"Type": "int", "Description": "s2"}], "Cautions": "none", "Example": "int  result = String.indexOfString(\"This is a test. This is a test.\", 3, \"is \");\nResult is: 5"},{"Function": "String.compareTo()", "Signature": "int compareTo (String s1, String s2)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "s1", "Parameters": [{"Name": "s1", "Type": "String", "Description": "A String to compare."}, {"Name": "s2", "Type": "String", "Description": "A second String to compare."}], "Returns": [{"Type": "int", "Description": "A negative integer, zero, or a positive integer as s1 is\ngreater than, equal to, or less than s2."}], "Cautions": "none"},{"Function": "String.substringBefore()", "Signature": "String substringBefore (String s1, String s2)", "Domain": "ACTION, CONDITION, QUERY", "Description": "s1", "Parameters": [{"Name": "s1", "Type": "String", "Description": "A String to test."}, {"Name": "s2", "Type": "String", "Description": "s1"}], "Returns": [{"Type": "String", "Description": "The result String."}], "Cautions": "none"},{"Function": "String.regionMatches()", "Signature": "boolean regionMatches (boolean ignoreCase, String s1, int offset1, String s2, int offset2, int length)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Tests if two identified string regions are equal.", "Parameters": [{"Name": "ignoreCase", "Type": "boolean", "Description": "if true, ignore case when comparing characters."}, {"Name": "s1", "Type": "String", "Description": "A String to test for region matches."}, {"Name": "offset1", "Type": "int", "Description": "s1"}, {"Name": "s2", "Type": "String", "Description": "Second String to test for region matches."}, {"Name": "offset2", "Type": "int", "Description": "s2"}, {"Name": "length", "Type": "int", "Description": "The number of characters to compare."}], "Returns": [{"Type": "boolean", "Description": "true if the specified subregion of string s1 matches\nthe specified subregion of the string s2; false otherwise. Whether\nthe matching is exact or case insensitive depends on the ignoreCase\nargument."}], "Cautions": "none", "See Also": "java.lang.String#regionMatches"},{"Function": "String.endsWith()", "Signature": "boolean endsWith (String s1, String suffix)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "s1", "Parameters": [{"Name": "s1", "Type": "String", "Description": "A String to test for the presence of the suffix."}, {"Name": "suffix", "Type": "String", "Description": "s1"}], "Returns": [{"Type": "boolean", "Description": "s1"}], "Cautions": "none"},{"Function": "String.matches()", "Signature": "boolean matches (String s1, String regex)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Tells whether or not this string matches the given regular expression.\nTo see a description of the regular expression syntax see the\njava.util.regex.Pattern documentation.", "Parameters": [{"Name": "s1", "Type": "String", "Description": "A String to search."}, {"Name": "regex", "Type": "String", "Description": "s1"}], "Returns": [{"Type": "boolean", "Description": "s1"}], "Cautions": "none", "See Also": "java.util.regex.Pattern"},{"Function": "String.split()", "Signature": "String[] split(String str, String regex)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Splits this string around matches of the given regular expression.\nTrailing empty strings are not included in the resulting array.", "Parameters": [{"Name": "str", "Type": "String", "Description": "A String to be splitted."}, {"Name": "regex", "Type": "String", "Description": "the delimiting regular expression."}], "Returns": [{"Type": "String[]", "Description": "the array of strings computed by splitting this string around matches of the given regular expression."}]},{"Function": "String.tokenize()", "Signature": "String[] tokenize(String str, String delimiter)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Breaks an input string into tokens, returning a string tokens in a String[].\nThe whole delimiters input string is not a single $1delimiter$1.", "Parameters": [{"Name": "str", "Type": "String", "Description": "A String to be tokenized."}, {"Name": "delimiters", "Type": "String", "Description": "The default is $1 $1$1$1$1t$1$1$1$1n$1$1$1$1r$1$1$1$1f$1 if null is passed."}], "Returns": [{"Type": "String[]", "Description": "All tokens in a String[]."}], "Cautions": "The whole delimiters input string is not a single $1delimiter$1"},{"Function": "String.right()", "Signature": "String right (String s1, int length)", "Domain": "ACTION, CONDITION, QUERY", "Description": "length", "Parameters": [{"Name": "s1", "Type": "String", "Description": "A String to test."}, {"Name": "length", "Type": "int", "Description": "The length of the String."}], "Returns": [{"Type": "String", "Description": "The result String."}], "Cautions": "none"},{"Function": "String.hashCode()", "Signature": "int hashCode (String s1)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns a hash code for the passed String.", "Parameters": [{"Name": "s1", "Type": "String", "Description": "A String to compute a hashcode for."}], "Returns": [{"Type": "int", "Description": "A hash code for the passed String."}], "Cautions": "none"},{"Function": "String.getBytes()", "Signature": "Object getBytes(String s1, String charsetName)", "Domain": "ACTION", "Parameters": [{"Name": "s1", "Type": "String", "Description": "The input string"}, {"Name": "charsetName", "Type": "String", "Description": "The charset name to use"}], "Returns": [{"Type": "Object", "Description": "The resulting byte[]"}]},{"Function": "String.toLowerCase()", "Signature": "String toLowerCase (String s1)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Converts all of the characters in the String passed to lower case\nusing the rules of the default locale.", "Parameters": [{"Name": "s1", "Type": "String", "Description": "A String to convert to lower case."}], "Returns": [{"Type": "String", "Description": "A String identical to the String passed in except that all\nchars have been converted to lower case."}], "Cautions": "none"},{"Function": "String.split2()", "Signature": "String[] split2(String str, String regex, int limit)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Splits this string around matches of the given regular expression.\nThe limit parameter controls the number of times the pattern is applied and therefore\naffects the length of the resulting array.", "Parameters": [{"Name": "str", "Type": "String", "Description": "A String to be splitted."}, {"Name": "regex", "Type": "String", "Description": "Delimiting regular expression."}, {"Name": "limit", "Type": "int", "Description": "Maximum length of the result array."}], "Returns": [{"Type": "String[]", "Description": "the array of strings computed by splitting this string around matches of the given regular expression."}]},{"Function": "String.append()", "Signature": "Object append(Object stringBuffer, String stringToAppend)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Appends the specified string to the character sequence.\nThe characters of the String argument are appended, in order, increasing the length of this sequence by the length of the argument.\nIf the string argument is\n, then the four characters\nare appended.\nLet n be the length of the character sequence prior to execution of the append method.Then the character at the index k in the new character sequence is equal to the character at the index k in the old character sequence, if k is less than n. If k is greater than n then the character at index k is equal to the character at index k-n in the argument string.", "Parameters": [{"Name": "stringBuffer", "Type": "Object", "Description": "The buffer created using"}, {"Name": "stringToAppend", "Type": "String", "Description": "The string to append."}], "Returns": [{"Type": "Object"}], "Cautions": "Buffer parameter should not be null.", "See Also": "Object createBuffer(int size)"},{"Function": "String.replaceFirst()", "Signature": "String replaceFirst (String s1, String regex, String replacement)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Replaces the first substring of this string that matches the\ngiven regular expression with the given replacement.", "Parameters": [{"Name": "s1", "Type": "String", "Description": "A String to replace characters in."}, {"Name": "regex", "Type": "String", "Description": "s1"}, {"Name": "replacement", "Type": "String", "Description": "with."}], "Returns": [{"Type": "String", "Description": "s1"}], "Cautions": "none", "See Also": "java.util.regex.Pattern"},{"Function": "String.length()", "Signature": "int length (String s1)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns the length (number of characters) of the String passed in.", "Parameters": [{"Name": "s1", "Type": "String", "Description": "A String to find the length of."}], "Returns": [{"Type": "int", "Description": "The length of the String passed in."}], "Cautions": "none"},{"Function": "String.replace()", "Signature": "String replace (String s1, char oldChar, char newChar)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Returns a new string resulting from replacing all occurrences of oldChar\nin this string with newChar.  If the character oldChar does not occur\nin the character sequence represented by this String object, then a\nreference to this String object is returned. Otherwise, a new String\nobject is created that represents a character sequence identical to the\ncharacter sequence represented by this String object, except that every\noccurrence of oldChar is replaced by an occurrence of newChar.", "Parameters": [{"Name": "s1", "Type": "String", "Description": "A String to replace characters in."}, {"Name": "oldChar", "Type": "char", "Description": "s1"}, {"Name": "newChar", "Type": "char", "Description": "s1"}], "Returns": [{"Type": "String", "Description": "s1"}], "Cautions": "none"},{"Function": "String.padFront()", "Signature": "String padFront(String s1, int length, String padCharacter)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Returns a string front-padded to the indicated length with the pad character.", "Parameters": [{"Name": "s1", "Type": "String", "Description": "A String to pad."}, {"Name": "length", "Type": "int", "Description": "Length of string."}, {"Name": "padCharacter", "Type": "String", "Description": "Pad character."}], "Returns": [{"Type": "String", "Description": "The front-padded result String."}], "Cautions": "none"},{"Function": "String.trim()", "Signature": "String trim(String str)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns a copy of the string, with leading and trailing whitespace omitted.", "Parameters": [{"Name": "str", "Type": "String", "Description": "A String to be trimmed."}], "Returns": [{"Type": "String", "Description": "a copy of the string, with leading and trailing whitespace omitted."}]},{"Function": "String.valueOfFloat()", "Signature": "String valueOfFloat (float f)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Returns a String representation of the float passed in.", "Parameters": [{"Name": "f", "Type": "float", "Description": "A float to get the value of (convert to String)."}], "Returns": [{"Type": "String", "Description": "A String representation of the float passed in."}], "Cautions": "none"},{"Function": "String.replaceAll()", "Signature": "String replaceAll (String s1, String regex, String replacement)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Replaces each substring of this string that matches the given\nregular expression with the given replacement.", "Parameters": [{"Name": "s1", "Type": "String", "Description": "A String to replace characters in."}, {"Name": "regex", "Type": "String", "Description": "s1"}, {"Name": "replacement", "Type": "String", "Description": "A String to replace regular expression matches with."}], "Returns": [{"Type": "String", "Description": "s1"}], "Cautions": "none", "See Also": "java.util.regex.Pattern"},{"Function": "String.convertByteArrayToString()", "Signature": "String convertByteArrayToString(Object bytesObject, String encoding)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Parameters": [{"Name": "bytesObject", "Type": "Object", "Description": "The input byte[]"}, {"Name": "encoding", "Type": "String", "Description": "The character set to use"}], "Returns": [{"Type": "String", "Description": "The resulting string"}]},{"Function": "String.compareToIgnoreCase()", "Signature": "int compareToIgnoreCase (String s1, String s2)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Compares two strings lexicographically, ignoring case differences.\nThis method returns an integer whose sign is that of calling compareTo\nwith normalized versions of the strings where case differences have been\neliminated by lowercasing each character.\nNote that this method does not take locale into account, and will result\nin an unsatisfactory ordering for certain locales.", "Parameters": [{"Name": "s1", "Type": "String", "Description": "A String to compare."}, {"Name": "s2", "Type": "String", "Description": "A second String to compare."}], "Returns": [{"Type": "int", "Description": "a negative integer, zero, or a positive integer as s1 is\ngreater than, equal to, or less than s2 ignoring case considerations."}], "Cautions": "none"},{"Function": "String.left()", "Signature": "String left (String s1, int length)", "Domain": "ACTION, CONDITION, QUERY", "Description": "length", "Parameters": [{"Name": "s1", "Type": "String", "Description": "A String to test."}, {"Name": "length", "Type": "int", "Description": "The length of the String."}], "Returns": [{"Type": "String", "Description": "The result String."}], "Cautions": "none"},{"Function": "String.valueOfInt()", "Signature": "String valueOfInt (int i)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns a String representation of the int passed in.", "Parameters": [{"Name": "i", "Type": "int", "Description": "An int to get the value of (convert to String)."}], "Returns": [{"Type": "String", "Description": "A String representation of the int passed in."}], "Cautions": "none"},{"Function": "String.equals()", "Signature": "boolean equals (String s1, String s2)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Compares two Strings and returns a boolean indicating whether they are equal.", "Parameters": [{"Name": "s1", "Type": "String", "Description": "A String to compare."}, {"Name": "s2", "Type": "String", "Description": "A second String to compare."}], "Returns": [{"Type": "boolean", "Description": "true if the Strings are equal, otherwise returns false."}], "Cautions": "none"},{"Function": "String.valueOfBoolean()", "Signature": "String valueOfBoolean (boolean b)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns a String representation of the boolean passed in.", "Parameters": [{"Name": "b", "Type": "boolean", "Description": "A boolean to get the value of (convert to String)."}], "Returns": [{"Type": "String", "Description": "A String representation of the boolean passed in."}], "Cautions": "none"},{"Function": "String.createBuffer()", "Signature": "Object createBuffer(int size)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "The new buffer is created using the Java StringBuilder class.", "Parameters": [{"Name": "size", "Type": "int", "Description": "Size of buffer, this size defines the initial capacity of the buffer."}], "Returns": [{"Type": "Object"}], "Cautions": "Size should not be a negative number."},{"Function": "String.convertBufferToString()", "Signature": "String convertBufferToString(Object stringBuffer)", "Domain": "ACTION, CONDITION, BUI", "Parameters": [{"Name": "stringBuffer", "Type": "Object", "Description": "The buffer created using"}], "Returns": [{"Type": "String"}], "Cautions": "Buffer parameter should not be null.", "See Also": "Object createBuffer(int size)"},{"Function": "String.pad()", "Signature": "String pad (String s1, int length, String padCharacter)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Returns a string padded to the indicated length with the pad character.", "Parameters": [{"Name": "s1", "Type": "String", "Description": "A String to pad."}, {"Name": "length", "Type": "int", "Description": "Length of string."}, {"Name": "padCharacter", "Type": "String", "Description": "Pad character."}], "Returns": [{"Type": "String", "Description": "The padded result String."}], "Cautions": "none"},{"Function": "String.startsWith()", "Signature": "boolean startsWith (String s1, String prefix)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "s1", "Parameters": [{"Name": "s1", "Type": "String", "Description": "A String to test for the presence of the prefix."}, {"Name": "prefix", "Type": "String", "Description": "s1"}], "Returns": [{"Type": "boolean", "Description": "s1"}], "Cautions": "none"},{"Function": "String.concat()", "Signature": "String concat (String s1, String s2)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Concatenates the two argument strings and returns the resulting String.", "Parameters": [{"Name": "s1", "Type": "String", "Description": "A String to concatenate."}, {"Name": "s2", "Type": "String", "Description": "A second String to concatenate."}], "Returns": [{"Type": "String", "Description": "The result of concatenating the two argument strings."}], "Cautions": "none"},{"Function": "String.substring()", "Signature": "String substring (String s1, int beginIndex, int endIndex)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "endIndex - 1", "Parameters": [{"Name": "s1", "Type": "String", "Description": "A String to use as a source of the substring."}, {"Name": "beginIndex", "Type": "int", "Description": "The String index where the substring should start, inclusive."}, {"Name": "endIndex", "Type": "int", "Description": "The String index where the substring should end, exclusive."}], "Returns": [{"Type": "String", "Description": "beginIndex"}], "Cautions": "none", "Example": "int  result = String.substring(\"This is a test. This is a test.\", 5, 9);\nResult is: \"is a\""},{"Function": "String.valueOfDouble()", "Signature": "String valueOfDouble (double d)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns a String representation of the double passed in.", "Parameters": [{"Name": "d", "Type": "double", "Description": "A double to get the value of (convert to String)."}], "Returns": [{"Type": "String", "Description": "A String representation of the double passed in."}], "Cautions": "none"},{"Function": "String.substringAfter()", "Signature": "String substringAfter (String s1, String s2)", "Domain": "ACTION, CONDITION, QUERY", "Description": "s1", "Parameters": [{"Name": "s1", "Type": "String", "Description": "A String to test."}, {"Name": "s2", "Type": "String", "Description": "s1"}], "Returns": [{"Type": "String", "Description": "The result String."}], "Cautions": "none", "Example": "int  result = String.substringAfter(\"This is a test. This is a test.\", \"is \");\nResult is: \"is a test. This is a test.\""},{"Function": "String.valueOfLong()", "Signature": "String valueOfLong (long l)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns a String representation of the long passed in.", "Parameters": [{"Name": "l", "Type": "long", "Description": "A long to get the value of (convert to String)."}], "Returns": [{"Type": "String", "Description": "A String representation of the long passed in."}], "Cautions": "none"},{"Function": "String.clearBuffer()", "Signature": "void clearBuffer(Object stringBuffer)", "Domain": "ACTION, CONDITION, BUI", "Description": "The method clearBuffer uses the Java StringBuilder delete method.", "Parameters": "None.", "Returns": [{"Type": "void"}], "Cautions": "Buffer parameter should not be null.", "See Also": "Object clearBuffer(Object stringBuffer)"},{"Function": "Collections.contains()", "Signature": "boolean contains ( Object collection, Object element )", "Domain": "ACTION", "Description": "Returns true if this collection contains the specified element.", "Parameters": [{"Name": "collection", "Type": "Object", "Description": "The Collection object"}, {"Name": "element", "Type": "Object", "Description": "Element whose presence in this collection is to be tested"}], "Returns": [{"Type": "boolean", "Description": "true, If this collection contains the specified element"}], "Cautions": "none"},{"Function": "Collections.size()", "Signature": "int size ( Object collection )", "Domain": "ACTION", "Description": "Returns the number of elements in this collection.", "Parameters": [{"Name": "collection", "Type": "Object", "Description": "The Collection object"}], "Returns": [{"Type": "int", "Description": "The number of elements in this collection"}], "Cautions": "none"},{"Function": "Collections.containsAll()", "Signature": "boolean containsAll ( Object collection, Object collection2 )", "Domain": "ACTION", "Description": "Returns true if this collection contains all of the elements of the specified collection.", "Parameters": [{"Name": "collection", "Type": "Object", "Description": "The Collection object"}, {"Name": "collection2", "Type": "Object", "Description": "Collection to be checked for containment in this collection"}], "Returns": [{"Type": "boolean", "Description": "true, If this collection contains all of the elements of the specified collection"}], "Cautions": "none"},{"Function": "Collections.toArray()", "Signature": "Object[] toArray ( Object collection, Object ... a )", "Domain": "ACTION", "Description": "Returns an array containing all of the elements in this collection in proper \n sequence (from first to last element)", "Parameters": [{"Name": "collection", "Type": "Object", "Description": "The Collection object"}, {"Name": "a", "Type": "Object", "Description": "The runtime type of the returned array"}], "Returns": [{"Type": "Object[]", "Description": "An array containing all of the elements in this collection in proper sequence. If specified, the runtime type of the returned array is that of the specified array"}], "Cautions": "none"},{"Function": "Collections.add()", "Signature": "void add ( Object collection, Object element)", "Domain": "ACTION", "Description": "Inserts the specified element at the specified position in this collection.", "Parameters": [{"Name": "collection", "Type": "Object", "Description": "The Collection object"}, {"Name": "element", "Type": "Object", "Description": "Element to be inserted"}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Collections.retainAll()", "Signature": "boolean retainAll ( Object collection, Object collection2 )", "Domain": "ACTION", "Description": "Retains only the elements in this collection that are contained in the specified collection.", "Parameters": [{"Name": "collection", "Type": "Object", "Description": "The Collection object"}, {"Name": "collection2", "Type": "Object", "Description": "Collection containing elements to be retained in this collection"}], "Returns": [{"Type": "boolean", "Description": "true, If this collection changed as a result of the call"}], "Cautions": "none"},{"Function": "Collections.remove()", "Signature": "boolean remove ( Object collection, Object element )", "Domain": "ACTION", "Description": "Removes the first occurrence of the specified element from this collection, if it is present..", "Parameters": [{"Name": "collection", "Type": "Object", "Description": "The Collection Object"}, {"Name": "element", "Type": "Object", "Description": "Element to be removed from this collection, if present"}], "Returns": [{"Type": "boolean", "Description": "true, If this collection contained the specified element"}], "Cautions": "none"},{"Function": "Collections.iterator()", "Signature": "Object iterator ( Object collection )", "Domain": "ACTION", "Description": "Returns an iterator over the elements in this collection in proper sequence.", "Parameters": [{"Name": "collection", "Type": "Object", "Description": "The Collection object"}], "Returns": [{"Type": "Object", "Description": "An iterator over the elements in this collection in proper sequence"}], "Cautions": "none"},{"Function": "Collections.removeAll()", "Signature": "boolean removeAll ( Object collection, Object collection2 )", "Domain": "ACTION", "Description": "Removes from this collection all of its elements that are contained in the specified collection.", "Parameters": [{"Name": "collection", "Type": "Object", "Description": "The Collection object"}, {"Name": "collection2", "Type": "Object", "Description": "Collection containing elements to be removed from this collection"}], "Returns": [{"Type": "boolean", "Description": "true, If this collection changed as a result of the call"}], "Cautions": "none"},{"Function": "Collections.clear()", "Signature": "void clear ( Object collection )", "Domain": "ACTION", "Description": "Removes all of the elements from this collection.", "Parameters": [{"Name": "collection", "Type": "Object", "Description": "The Collection object"}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Collections.addAll()", "Signature": "boolean addAll ( Object collection, Object collection2 )", "Domain": "ACTION", "Description": "Inserts all of the elements in the specified collection into this collection at the specified position.", "Parameters": [{"Name": "collection", "Type": "Object", "Description": "The Collection object"}, {"Name": "collection2", "Type": "Object", "Description": "Collection containing elements to be added to this collection"}], "Returns": [{"Type": "boolean", "Description": "true, If this collection changed as a result of the call"}], "Cautions": "none"},{"Function": "Collections.Comparator.compare()", "Signature": "int compare ( Object comparator, Object o1, Object o2   )", "Domain": "ACTION", "Description": "Compares its two arguments for order.", "Parameters": [{"Name": "comparator", "Type": "Object", "Description": "The Comparator object."}, {"Name": "o1", "Type": "Object", "Description": "The first object to be compared."}, {"Name": "o2", "Type": "Object", "Description": "The second object to be compared."}], "Returns": [{"Type": "int", "Description": "A negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second."}], "Cautions": "none"},{"Function": "Collections.Comparator.createComparator()", "Signature": "Object createSet ( String className   )", "Domain": "ACTION", "Description": "Creates instance of user specified Comparator implementation.", "Parameters": [{"Name": "className", "Type": "String", "Description": "Specify the className that implements the Comparator interface"}], "Returns": [{"Type": "Object", "Description": "Instance of user specified Comparator implementation"}], "Cautions": "none"},{"Function": "Collections.SortedMap.headMap()", "Signature": "Object headMap ( Object map, Object toKey   )", "Domain": "ACTION", "Description": "Returns a view of the portion of this map whose keys are strictly less than toKey.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "Instance of SortedMap"}, {"Name": "toKey", "Type": "Object", "Description": "High endpoint (exclusive) of the keys in the returned map"}], "Returns": [{"Type": "Object", "Description": "Instance of Map, a view of the portion of this map whose keys are strictly\nless than toKey."}], "Cautions": "none"},{"Function": "Collections.SortedMap.tailMap()", "Signature": "Object tailMap ( Object map, Object fromKey   )", "Domain": "ACTION", "Description": "Returns a view of the portion of this map whose keys are greater than or equal to fromKey.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "Instance of SortedMap"}, {"Name": "fromKey", "Type": "Object", "Description": "Low endpoint (inclusive) of the keys in the returned map"}], "Returns": [{"Type": "Object", "Description": "Instance of SortedSet, a view of the portion of this map whose keys are greater\nthan or equal to fromKey"}], "Cautions": "none"},{"Function": "Collections.SortedMap.lastKey()", "Signature": "Object lastKey (Object map  )", "Domain": "ACTION", "Description": "Returns the last (highest) key currently in this map.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "Instance of SortedMap"}], "Returns": [{"Type": "Object", "Description": "The last (highest) key currently in this map."}], "Cautions": "none"},{"Function": "Collections.SortedMap.subMap()", "Signature": "Object subMap ( Object map, Object fromKey  ,Object toKey   )", "Domain": "ACTION", "Description": "Returns a view of the portion of this map whose keys range from fromKey, inclusive, to toKey, exclusive. (If fromKey and toKey are equal, the returned map is empty.)", "Parameters": [{"Name": "map", "Type": "Object", "Description": "Instance of SortedMap"}, {"Name": "fromKey", "Type": "Object", "Description": "Low endpoint (inclusive) of the keys in the returned map"}, {"Name": "toKey", "Type": "Object", "Description": "High endpoint (exclusive) of the keys in the returned map"}], "Returns": [{"Type": "Object", "Description": "Instance of SortedSet, a view of the portion of this map whose keys range from\nfromKey, inclusive, to toKey, exclusive"}], "Cautions": "none"},{"Function": "Collections.SortedMap.firstKey()", "Signature": "Object firstKey ( Object map )", "Domain": "ACTION", "Description": "Returns the first (lowest) key currently in this map.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "Instance of SortedMap"}], "Returns": [{"Type": "Object", "Description": "The first (lowest) key currently in this map"}], "Cautions": "none"},{"Function": "Collections.SortedMap.comparator()", "Signature": "Object comparator ( Object map )", "Domain": "ACTION", "Description": "Returns the comparator used to order the keys in this map, or null if this map uses the Comparable natural ordering of its keys.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "Instance of SortedMap"}], "Returns": [{"Type": "Object"}], "Cautions": "none"},{"Function": "Collections.SortedSet.last()", "Signature": "Object last ( Object set )", "Domain": "ACTION", "Description": "Returns the last (highest) element currently in this set.", "Parameters": [{"Name": "set", "Type": "Object", "Description": "Instance of SortedSet"}], "Returns": [{"Type": "Object", "Description": "The last (highest) element currently in this set."}], "Cautions": "none"},{"Function": "Collections.SortedSet.subSet()", "Signature": "Object subSet ( Object set, Object fromElement  ,Object toElement   )", "Domain": "ACTION", "Description": "Returns a view of the portion of this set whose elements range from fromElement, inclusive, to toElement, exclusive. (If fromElement and toElement are equal, the returned set is empty.)", "Parameters": [{"Name": "set", "Type": "Object", "Description": "Instance of SortedSet"}, {"Name": "fromElement", "Type": "Object", "Description": "Low endpoint (inclusive) of the returned set"}, {"Name": "toElement", "Type": "Object", "Description": "High endpoint (exclusive) of the returned set"}], "Returns": [{"Type": "Object", "Description": "A view of the portion of this set whose elements range from\nfromElement, inclusive, to toElement, exclusive"}], "Cautions": "none"},{"Function": "Collections.SortedSet.tailSet()", "Signature": "Object tailSet ( Object set, Object fromElement   )", "Domain": "ACTION", "Description": "Returns a view of the portion of this set whose elements are greater than or equal to fromElement.", "Parameters": [{"Name": "set", "Type": "Object", "Description": "Instance of SortedSet"}, {"Name": "fromElement", "Type": "Object", "Description": "Low endpoint (inclusive) of the returned set"}], "Returns": [{"Type": "Object", "Description": "A view of the portion of this set whose elements are greater\nthan or equal to fromElement"}], "Cautions": "none"},{"Function": "Collections.SortedSet.headSet()", "Signature": "Object headSet ( Object set, Object toElement   )", "Domain": "ACTION", "Description": "Returns a view of the portion of this set whose elements are strictly less than toElement.", "Parameters": [{"Name": "set", "Type": "Object", "Description": "Instance of SortedSet"}, {"Name": "toElement", "Type": "Object", "Description": "High endpoint (exclusive) of the returned set"}], "Returns": [{"Type": "Object", "Description": "A view of the portion of this set whose elements are strictly\nless than toElement"}], "Cautions": "none"},{"Function": "Collections.SortedSet.comparator()", "Signature": "Object comparator ( Object set )", "Domain": "ACTION", "Parameters": [{"Name": "set", "Type": "Object", "Description": "Instance of SortedSet"}], "Returns": [{"Type": "Object"}], "Cautions": "none"},{"Function": "Collections.SortedSet.first()", "Signature": "Object first (Object set  )", "Domain": "ACTION", "Description": "Returns the first (lowest) element currently in this set.", "Parameters": [{"Name": "set", "Type": "Object", "Description": "Instance of SortedSet"}], "Returns": [{"Type": "Object", "Description": "The first (lowest) element currently in this set"}], "Cautions": "none"},{"Function": "Collections.Iterator.remove()", "Signature": "void remove (Object iterator)", "Domain": "ACTION", "Description": "Removes from the underlying collection the last element returned by the iterator.", "Parameters": [{"Name": "iterator", "Type": "Object", "Description": "The iterator object"}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Collections.Iterator.hasNext()", "Signature": "boolean hasNext (Object iterator)", "Domain": "ACTION", "Description": "Returns true, if the iteration has more elements.", "Parameters": [{"Name": "iterator", "Type": "Object", "Description": "The iterator object"}], "Returns": [{"Type": "boolean", "Description": "Returns true if the iterator has more elements"}], "Cautions": "none"},{"Function": "Collections.Iterator.next()", "Signature": "Object next (Object iterator)", "Domain": "ACTION", "Description": "Returns the next element in the iteration", "Parameters": [{"Name": "iterator", "Type": "Object", "Description": "The iterator object"}], "Returns": [{"Type": "Object", "Description": "Returns the next element in the iteration"}], "Cautions": "none"},{"Function": "Collections.Map.keySet()", "Signature": "Object keySet ( Object map )", "Domain": "ACTION", "Description": "Returns a view of the keys contained in this map.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The Map object"}], "Returns": [{"Type": "Object", "Description": "A set view of the keys contained in this map"}], "Cautions": "none"},{"Function": "Collections.Map.size()", "Signature": "int size ( Object map )", "Domain": "ACTION", "Description": "the number of key-value mappings in this map.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The map object"}], "Returns": [{"Type": "int", "Description": "The number of key-value mappings in this map"}], "Cautions": "none"},{"Function": "Collections.Map.putAll()", "Signature": "void putAll ( Object map, Object mapToBeAdded )", "Domain": "ACTION", "Description": "Copies all of the mappings from the specified map to this map.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The Map object"}, {"Name": "mapToBeAdded", "Type": "Object", "Description": "Mappings to be stored in this map"}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Collections.Map.entrySet()", "Signature": "Object entrySet ( Object map )", "Domain": "ACTION", "Description": "Returns a view of the mappings contained in this map.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The Map object"}], "Returns": [{"Type": "Object", "Description": "A set view of the mappings contained in this map"}], "Cautions": "none"},{"Function": "Collections.Map.values()", "Signature": "Object values ( Object map )", "Domain": "ACTION", "Description": "Returns a  view of the values contained in this map.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The Map object"}], "Returns": [{"Type": "Object", "Description": "A collection view of the values contained in this map"}], "Cautions": "none"},{"Function": "Collections.Map.createHashMapWithId()", "Signature": "Object createHashMapWithId ( String mapId )", "Domain": "ACTION", "Description": "Create and return instance of HashMap for the given mapID. If the map already exists, return the existing Map.", "Parameters": [{"Name": "mapId", "Type": "String", "Description": "The String ID of the map to create"}], "Returns": [{"Type": "Object", "Description": "Instance of HashMap"}], "Cautions": "none"},{"Function": "Collections.Map.isEmpty()", "Signature": "boolean isEmpty ( Object map )", "Domain": "ACTION", "Description": "Returns true, if this map contains no key-value mappings", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The Map object"}], "Returns": [{"Type": "boolean", "Description": "true, If this map contains no key-value mappings"}], "Cautions": "none"},{"Function": "Collections.Map.containsValue()", "Signature": "boolean containsValue ( Object map, Object value )", "Domain": "ACTION", "Description": "Returns true, if this map maps one or more keys to the specified value.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The Map object"}, {"Name": "value", "Type": "Object", "Description": "value whose presence in this map is to be tested"}], "Returns": [{"Type": "boolean", "Description": "true, If this map maps one or more keys to the specified value"}], "Cautions": "none"},{"Function": "Collections.Map.createHashMap()", "Signature": "Object createHashMap ( )", "Domain": "ACTION", "Description": "Create and return instance of HashMap.\nThe hashmap returned by this function is not thread safe hence any updates if using a multi-threaded RETE should be done carefully.", "Parameters": "None.", "Returns": [{"Type": "Object", "Description": "Instance of HashMap"}], "Cautions": "none"},{"Function": "Collections.Map.remove()", "Signature": "Object remove ( Object map, Object key )", "Domain": "ACTION", "Description": "Removes the mapping for a key from this map if it is present.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The map object"}, {"Name": "key", "Type": "Object", "Description": "Key whose mapping is to be removed from the map"}], "Returns": [{"Type": "Object", "Description": "The previous value associated with key, or \n null if there was no mapping for key."}], "Cautions": "none"},{"Function": "Collections.Map.createTreeMapWithId()", "Signature": "Object createTreeMapWithId ( String mapId )", "Domain": "ACTION", "Description": "Create and return instance of TreeMap for the given mapID. If the map already exists, return the existing Map.", "Parameters": [{"Name": "mapId", "Type": "String", "Description": "The String ID of the map to create"}], "Returns": [{"Type": "Object", "Description": "Instance of TreeMap"}], "Cautions": "none"},{"Function": "Collections.Map.deleteMap()", "Signature": "Object deleteMap ( String mapId )", "Domain": "ACTION", "Description": "Deletes the instance of Map  for the given mapId.\nThis function can not be used if the collection is created with createMap().", "Parameters": [{"Name": "mapId", "Type": "String", "Description": "The String ID of the map to delete"}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Collections.Map.createTreeMap()", "Signature": "Object createTreeMap ( )", "Domain": "ACTION", "Description": "Create and return instance of TreeMap.", "Parameters": "None.", "Returns": [{"Type": "Object", "Description": "Instance of TreeMap"}], "Cautions": "none"},{"Function": "Collections.Map.getMap()", "Signature": "Object getMap ( String mapId )", "Domain": "ACTION", "Description": "Returns the instance of Map  for the given mapId.", "Parameters": [{"Name": "mapId", "Type": "String", "Description": "The String ID of the map"}], "Returns": [{"Type": "Object", "Description": "Returns the instance of Map for the given mapId"}], "Cautions": "none"},{"Function": "Collections.Map.createLinkedHashMap()", "Signature": "Object createLinkedHashMap ( )", "Domain": "ACTION", "Description": "Create and return instance of LinkedHashMap.", "Parameters": "None.", "Returns": [{"Type": "Object", "Description": "Instance of LinkedHashMap"}], "Cautions": "none"},{"Function": "Collections.Map.clear()", "Signature": "void clear ( Object map )", "Domain": "ACTION", "Description": "Removes all of the mappings from this map.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The Map object"}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Collections.Map.put()", "Signature": "Object put ( Object map, Object key, Object value )", "Domain": "ACTION", "Description": "Associates the specified value with the specified key in this map.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The Map object"}, {"Name": "key", "Type": "Object", "Description": "key with which the specified value is to be associated"}, {"Name": "value", "Type": "Object", "Description": "Value to be associated with the specified key"}], "Returns": [{"Type": "Object", "Description": "The previous value associated with key, \n or null if there was no mapping for key."}], "Cautions": "none"},{"Function": "Collections.Map.containsKey()", "Signature": "boolean containsKey ( Object map, Object key )", "Domain": "ACTION", "Description": "Returns true, if this map contains a mapping for the specified.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The Map object"}, {"Name": "key", "Type": "Object", "Description": "Key whose presence in this map is to be tested"}], "Returns": [{"Type": "boolean", "Description": "true, If this map contains a mapping for the specified  key"}], "Cautions": "none"},{"Function": "Collections.Map.createMap()", "Signature": "Object createMap ( String className )", "Domain": "ACTION", "Description": "Creates user specified Map implementation", "Parameters": [{"Name": "className", "Type": "String", "Description": "Specify the className that implements the Map interface"}], "Returns": [{"Type": "Object", "Description": "Instance of user specified Map implementation"}], "Cautions": "none"},{"Function": "Collections.Map.get()", "Signature": "Object get ( Object map, Object key )", "Domain": "ACTION", "Description": "Returns the value to which the specified key is mapped.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The Map object"}, {"Name": "key", "Type": "Object", "Description": "The key whose associated value is to be returned"}], "Returns": [{"Type": "Object"}], "Cautions": "none"},{"Function": "Collections.Map.createMapWithId()", "Signature": "Object createMapWithId ( String mapId )", "Domain": "ACTION", "Description": "Create and return instance of user specified Map implementation for the given mapID. If the map already exists, return the existing Map.", "Parameters": [{"Name": "className", "Type": "String", "Description": "Specify the className that implements the Map interface"}, {"Name": "mapId", "Type": "String", "Description": "The String ID of the map to create"}], "Returns": [{"Type": "Object", "Description": "Instance of user specified Map implementation"}], "Cautions": "none"},{"Function": "Collections.Map.createLinkedHashMapWithId()", "Signature": "Object createLinkedHashMapWithId ( String mapId )", "Domain": "ACTION", "Description": "Create and return instance of LinkedHashMap for the given mapID. If the map already exists, return the existing Map.", "Parameters": [{"Name": "mapId", "Type": "String", "Description": "The String ID of the map to create"}], "Returns": [{"Type": "Object", "Description": "Instance of LinkedHashMap"}], "Cautions": "none"},{"Function": "Collections.Map.Entry.setValue()", "Signature": "Object setValue ( Object entry  ,Object value   )", "Domain": "ACTION", "Description": "Replaces the value corresponding to this entry with the specified value.", "Parameters": [{"Name": "entry", "Type": "Object", "Description": "The Entry object"}, {"Name": "value", "Type": "Object", "Description": "new value to be stored in this entry"}], "Returns": [{"Type": "Object", "Description": "old value corresponding to the entry"}], "Cautions": "none"},{"Function": "Collections.Map.Entry.getKey()", "Signature": "Object getKey ( Object entry)", "Domain": "ACTION", "Description": "Returns the key corresponding to this entry..", "Parameters": [{"Name": "entry", "Type": "Object", "Description": "The Entry object"}], "Returns": [{"Type": "Object", "Description": "the key corresponding to this entry"}], "Cautions": "none"},{"Function": "Collections.Map.Entry.getValue()", "Signature": "Object getValue ( Object entry)", "Domain": "ACTION", "Description": "Returns the value corresponding to this entry.", "Parameters": [{"Name": "entry", "Type": "Object", "Description": "The Entry object"}], "Returns": [{"Type": "Object", "Description": "the value corresponding to this entry"}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.keySet()", "Signature": "Object keySet ( Object map )", "Domain": "ACTION", "Description": "Returns a view of the keys contained in this map.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The Map object"}], "Returns": [{"Type": "Object", "Description": "A set view of the keys contained in this map"}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.size()", "Signature": "int size ( Object map )", "Domain": "ACTION", "Description": "the number of key-value mappings in this map.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The map object"}], "Returns": [{"Type": "int", "Description": "The number of key-value mappings in this map"}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.putAll()", "Signature": "void putAll ( Object map, Object mapToBeAdded )", "Domain": "ACTION", "Description": "Copies all of the mappings from the specified map to this map.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The Map object"}, {"Name": "mapToBeAdded", "Type": "Object", "Description": "Mappings to be stored in this map"}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.entrySet()", "Signature": "Object entrySet ( Object map )", "Domain": "ACTION", "Description": "Returns a view of the mappings contained in this map.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The Map object"}], "Returns": [{"Type": "Object", "Description": "A set view of the mappings contained in this map"}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.values()", "Signature": "Object values ( Object map )", "Domain": "ACTION", "Description": "Returns a  view of the values contained in this map.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The Map object"}], "Returns": [{"Type": "Object", "Description": "A collection view of the values contained in this map"}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.createHashMapWithId()", "Signature": "Object createHashMapWithId ( String mapId )", "Domain": "ACTION", "Description": "Create and return instance of ConcurrentHashMap for the given mapID. If the map already exists, return the existing Map.", "Parameters": [{"Name": "mapId", "Type": "String", "Description": "The String ID of the concurrent hash map to create"}], "Returns": [{"Type": "Object", "Description": "Instance of ConcurrentHashMap"}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.isEmpty()", "Signature": "boolean isEmpty ( Object map )", "Domain": "ACTION", "Description": "Returns true, if this map contains no key-value mappings", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The Map object"}], "Returns": [{"Type": "boolean", "Description": "true, If this map contains no key-value mappings"}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.containsValue()", "Signature": "boolean containsValue ( Object map, Object value )", "Domain": "ACTION", "Description": "Returns true, if this map maps one or more keys to the specified value.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The Map object"}, {"Name": "value", "Type": "Object", "Description": "value whose presence in this map is to be tested"}], "Returns": [{"Type": "boolean", "Description": "true, If this map maps one or more keys to the specified value"}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.createConcurrentHashMap()", "Signature": "Object createConcurrentHashMap (  )", "Domain": "ACTION", "Description": "Create and return instance of ConcurrentHashMap.", "Parameters": "None.", "Returns": [{"Type": "Object", "Description": "Instance of ConcurrentHashMap"}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.createHashMap()", "Signature": "Object createHashMap ( )", "Domain": "ACTION", "Description": "Create and return instance of HashMap.\nThe hashmap returned by this function is not thread safe hence any updates if using a multi-threaded RETE should be done carefully.", "Parameters": "None.", "Returns": [{"Type": "Object", "Description": "Instance of HashMap"}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.remove()", "Signature": "boolean remove ( Object map  ,Object key ,Object value  )", "Domain": "ACTION", "Description": "Remove entry for key only if currently mapped to given value. The action is performed atomically.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The concurrent map object"}, {"Name": "key", "Type": "Object", "Description": "key with which the specified value is to be associated."}, {"Name": "value", "Type": "Object", "Description": "value to be associated with the specified key."}], "Returns": [{"Type": "boolean", "Description": "true if the value was removed, false otherwise ."}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.createTreeMapWithId()", "Signature": "Object createTreeMapWithId ( String mapId )", "Domain": "ACTION", "Description": "Create and return instance of TreeMap for the given mapID. If the map already exists, return the existing Map.", "Parameters": [{"Name": "mapId", "Type": "String", "Description": "The String ID of the map to create"}], "Returns": [{"Type": "Object", "Description": "Instance of TreeMap"}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.replace()", "Signature": "Object replace ( Object map  ,Object key ,Object value  )", "Domain": "ACTION", "Description": "Replace entry for key only if currently mapped to some value. The action is performed atomically.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The concurrent map object"}, {"Name": "key", "Type": "Object", "Description": "key with which the specified value is to be associated."}, {"Name": "value", "Type": "Object", "Description": "value to be associated with the specified key."}], "Returns": [{"Type": "Object"}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.deleteMap()", "Signature": "Object deleteMap ( String mapId )", "Domain": "ACTION", "Description": "Deletes the instance of Map  for the given mapId.\nThis function can not be used if the collection is created with createMap().", "Parameters": [{"Name": "mapId", "Type": "String", "Description": "The String ID of the map to delete"}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.createTreeMap()", "Signature": "Object createTreeMap ( )", "Domain": "ACTION", "Description": "Create and return instance of TreeMap.", "Parameters": "None.", "Returns": [{"Type": "Object", "Description": "Instance of TreeMap"}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.getMap()", "Signature": "Object getMap ( String mapId )", "Domain": "ACTION", "Description": "Returns the instance of Map  for the given mapId.", "Parameters": [{"Name": "mapId", "Type": "String", "Description": "The String ID of the map"}], "Returns": [{"Type": "Object", "Description": "Returns the instance of Map for the given mapId"}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.createLinkedHashMap()", "Signature": "Object createLinkedHashMap ( )", "Domain": "ACTION", "Description": "Create and return instance of LinkedHashMap.", "Parameters": "None.", "Returns": [{"Type": "Object", "Description": "Instance of LinkedHashMap"}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.clear()", "Signature": "void clear ( Object map )", "Domain": "ACTION", "Description": "Removes all of the mappings from this map.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The Map object"}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.put()", "Signature": "Object put ( Object map, Object key, Object value )", "Domain": "ACTION", "Description": "Associates the specified value with the specified key in this map.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The Map object"}, {"Name": "key", "Type": "Object", "Description": "key with which the specified value is to be associated"}, {"Name": "value", "Type": "Object", "Description": "Value to be associated with the specified key"}], "Returns": [{"Type": "Object", "Description": "The previous value associated with key, \n or null if there was no mapping for key."}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.containsKey()", "Signature": "boolean containsKey ( Object map, Object key )", "Domain": "ACTION", "Description": "Returns true, if this map contains a mapping for the specified.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The Map object"}, {"Name": "key", "Type": "Object", "Description": "Key whose presence in this map is to be tested"}], "Returns": [{"Type": "boolean", "Description": "true, If this map contains a mapping for the specified  key"}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.putIfAbsent()", "Signature": "Object putIfAbsent ( Object map  ,Object key ,Object value  )", "Domain": "ACTION", "Description": "If the specified key is not already associated with a value, associate it with the given value. The action is performed atomically.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The concurrent map object"}, {"Name": "key", "Type": "Object", "Description": "key with which the specified value is to be associated."}, {"Name": "value", "Type": "Object", "Description": "value to be associated with the specified key."}], "Returns": [{"Type": "Object", "Description": "previous value associated with specified key, or null if there was no mapping for key. A null return can also indicate that the map previously associated null with the specified key, if the implementation supports null values."}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.createMap()", "Signature": "Object createMap ( String className )", "Domain": "ACTION", "Description": "Creates user specified Map implementation", "Parameters": [{"Name": "className", "Type": "String", "Description": "Specify the className that implements the Map interface"}], "Returns": [{"Type": "Object", "Description": "Instance of user specified Map implementation"}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.get()", "Signature": "Object get ( Object map, Object key )", "Domain": "ACTION", "Description": "Returns the value to which the specified key is mapped.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The Map object"}, {"Name": "key", "Type": "Object", "Description": "The key whose associated value is to be returned"}], "Returns": [{"Type": "Object"}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.createMapWithId()", "Signature": "Object createMapWithId ( String mapId )", "Domain": "ACTION", "Description": "Create and return instance of user specified Map implementation for the given mapID. If the map already exists, return the existing Map.", "Parameters": [{"Name": "className", "Type": "String", "Description": "Specify the className that implements the Map interface"}, {"Name": "mapId", "Type": "String", "Description": "The String ID of the map to create"}], "Returns": [{"Type": "Object", "Description": "Instance of user specified Map implementation"}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.replaceIfEqualToGivenValue()", "Signature": "boolean replaceIfEqualToGivenValue ( Object map  ,Object key ,Object oldValue, Object newValue  )", "Domain": "ACTION", "Description": "Replace entry for key only if currently mapped to given value. The action is performed atomically.", "Parameters": [{"Name": "map", "Type": "Object", "Description": "The concurrent map object"}, {"Name": "key", "Type": "Object", "Description": "key with which the specified value is to be associated."}, {"Name": "oldvalue", "Type": "Object", "Description": "value expected to be associated with the specified key."}, {"Name": "newValue", "Type": "Object", "Description": "value to be associated with the specified key."}], "Returns": [{"Type": "boolean", "Description": "true if the value was replaced, false otherwise ."}], "Cautions": "none"},{"Function": "Collections.Map.Concurrent.createLinkedHashMapWithId()", "Signature": "Object createLinkedHashMapWithId ( String mapId )", "Domain": "ACTION", "Description": "Create and return instance of LinkedHashMap for the given mapID. If the map already exists, return the existing Map.", "Parameters": [{"Name": "mapId", "Type": "String", "Description": "The String ID of the map to create"}], "Returns": [{"Type": "Object", "Description": "Instance of LinkedHashMap"}], "Cautions": "none"},{"Function": "Collections.List.getList()", "Signature": "Object getList ( String listId )", "Domain": "ACTION", "Description": "Returns the instance of List  for the given listID.", "Parameters": [{"Name": "listId", "Type": "String", "Description": "The String ID of the List"}], "Returns": [{"Type": "Object", "Description": "The instance of List"}], "Cautions": "none"},{"Function": "Collections.List.subList()", "Signature": "Object subList ( Object list  ,int fromIndex  ,int toIndex   )", "Domain": "ACTION", "Description": "Returns a view of the portion of this list between the specified \n fromIndex, inclusive, and toIndex , exclusive.", "Parameters": [{"Name": "list", "Type": "Object", "Description": "The List object"}, {"Name": "fromIndex", "Type": "int", "Description": "Low endpoint (inclusive) of the subList"}, {"Name": "toIndex", "Type": "int", "Description": "High endpoint (exclusive) of the subList"}], "Returns": [{"Type": "Object", "Description": "A view of the specified range within this list"}], "Cautions": "none"},{"Function": "Collections.List.lastIndexOf()", "Signature": "int lastIndexOf ( Object list  ,Object element   )", "Domain": "ACTION", "Description": "Returns the index of the last occurrence of the specified element \n in this list, or -1 if this list does not contain the element.", "Parameters": [{"Name": "list", "Type": "Object", "Description": "The List object"}, {"Name": "element", "Type": "Object", "Description": "Element to search for"}], "Returns": [{"Type": "int", "Description": "The index of the last occurrence of the specified element in \n this list, or -1 if this list does not contain the element"}], "Cautions": "none"},{"Function": "Collections.List.createList()", "Signature": "Object createList ( String className   )", "Domain": "ACTION", "Description": "Creates user specified List implementation", "Parameters": [{"Name": "className", "Type": "String", "Description": "Specify the className that implements the List interface"}], "Returns": [{"Type": "Object", "Description": "Instance of user specified List implementation"}], "Cautions": "none"},{"Function": "Collections.List.createArrayList()", "Signature": "Object createArrayList (  )", "Domain": "ACTION", "Description": "Create and returns instance of ArrayList.", "Parameters": "None.", "Returns": [{"Type": "Object", "Description": "Instance of ArrayList"}], "Cautions": "none"},{"Function": "Collections.List.add()", "Signature": "void add ( Object collection  ,int index  ,Object element)", "Domain": "ACTION", "Description": "Inserts the specified element at the specified position in this collection.", "Parameters": [{"Name": "collection", "Type": "Object", "Description": "The Collection object"}, {"Name": "index", "Type": "int", "Description": "Index at which the specified element is to be inserted"}, {"Name": "element", "Type": "Object", "Description": "Element to be inserted"}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Collections.List.createLinkedListWithId()", "Signature": "Object createLinkedListWithId ( String listId  )", "Domain": "ACTION", "Description": "Create and return instance of LinkedList for the given listID. If the list already exists, return the existing List.", "Parameters": [{"Name": "listId", "Type": "String", "Description": "The String ID of the list to create"}], "Returns": [{"Type": "Object", "Description": "Instance of LinkedList"}], "Cautions": "none"},{"Function": "Collections.List.deleteList()", "Signature": "Object deleteList ( String listId )", "Domain": "ACTION", "Description": "Deletes the instance of List  for the given listID.\nThis function can not be used if the collection is created with createList().", "Parameters": [{"Name": "listId", "Type": "String", "Description": "The String ID of the List to delete"}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Collections.List.createLinkedList()", "Signature": "Object createLinkedList (  )", "Domain": "ACTION", "Description": "Create and returns instance of LinkedList.", "Parameters": "None.", "Returns": [{"Type": "Object", "Description": "Instance of LinkedList"}], "Cautions": "none"},{"Function": "Collections.List.createArrayListWithId()", "Signature": "Object createArrayListWithId ( String listId  )", "Domain": "ACTION", "Description": "Create and return instance of ArrayList for the given listID. If the list already exists, return the existing List.", "Parameters": [{"Name": "listId", "Type": "String", "Description": "The String ID of the list to create"}], "Returns": [{"Type": "Object", "Description": "Instance of ArrayList"}], "Cautions": "none"},{"Function": "Collections.List.createListWithId()", "Signature": "Object createListWithId ( String className , String listId  )", "Domain": "ACTION", "Description": "Create and return instance of user specified list implementation for the given listID. If the list already exists, return the existing List.", "Parameters": [{"Name": "className", "Type": "String", "Description": "Specify the className that implements the List interface"}, {"Name": "listId", "Type": "String", "Description": "The String ID of the list to create"}], "Returns": [{"Type": "Object", "Description": "Instance of user specified List implementation"}], "Cautions": "none"},{"Function": "Collections.List.addAll()", "Signature": "boolean addAll ( Object collection  ,int index  ,Object collection )", "Domain": "ACTION", "Description": "Inserts all of the elements in the specified collection into this collection at the specified position.", "Parameters": [{"Name": "collection", "Type": "Object", "Description": "The Collection object"}, {"Name": "index", "Type": "int", "Description": "Index at which to insert the first element from the specified collection"}, {"Name": "collection2", "Type": "Object", "Description": "Collection containing elements to be added to this collection"}], "Returns": [{"Type": "boolean", "Description": "true, If this collection changed as a result of the call"}], "Cautions": "none"},{"Function": "Collections.List.indexOf()", "Signature": "int indexOf ( Object list  ,Object element   )", "Domain": "ACTION", "Description": "Returns the index of the first occurrence of the specified element \n in this list, or -1 if this list does not contain the element.", "Parameters": [{"Name": "list", "Type": "Object", "Description": "The List object"}, {"Name": "element", "Type": "Object", "Description": "Element to search for"}], "Returns": [{"Type": "int", "Description": "The index of the first occurrence of the specified element in \n this list, or -1 if this list does not contain the element"}], "Cautions": "none"},{"Function": "Collections.List.set()", "Signature": "Object set ( Object list  ,int index  ,Object element   )", "Domain": "ACTION", "Description": "Replaces the element at the specified position in this list with the specified element.", "Parameters": [{"Name": "list", "Type": "Object", "Description": "The list object"}, {"Name": "index", "Type": "int", "Description": "Index of the element to replace"}, {"Name": "element", "Type": "Object", "Description": "Element to be stored at the specified position"}], "Returns": [{"Type": "Object", "Description": "The element previously at the specified position"}], "Cautions": "none"},{"Function": "Collections.List.get()", "Signature": "Object get ( Object list  ,int index   )", "Domain": "ACTION", "Description": "Returns the element at the specified position in this list.", "Parameters": [{"Name": "list", "Type": "Object", "Description": "The List object"}, {"Name": "index", "Type": "int", "Description": "Index of the element to return"}], "Returns": [{"Type": "Object", "Description": "The element at the specified position in this list"}], "Cautions": "none"},{"Function": "Collections.Set.createHashSetWithId()", "Signature": "Object createHashSetWithId ( String setId )", "Domain": "ACTION", "Description": "Create and return instance of HashSet for the given setID. If the set already exists, return the existing Set.", "Parameters": [{"Name": "setId", "Type": "String", "Description": "The String ID of the set to create"}], "Returns": [{"Type": "Object", "Description": "Instance of HashSet"}], "Cautions": "none"},{"Function": "Collections.Set.createSet()", "Signature": "Object createSet ( String className   )", "Domain": "ACTION", "Description": "Create and return instance of user specified Set implementation.", "Parameters": [{"Name": "className", "Type": "String", "Description": "Specify the className that implements the Set interface"}], "Returns": [{"Type": "Object", "Description": "Instance of user specified Set implementation"}], "Cautions": "none"},{"Function": "Collections.Set.createTreeSetWithId()", "Signature": "Object createTreeSetWithId ( String setId )", "Domain": "ACTION", "Description": "Create and return instance of TreeSet for the given setID. If the set already exists, return the existing Set.", "Parameters": [{"Name": "setId", "Type": "String", "Description": "The String ID of the set to create"}], "Returns": [{"Type": "Object", "Description": "Instance of TreeSet"}], "Cautions": "none"},{"Function": "Collections.Set.createLinkedHashSet()", "Signature": "Object createLinkedHashSet (  )", "Domain": "ACTION", "Description": "Create and return the instance of LinkedHashSet.", "Parameters": "None.", "Returns": [{"Type": "Object", "Description": "Instance of LinkedHashSet"}], "Cautions": "none"},{"Function": "Collections.Set.getSet()", "Signature": "Object getSet ( String setId )", "Domain": "ACTION", "Description": "Returns the instance of Set  for the given setID.\nThis function can not be used when a set is created using createSet(), createHashSet(), createLinkedHashSet() and createTreeSet() functions.", "Parameters": [{"Name": "setId", "Type": "String", "Description": "The String ID of the Set"}], "Returns": [{"Type": "Object", "Description": "The instance of Set"}], "Cautions": "none"},{"Function": "Collections.Set.createTreeSet()", "Signature": "Object createTreeSet (  )", "Domain": "ACTION", "Description": "Create and return the instance of TreeSet.", "Parameters": "None.", "Returns": [{"Type": "Object", "Description": "Instance of TreeSet"}], "Cautions": "none"},{"Function": "Collections.Set.deleteSet()", "Signature": "Object deleteSet ( String setId )", "Domain": "ACTION", "Description": "Deletes the instance of Set  for the given setID.\nThis function can not be used if the collection is created with createSet().", "Parameters": [{"Name": "setId", "Type": "String", "Description": "The String ID of the Set to delete"}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Collections.Set.createHashSet()", "Signature": "Object createHashSet ()", "Domain": "ACTION", "Description": "Create and return the instance of HashSet.", "Parameters": "None.", "Returns": [{"Type": "Object", "Description": "Instance of HashSet"}], "Cautions": "none"},{"Function": "Collections.Set.createSetWithId()", "Signature": "Object createSetWithId ( String className,  String setId )", "Domain": "ACTION", "Description": "Create and return instance of user specified Set implementation for the given setID. If the list already exists, return the existing Set.", "Parameters": [{"Name": "className", "Type": "String", "Description": "Specify the className that implements the Set interface"}, {"Name": "setId", "Type": "String", "Description": "The String ID of the set to create"}], "Returns": [{"Type": "Object", "Description": "Instance of user specified Set implementation"}], "Cautions": "none"},{"Function": "Collections.Set.createLinkedHashSetWithId()", "Signature": "Object createLinkedHashSetWithId ( String setId )", "Domain": "ACTION", "Description": "Create and return instance of LinkedHashSet for the given setID. If the set already exists, return the existing Set.", "Parameters": [{"Name": "setId", "Type": "String", "Description": "The String ID of the set to create"}], "Returns": [{"Type": "Object", "Description": "Instance of LinkedHashSet"}], "Cautions": "none"},{"Function": "Engine.sessionName()", "Signature": "String sessionName ()", "Domain": "ACTION, CONDITION, BUI", "Description": "Returns the current RuleSession Name.", "Parameters": "None.", "Returns": [{"Type": "String", "Description": "The Session Name."}], "Cautions": "none"},{"Function": "Engine.executeRules()", "Signature": "void executeRules()", "Domain": "ACTION", "Description": "Execute the rules in the preprocessor context. Whatever is present (mainly asserted or deleted, will be used for execution;", "Parameters": "None.", "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Engine.numberOfRulesFired()", "Signature": "long numberOfRulesFired ()", "Domain": "ACTION, CONDITION, BUI", "Description": "Returns the total number of rules fired in current working memory since the counter was last reset.", "Parameters": "None.", "Returns": [{"Type": "long", "Description": "The number of rules fired in current working memory."}], "Cautions": "none"},{"Function": "Engine.numberOfInstances()", "Signature": "int numberOfInstances()", "Domain": "ACTION, CONDITION, BUI", "Description": "Returns the total number of instances exist in the working memory.", "Parameters": "None.", "Returns": [{"Type": "int", "Description": "The number of instances in the working memory."}], "Cautions": "none"},{"Function": "Engine.loadResourceAsByte()", "Signature": "Object loadResourceAsByte(String uri)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "When a relative path to a file is provided, then the byte representation of the file contents are returned.", "Parameters": [{"Name": "uri", "Type": "String", "Description": "Relative path of a file if any uri is provided, else null."}], "Returns": [{"Type": "Object", "Description": "Returns the contents of the file the uri is pointing to in a byte array format."}], "Cautions": "none"},{"Function": "Engine.clusterSubscriptionLoadOnly()", "Signature": "void clusterSubscriptionLoadOnly()", "Domain": "ACTION", "Description": "Loads the Entity that comes from Cluster Subscription into the working memory only and does not execute any rule for it.This can only be used in the preprocessor for the Entity which Subscribes Cluster.", "Parameters": "None.", "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Engine.jvmMemoryMax()", "Signature": "long jvmMemoryMax ()", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns the maximum memory size of the JVM.", "Parameters": "None.", "Returns": [{"Type": "long", "Description": "The maximum memory size of the JVM."}], "Cautions": "none"},{"Function": "Engine.assertEvent_Async()", "Signature": "void assertEvent_Async()", "Domain": "ACTION", "Description": "Execute the rules in the preprocessor context. Whatever is present (mainly asserted or deleted, will be used for execution;", "Parameters": [{"Name": "workManagerID", "Type": "String", "Description": "Name of an existing work-manager to be used for the execution"}, {"Name": "event", "Type": "SimpleEvent", "Description": "Event to be asserted"}, {"Name": "ruleFunction", "Type": "String", "Description": "Fully qualified name of the preprocessor function if any, else null."}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Engine.currentRuleIdentifiers()", "Signature": "Object[] currentRuleIdentifiers()", "Domain": "ACTION, BUI", "Description": "Returns currently executing Rule's Identifiers (arguments), or 'null' if there is none.", "Parameters": "None.", "Returns": [{"Type": "Object[]", "Description": "Currently executing Rule's Identifiers (arguments), or null if there is none."}], "Cautions": "none"},{"Function": "Engine.executionContext()", "Signature": "String[] executionContext()", "Domain": "ACTION, BUI", "Description": "Returns the current execution context.  The first element in the String[] indicates where\nthis call is executing under. The remaining elements in the String[] contains the objects\nthat associated with the context.  For example, if this is executing in Rule A.B.C and the\nscope is InstanceX. This function will returns { $1Rule=A.B.C$1, $1InstanceX@id=12@extId=123$1 }.", "Parameters": "None.", "Returns": [{"Type": "String[]", "Description": "The current execution context."}], "Cautions": "none"},{"Function": "Engine.ruleName()", "Signature": "String ruleName()", "Domain": "ACTION, BUI", "Description": "Returns the name of the currently executing Rule, or \"\" if there is none.", "Parameters": "None.", "Returns": [{"Type": "String", "Description": "The name of the currently executing Rule, or \"\" if there is none."}], "Cautions": "none"},{"Function": "Engine.currentRuleFunction()", "Signature": "Object currentRuleFunction()", "Domain": "ACTION, BUI", "Description": "Returns currently executing RuleFunction, or 'null' if there is none.", "Parameters": "None.", "Returns": [{"Type": "Object", "Description": "Currently executing RuleFunction, or null if there is none."}], "Cautions": "none"},{"Function": "Engine.resetNumberOfRulesFired()", "Signature": "void resetNumberOfRulesFired ()", "Domain": "ACTION, BUI", "Description": "Resets the counter that tracks the total number of rules fired in current working memory.", "Parameters": "None.", "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Engine.executeRulesAsync()", "Signature": "void executeRulesAsync(String workManagerID)", "Domain": "ACTION", "Description": "Execute the rules in the preprocessor context. Whatever is present (mainly asserted or deleted, will be used for execution;", "Parameters": [{"Name": "workManagerID", "Type": "String", "Description": "Name of an existing work-manager to be used for the execution"}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Engine.currentRuleConditions()", "Signature": "Object[] currentRuleConditions()", "Domain": "ACTION, BUI", "Description": "Returns currently executing Rule's Conditions, or 'null' if there is none.", "Parameters": "None.", "Returns": [{"Type": "Object[]", "Description": "Currently executing Rule's Conditions, or null if there is none."}], "Cautions": "none"},{"Function": "Engine.currentRule()", "Signature": "Object currentRule()", "Domain": "ACTION, BUI", "Description": "Returns currently executing Rule, or 'null' if there is none.", "Parameters": "None.", "Returns": [{"Type": "Object", "Description": "Currently executing Rule, or null if there is none."}], "Cautions": "none"},{"Function": "Engine.gc()", "Signature": "void gc()", "Domain": "ACTION, BUI", "Description": "Runs the Java Garbage Collection.", "Parameters": "None.", "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Engine.invokeRuleFunction()", "Signature": "Object invokeRuleFunction(String uri, Object[] arguments)", "Domain": "ACTION, BUI", "Description": "Invoke a rule function by name.", "Parameters": [{"Name": "uri", "Type": "String", "Description": "The URI of the rule function to invoke."}, {"Name": "arguments", "Type": "Object[]", "Description": "Array elements must be in the same order as the arguments are declared by the rule function."}], "Returns": [{"Type": "Object", "Description": "The result if any. Will be null if function returns void."}], "Cautions": "none"},{"Function": "Engine.threadName()", "Signature": "String threadName()", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the name of the current thread.", "Parameters": "None.", "Returns": [{"Type": "String", "Description": "Thread name."}], "Cautions": "none"},{"Function": "Engine.sleep()", "Signature": "void sleep(long millisec)", "Domain": "ACTION, BUI", "Description": "Put current rule session to sleep. Caution! In case of single-threaded RTC, this method may block current thread as well as all other rule sessions.", "Parameters": "None.", "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Engine.currentRuleActions()", "Signature": "Object[] currentRuleActions", "Domain": "ACTION, BUI", "Description": "Returns currently executing Rule's Actions, or 'null' if there is none.", "Parameters": "None.", "Returns": [{"Type": "Object[]", "Description": "Currently executing Rule's Actions, or null if there is none."}], "Cautions": "none"},{"Function": "Engine.engineName()", "Signature": "String engineName ()", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns the Engine name.", "Parameters": "None.", "Returns": [{"Type": "String", "Description": "The Engine name."}], "Cautions": "none"},{"Function": "Engine.shutdown()", "Signature": "void shutdown(boolean immediate)", "Domain": "ACTION, BUI", "Description": "Shutdown the engine.", "Parameters": [{"Name": "immediate", "Type": "boolean", "Description": "if false waits for completion of RTC and for acknowledgment of events received."}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Engine.jvmMemoryFree()", "Signature": "long jvmMemoryFree ()", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns an estimate of the free memory available to the JVM.", "Parameters": "None.", "Returns": [{"Type": "long", "Description": "The size of the free memory."}], "Cautions": "none"},{"Function": "Engine.jvmMemoryUsed()", "Signature": "long jvmMemoryUsed ()", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns an estimate of the used memory in the JVM.", "Parameters": "None.", "Returns": [{"Type": "long", "Description": "The size of the used memory."}], "Cautions": "none"},{"Function": "Engine.sessionIndex()", "Signature": "int sessionIndex ()", "Domain": "ACTION, CONDITION", "Description": "Returns the current Index of the RuleSession in the EAR's. If numLocal is provided, then it will give that info.", "Parameters": "None.", "Returns": [{"Type": "int", "Description": "The Session Index."}], "Cautions": "none"},{"Function": "Engine.loadResourceAsString()", "Signature": "String loadResourceAsString(String uri, String encoding)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "When a relative path to a file is provided, then the contents of the file are returned in String format. The type of encoding to be used can be determined by the user. In case no encoding is provided, then UTF-8 is used by default.", "Parameters": [{"Name": "uri", "Type": "String", "Description": "Relative path of a file if any uri is provided, else null."}, {"Name": "encoding", "Type": "String", "Description": "Type of encoding to be used, if encoding mentioned is empty string or null, then UTF-8 would be used as default encoding."}], "Returns": [{"Type": "String", "Description": "Returns the contents of the file in String format after applying the encoding (UTF-8 by default)."}], "Cautions": "none"},{"Function": "Engine.invokeRule()", "Signature": "Object[] invokeRule(String uri, Object[] inputSet, boolean dirtyRead)", "Domain": "ACTION, BUI", "Description": "Find all the matched tuples of a rule given partial input set.  And for each tuple, execute the rule action.", "Parameters": [{"Name": "uri", "Type": "String", "Description": "The URI of the rule to invoke."}, {"Name": "inputSet", "Type": "Object[]", "Description": "support one input in the array.)"}, {"Name": "dirtyRead", "Type": "boolean", "Description": "If true, it won't synchronize the working memory during the read when calling from preprocessor"}], "Returns": [{"Type": "Object[]", "Description": "The result Set, each element in the Object[] is a result tuple which is another Object[]."}], "Cautions": "none"},{"Function": "Engine.numberOfEvents()", "Signature": "int numberOfEvents()", "Domain": "ACTION, CONDITION, BUI", "Description": "Returns the total number of events exist in the working memory.", "Parameters": "None.", "Returns": [{"Type": "int", "Description": "The number of events in the working memory."}], "Cautions": "none"},{"Function": "Engine.ruleFunctionName()", "Signature": "String ruleFunctionName()", "Domain": "ACTION, BUI", "Description": "Returns the name of the currently executing RuleFunction, or \"\" if there is none.  For example, if executing RuleFunction A.B.C, this function will return \"A.B.C\".", "Parameters": "None.", "Returns": [{"Type": "String", "Description": "The name of the currently executing RuleFunction, or \"\" if there is none."}], "Cautions": "none"},{"Function": "Engine.Locale.setDefaultTimeZone()", "Signature": "void setDefaultTimeZone(String tz)", "Domain": "ACTION, BUI", "Description": "Sets the default timezone id. null sets it back to the value at JVM start.", "Parameters": [{"Name": "tz", "Type": "String", "Description": "The Time Zone ID; invalid id defaults to GMT."}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Engine.Locale.getLanguage()", "Signature": "String getLanguage ()", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns the language in current locale.", "Parameters": "None.", "Returns": [{"Type": "String", "Description": "Language in current locale."}], "Cautions": "none"},{"Function": "Engine.Locale.getCountry()", "Signature": "String getCountry ()", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns the country code in current locale.", "Parameters": "None.", "Returns": [{"Type": "String", "Description": "Country code in current locale."}], "Cautions": "none"},{"Function": "Engine.Locale.getDefaultTimeZone()", "Signature": "String getDefaultTimeZone()", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the default timezone; value depends on JVM implementation.", "Parameters": "None.", "Returns": [{"Type": "String", "Description": "The timezone id."}], "Cautions": "none"},{"Function": "Engine.Variable.removeEngineVar()", "Signature": "void removeEngineVar(String varName)", "Domain": "ACTION, CONDITION, BUI", "Description": "Removes the engine variable of name varName.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Engine.Variable.getEngineLongArrayVar()", "Signature": "long[] getEngineLongArrayVar(String varName)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the engine variable as long[] of name varName.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.  This function returns null if the variable is not set.", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}], "Returns": [{"Type": "long[]", "Description": "The value of this variable"}], "Cautions": "none"},{"Function": "Engine.Variable.setEngineIntVar()", "Signature": "void setEngineIntVar(String varName, int value)", "Domain": "ACTION, CONDITION, BUI", "Description": "Sets the engine variable of name varName to value.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.\n* @.cautions none", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}, {"Name": "value", "Type": "int", "Description": "The value of the variable."}], "Returns": [{"Type": "void"}]},{"Function": "Engine.Variable.getEngineDateTimeVar()", "Signature": "DateTime getEngineDateTimeVar(String varName)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the engine variable as DateTime of name varName.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.  This function returns null if the variable is not set.", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}], "Returns": [{"Type": "DateTime", "Description": "The value of this variable"}], "Cautions": "none"},{"Function": "Engine.Variable.getEngineStringVar()", "Signature": "String getEngineStringVar(String varName)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the engine variable as String of name varName.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.  This function returns null if the variable is not set.", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}], "Returns": [{"Type": "String", "Description": "The value of this variable"}], "Cautions": "none"},{"Function": "Engine.Variable.getEngineIntVar()", "Signature": "int getEngineIntVar(String varName)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the engine variable as int of name varName.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.  This function returns 0 if the variable is not set.", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}], "Returns": [{"Type": "int", "Description": "The value of this variable"}], "Cautions": "none"},{"Function": "Engine.Variable.getEngineIntArrayVar()", "Signature": "int[] getEngineIntArrayVar(String varName)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the engine variable as int[] of name varName.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.  This function returns null if the variable is not set.", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}], "Returns": [{"Type": "int[]", "Description": "The value of this variable"}], "Cautions": "none"},{"Function": "Engine.Variable.setEngineLongArrayVar()", "Signature": "void setEngineLongArrayVar(String varName, long[] value)", "Domain": "ACTION, CONDITION, BUI", "Description": "Sets the engine variable of name varName to value.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.\n* @.cautions none", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}, {"Name": "value", "Type": "long[]", "Description": "The value of the variable."}], "Returns": [{"Type": "void"}]},{"Function": "Engine.Variable.setEngineBooleanArrayVar()", "Signature": "void setEngineBooleanArrayVar(String varName, boolean[] value)", "Domain": "ACTION, CONDITION, BUI", "Description": "Sets the engine variable of name varName to value.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.\n* @.cautions none", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}, {"Name": "value", "Type": "boolean[]", "Description": "The value of the variable."}], "Returns": [{"Type": "void"}]},{"Function": "Engine.Variable.setEngineStringArrayVar()", "Signature": "void setEngineStringArrayVar(String varName, String[] value)", "Domain": "ACTION, CONDITION, BUI", "Description": "Sets the engine variable of name varName to value.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}, {"Name": "value", "Type": "String[]", "Description": "The value of the variable."}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Engine.Variable.setEngineBooleanVar()", "Signature": "void setEngineBooleanVar(String varName, boolean value)", "Domain": "ACTION, CONDITION, BUI", "Description": "Sets the engine variable of name varName to value.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.\n* @.cautions none", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}, {"Name": "value", "Type": "boolean", "Description": "The value of the variable."}], "Returns": [{"Type": "void"}]},{"Function": "Engine.Variable.getEngineDoubleArrayVar()", "Signature": "double getEngineDoubleArrayVar(String varName)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the engine variable as double[] of name varName.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.  This function 0.0 false if the variable is not set.", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}], "Returns": [{"Type": "double[]", "Description": "The value of this variable"}], "Cautions": "none"},{"Function": "Engine.Variable.setEngineDoubleVar()", "Signature": "void setEngineDoubleVar(String varName, double value)", "Domain": "ACTION, CONDITION, BUI", "Description": "Sets the engine variable of name varName to value.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.\n* @.cautions none", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}, {"Name": "value", "Type": "double", "Description": "The value of the variable."}], "Returns": [{"Type": "void"}]},{"Function": "Engine.Variable.setEngineObjectVar()", "Signature": "void setEngineObjectVar(String varName, Object value)", "Domain": "ACTION, CONDITION, BUI", "Description": "Sets the engine variable of name varName to value.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.\n* @.cautions none", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}, {"Name": "value", "Type": "Object", "Description": "The value of the variable."}], "Returns": [{"Type": "void"}]},{"Function": "Engine.Variable.getEngineDateTimeArrayVar()", "Signature": "DateTime[] getEngineDateTimeArrayVar(String varName)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the engine variable as DateTime[] of name varName.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.  This function returns null if the variable is not set.", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}], "Returns": [{"Type": "DateTime", "Description": "The value of this variable"}], "Cautions": "none"},{"Function": "Engine.Variable.setEngineDateTimeVar()", "Signature": "void setEngineDateTimeVar(String varName, DateTime value)", "Domain": "ACTION, CONDITION, BUI", "Description": "Sets the engine variable of name varName to value.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.\n* @.cautions none", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}, {"Name": "value", "Type": "DateTime", "Description": "The value of the variable."}], "Returns": [{"Type": "void"}]},{"Function": "Engine.Variable.setEngineIntArrayVar()", "Signature": "void setEngineIntArrayVar(String varName, int[] value)", "Domain": "ACTION, CONDITION, BUI", "Description": "Sets the engine variable of name varName to value.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.\n* @.cautions none", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}, {"Name": "value", "Type": "int[]", "Description": "The value of the variable."}], "Returns": [{"Type": "void"}]},{"Function": "Engine.Variable.getEngineDoubleVar()", "Signature": "double getEngineDoubleVar(String varName)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the engine variable as double of name varName.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.  This function 0.0 false if the variable is not set.", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}], "Returns": [{"Type": "double", "Description": "The value of this variable"}], "Cautions": "none"},{"Function": "Engine.Variable.getEngineObjectVar()", "Signature": "Object getEngineObjectVar(String varName)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the engine variable as Object of name varName.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.  This function returns null if the variable is not set.", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}], "Returns": [{"Type": "Object", "Description": "The value of this variable"}], "Cautions": "none"},{"Function": "Engine.Variable.getEngineBooleanArrayVar()", "Signature": "boolean[] getEngineBooleanArrayVar(String varName)", "Domain": "ACTION, CONDITION, QUERY", "Description": "Gets the engine variable as boolean[] of name varName.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.  This function returns null if the variable is not set.", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}], "Returns": [{"Type": "boolean[]", "Description": "The value of this variable"}], "Cautions": "none"},{"Function": "Engine.Variable.setEngineDoubleArrayVar()", "Signature": "void setEngineDoubleArrayVar(String varName, double[] value)", "Domain": "ACTION, CONDITION, BUI", "Description": "Sets the engine variable of name varName to value.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.\n* @.cautions none", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}, {"Name": "value", "Type": "double[]", "Description": "The value of the variable."}], "Returns": [{"Type": "void"}]},{"Function": "Engine.Variable.getEngineBooleanVar()", "Signature": "boolean getEngineBooleanVar(String varName)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the engine variable as boolean of name varName.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.  This function returns false if the variable is not set.", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}], "Returns": [{"Type": "boolean", "Description": "The value of this variable"}], "Cautions": "none"},{"Function": "Engine.Variable.getEngineLongVar()", "Signature": "long getEngineLongVar(String varName)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the engine variable as long of name varName.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.  This function returns 0L if the variable is not set.", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}], "Returns": [{"Type": "long", "Description": "The value of this variable"}], "Cautions": "none"},{"Function": "Engine.Variable.getEngineStringArrayVar()", "Signature": "String[] getEngineStringArrayVar(String varName)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Gets the engine variable as String[] of name varName.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.  This function returns null if the variable is not set.", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}], "Returns": [{"Type": "String[]", "Description": "The value of this variable"}], "Cautions": "none"},{"Function": "Engine.Variable.setEngineStringVar()", "Signature": "void setEngineStringVar(String varName, String value)", "Domain": "ACTION, CONDITION, BUI", "Description": "Sets the engine variable of name varName to value.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.\n* @.cautions none", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}, {"Name": "value", "Type": "String", "Description": "The value of the variable."}], "Returns": [{"Type": "void"}]},{"Function": "Engine.Variable.setEngineDateTimeArrayVar()", "Signature": "void setEngineDateTimeArrayVar(String varName, DateTime[] value)", "Domain": "ACTION, CONDITION, BUI", "Description": "Sets the engine variable of name varName to value.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.\n* @.cautions none", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}, {"Name": "value", "Type": "DateTime[]", "Description": "The value of the variable."}], "Returns": [{"Type": "void"}]},{"Function": "Engine.Variable.setEngineLongVar()", "Signature": "void setEngineLongVar(String varName, long value)", "Domain": "ACTION, CONDITION, BUI", "Description": "Sets the engine variable of name varName to value.  Engine variable is a in-memory variable share\nacross all the rule sessions for a RuleServiceProvider.  Rule condition won't have dependency of this variable i.e. changes\nof this variable won't retrigger the rule if it is used in the condition.\n* @.cautions none", "Parameters": [{"Name": "varName", "Type": "String", "Description": "The name of the variable."}, {"Name": "value", "Type": "long", "Description": "The value of the variable."}], "Returns": [{"Type": "void"}]},{"Function": "Engine.Rtc.abortRTC()", "Signature": "void abortRTC()", "Domain": "ACTION", "Description": "Cancels all rule actions scheduled to be executed in the current RTC.  Cancels all pending external changes in the current RTC: new/modified/deleted cache-based entities, events to send, event acknowledgments and scheduled events to schedule.  The rollback operation (if implemented) of the destination of the event (if any) that triggered the RTC will be invoked.", "Parameters": "None.", "Returns": [{"Type": "void"}], "Cautions": "This function only affects the present state of the RTC.  Any subsequent actions taken after the call, such as sending events or modifying concepts will proceed as normal."},{"Function": "Engine.Rtc.printAgenda()", "Signature": "String printAgenda()", "Domain": "ACTION", "Description": "Returns the current agenda of the current RTC.", "Parameters": "None.", "Returns": [{"Type": "String", "Description": "A textual description of the current agenda of the current RTC."}], "Cautions": "Note that the agenda may change after each rule is executed as the working memory changes."},{"Function": "Engine.Profiler.stopCollecting()", "Signature": "void stopCollecting()", "Domain": "ACTION, BUI", "Description": "Turns off the BusinessEvents Profiler and writes the profile data into a file specified\nwhen the Profiler was turned on.", "Parameters": "None.", "Returns": [{"Type": "void"}], "Cautions": "Profiler is not for BE Query."},{"Function": "Engine.Profiler.startCollectingToFile()", "Signature": "void startCollectingToFile(String fileName, int level, long duration)", "Domain": "ACTION, BUI", "Description": "Turns on the BusinessEvents Profiler and starts collecting data for a specified duration. At the end of the duration or when the Profiler is turned off before the end of the duration, profiling data will be output to a file in comma separated value format.", "Parameters": [{"Name": "fileName", "Type": "String", "Description": "The name of output file that the Profiler writes to."}, {"Name": "level", "Type": "int", "Description": "If 1, only RTC level of profile data will be collected."}, {"Name": "duration", "Type": "long", "Description": "Time duration in seconds that the profile data will be collected."}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Exception.newException()", "Signature": "Exception newException (String errorType, String message, Exception cause)", "Domain": "ACTION, CONDITION, BUI", "Description": "This creates a new Exception Instance based on the data passed in.", "Parameters": [{"Name": "errorType", "Type": "String", "Description": "indicates the type of error this exception represents"}, {"Name": "message", "Type": "String", "Description": "more detailed information about the error this exception represents"}, {"Name": "cause", "Type": "Exception", "Description": "an exception that has caused this exception"}], "Returns": [{"Type": "Exception", "Description": "The newly created Exception Instance."}], "Cautions": "none"},{"Function": "Event.createEventFromXML()", "Signature": "Event createEventFromXML (String uri, String xml)", "Domain": "ACTION, BUI", "Description": "xml", "Parameters": [{"Name": "uri", "Type": "String", "Description": "will use the XML to parse the namespace and create the corresponding event."}, {"Name": "xml", "Type": "String", "Description": "XML string to be parsed"}], "Returns": [{"Type": "Event"}], "Cautions": "The following exceptions are thrown when Event.createEventFromXML() is used with wrong arguments to create events from XML.\n(1) java.lang.RuntimeException: com.tibco.xml.data.cursor.UndefinedPropertyException: [attributes] is not defined for the node type \"document\".\n(2) java.lang.RuntimeException: org.xml.sax.SAXParseException; lineNumber: 1; columnNumber: 41; The processing instruction target matching \"[xX][mM][lL]\" is not allowed.", "Example": "Event.createEventFromXML(\"&ltONTOLOGY_PATH_OF_THE_EVENT>\", \"&ltEventName>&ltpayload>\"+xmlpayload+\"</payload></EventName>\");"},{"Function": "Event.getById()", "Signature": "Event getById (Object Id)", "Domain": "ACTION", "Description": "Id", "Parameters": [{"Name": "Id", "Type": "Object", "Description": "The internal ID, retrieved off"}], "Returns": [{"Type": "Event", "Description": "Id"}], "Cautions": "none"},{"Function": "Event.acknowledgeEvent()", "Signature": "void acknowledgeEvent (SimpleEvent evt)", "Domain": "ACTION", "Description": "Acknowledge the event passed.", "Parameters": [{"Name": "evt", "Type": "SimpleEvent", "Description": "The event to acknowledge."}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Event.replyEvent()", "Signature": "boolean replyEvent(SimpleEvent request, SimpleEvent reply)", "Domain": "ACTION, BUI", "Description": "request", "Parameters": [{"Name": "request", "Type": "SimpleEvent", "Description": "The original request SimpleEvent."}, {"Name": "reply", "Type": "SimpleEvent", "Description": "The Reply SimpleEvent."}], "Returns": [{"Type": "boolean", "Description": "true if the SimpleEvent is sent; false otherwise."}]},{"Function": "Event.requestEvent()", "Signature": "Object requestEvent(SimpleEvent requestEvent, String responseEventURI, String requestEventDestinationURI, long timeout, String properties)", "Domain": "ACTION, BUI", "Description": "Make synchronous request/response calls using JMS. Sends an event and waits for a response to be returned.Each request creates and listens on a JMS temporary queue for a response.", "Parameters": [{"Name": "requestEvent", "Type": "SimpleEvent", "Description": "The SimpleEvent to use to make the request."}, {"Name": "responseEventURI", "Type": "String", "Description": "null"}, {"Name": "requestEventDestinationURI", "Type": "String", "Description": "null"}, {"Name": "timeout", "Type": "long", "Description": "The duration in milliseconds to wait for a response. Use -1 to wait forever."}, {"Name": "properties", "Type": "String", "Description": "[name1=value1;name2=value2;...;]"}], "Returns": [{"Type": "Object", "Description": "responseEventURI"}], "Cautions": "requestEvent"},{"Function": "Event.assertAdvisoryEvent()", "Signature": "void assertAdvisoryEvent(String category, String type, String message)", "Domain": "ACTION, BUI", "Description": "Assert an AdvisoryEvent with user defined fields.", "Parameters": [{"Name": "category", "Type": "String", "Description": "New AdvisoryEvent's category attribute.  The broad category of advisory."}, {"Name": "type", "Type": "String", "Description": "New AdvisoryEvent's category attribute. Type of advisory within the category."}, {"Name": "message", "Type": "String", "Description": "New AdvisoryEvent's message attribute."}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Event.getByExtIdByUri()", "Signature": "SimpleEvent getByExtIdByUri (String extId, String uri)", "Domain": "ACTION, BUI", "Description": "extId", "Parameters": [{"Name": "extId", "Type": "String", "Description": "The external ID."}, {"Name": "uri", "Type": "String", "Description": "URI of the event"}], "Returns": [{"Type": "SimpleEvent", "Description": "extId"}], "Cautions": "none"},{"Function": "Event.setPayload()", "Signature": "void setPayload(SimpleEvent target, SimpleEvent source)", "Domain": "ACTION, CONDITION, BUI", "Description": "Makes the target SimpleEvent use the same payload as the source SimpleEvent.", "Parameters": [{"Name": "target", "Type": "SimpleEvent", "Description": "The SimpleEvent whose payload is being set."}, {"Name": "source", "Type": "SimpleEvent", "Description": "The SimpleEvent from which the payload is obtained"}], "Returns": [{"Type": "void"}]},{"Function": "Event.consumeEvent()", "Signature": "void consumeEvent (Event evt)", "Domain": "ACTION", "Description": "Consume the Event passed (removes the Event from working memory).", "Parameters": [{"Name": "evt", "Type": "Event", "Description": "The event to consume."}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Event.assertEvent()", "Signature": "SimpleEvent assertEvent (SimpleEvent event)", "Domain": "ACTION", "Description": "Asserts a SimpleEvent into the working memory.", "Parameters": [{"Name": "event", "Type": "SimpleEvent", "Description": "The simpleEvent to be asserted."}], "Returns": [{"Type": "SimpleEvent", "Description": "The SimpleEvent. Null if there is an error, of the argument was null."}]},{"Function": "Event.serializeToJSON()", "Signature": "String serializeToJSON(SimpleEvent event, boolean pretty)", "Domain": "ACTION, CONDITION, BUI", "Description": "This function serializes the event to JSON string", "Parameters": [{"Name": "event", "Type": "SimpleEvent", "Description": "The input event"}, {"Name": "pretty", "Type": "boolean", "Description": "If true, the output will be formatted for human-readability."}], "Returns": [{"Type": "String", "Description": "Serialized JSON"}], "Cautions": "The input event cannot be null."},{"Function": "Event.getPayloadAsBytes()", "Signature": "Object getPayloadAsBytes(SimpleEvent input)", "Domain": "ACTION, CONDITION, BUI", "Description": "byte[]", "Parameters": [{"Name": "input", "Type": "SimpleEvent", "Description": "The input event"}], "Returns": [{"Type": "byte[]", "Description": "as Object"}], "Cautions": "The input event cannot be null."},{"Function": "Event.getPayload()", "Signature": "Object getPayload(SimpleEvent event)", "Domain": "ACTION, CONDITION, BUI", "Description": "Returns the payload associated with the event", "Parameters": [{"Name": "event", "Type": "SimpleEvent", "Description": "The SimpleEvent whose payload is being returned."}], "Returns": [{"Type": "Object", "Description": "Payload Object"}]},{"Function": "Event.serializeToXML()", "Signature": "String serializeToXML(SimpleEvent event)", "Domain": "ACTION, CONDITION, BUI", "Description": "This function serializes the event to XML string", "Parameters": [{"Name": "event", "Type": "SimpleEvent", "Description": "The input event"}], "Returns": [{"Type": "String", "Description": "Serialized XML"}], "Cautions": "The input event cannot be null."},{"Function": "Event.validatePayload()", "Signature": "void validatePayload(SimpleEvent event)", "Domain": "ACTION, CONDITION, BUI", "Description": "Validates the payload of the event in the current RuleSession. Validation will throw an Exception if the validation failed.", "Parameters": [{"Name": "event", "Type": "SimpleEvent", "Description": "The SimpleEvent whose payload will be validated, if present."}], "Returns": [{"Type": "void"}]},{"Function": "Event.createEvent()", "Signature": "SimpleEvent createEvent (String xslt-template)", "Domain": "ACTION, BUI", "Description": "Create a new SimpleEvent using the an XSLT EventBuilder.", "Parameters": [{"Name": "xslt-template", "Type": "String", "Description": "formed using XSLT EventBuilder."}], "Returns": [{"Type": "SimpleEvent", "Description": "The newly created SimpleEvent."}], "Cautions": "none"},{"Function": "Event.routeTo()", "Signature": "SimpleEvent routeTo(SimpleEvent event, String destinationPath, String properties) {", "Domain": "ACTION, BUI", "Description": "Sends a SimpleEvent to a Destination with custom destination properties.\nThe Destination in turn specifies the Channel where the Event will be sent.", "Parameters": [{"Name": "event", "Type": "SimpleEvent", "Description": "The simpleEvent to be sent."}, {"Name": "destinationPath", "Type": "String", "Description": "The path to the Destination that will be used to send the Event. E.G. \"/MyChannel/MyDestination\" where MyChannel is the Channel in the model and MyDestination is the destination in it."}, {"Name": "properties", "Type": "String", "Description": "[name1=value1;name2=value2;...;]"}], "Returns": [{"Type": "SimpleEvent", "Description": "The same value as the argument evt, or null if there was an error."}], "Cautions": "Custom channels may not support overriding of destination properties."},{"Function": "Event.getDestinationURI()", "Signature": "String getDestinationURI (SimpleEvent event)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns The destination URI of the specified event.", "Parameters": [{"Name": "event", "Type": "SimpleEvent", "Description": "The event whose destination URI is to be returned."}], "Returns": [{"Type": "String", "Description": "null"}]},{"Function": "Event.createEventFromJSON()", "Signature": "Event createEventFromJSON(String uri, String json)", "Domain": "ACTION, BUI", "Description": "json", "Parameters": [{"Name": "uri", "Type": "String", "Description": "URI of the corresponding event."}, {"Name": "json", "Type": "String", "Description": "JSON string to be parsed"}], "Returns": [{"Type": "Event", "Description": "returns an event instance"}], "Cautions": "none"},{"Function": "Event.sendEvent()", "Signature": "SimpleEvent sendEvent (SimpleEvent evt)", "Domain": "ACTION, BUI", "Description": "evt", "Parameters": [{"Name": "evt", "Type": "SimpleEvent", "Description": "An SimpleEvent to send."}], "Returns": [{"Type": "SimpleEvent", "Description": "The same value as the argument evt, or null if there was an error."}], "Cautions": "This method will fail if the SimpleEvent has not been configured with any default channel and destination information."},{"Function": "Event.Ext.createEventFromXML()", "Signature": "Event createEventFromXML (String uri, String xml)", "Domain": "ACTION, BUI", "Description": "xml", "Parameters": [{"Name": "uri", "Type": "String", "Description": "will use the XML to parse the namespace and create the corresponding event."}, {"Name": "xml", "Type": "String", "Description": "XML string to be parsed"}], "Returns": [{"Type": "Event"}], "Cautions": "The following exceptions are thrown when Event.createEventFromXML() is used with wrong arguments to create events from XML.\n(1) java.lang.RuntimeException: com.tibco.xml.data.cursor.UndefinedPropertyException: [attributes] is not defined for the node type \"document\".\n(2) java.lang.RuntimeException: org.xml.sax.SAXParseException; lineNumber: 1; columnNumber: 41; The processing instruction target matching \"[xX][mM][lL]\" is not allowed.", "Example": "Event.createEventFromXML(\"&ltONTOLOGY_PATH_OF_THE_EVENT>\", \"&ltEventName>&ltpayload>\"+xmlpayload+\"</payload></EventName>\");"},{"Function": "Event.Ext.getById()", "Signature": "Event getById (Object Id)", "Domain": "ACTION", "Description": "Id", "Parameters": [{"Name": "Id", "Type": "Object", "Description": "The internal ID, retrieved off"}], "Returns": [{"Type": "Event", "Description": "Id"}], "Cautions": "none"},{"Function": "Event.Ext.acknowledgeEvent()", "Signature": "void acknowledgeEvent (SimpleEvent evt)", "Domain": "ACTION", "Description": "Acknowledge the event passed.", "Parameters": [{"Name": "evt", "Type": "SimpleEvent", "Description": "The event to acknowledge."}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Event.Ext.replyEvent()", "Signature": "boolean replyEvent(SimpleEvent request, SimpleEvent reply)", "Domain": "ACTION, BUI", "Description": "request", "Parameters": [{"Name": "request", "Type": "SimpleEvent", "Description": "The original request SimpleEvent."}, {"Name": "reply", "Type": "SimpleEvent", "Description": "The Reply SimpleEvent."}], "Returns": [{"Type": "boolean", "Description": "true if the SimpleEvent is sent; false otherwise."}]},{"Function": "Event.Ext.requestEvent()", "Signature": "Object requestEvent(SimpleEvent requestEvent, String responseEventURI, String requestEventDestinationURI, long timeout, String properties)", "Domain": "ACTION, BUI", "Description": "Make synchronous request/response calls using JMS. Sends an event and waits for a response to be returned.Each request creates and listens on a JMS temporary queue for a response.", "Parameters": [{"Name": "requestEvent", "Type": "SimpleEvent", "Description": "The SimpleEvent to use to make the request."}, {"Name": "responseEventURI", "Type": "String", "Description": "null"}, {"Name": "requestEventDestinationURI", "Type": "String", "Description": "null"}, {"Name": "timeout", "Type": "long", "Description": "The duration in milliseconds to wait for a response. Use -1 to wait forever."}, {"Name": "properties", "Type": "String", "Description": "[name1=value1;name2=value2;...;]"}], "Returns": [{"Type": "Object", "Description": "responseEventURI"}], "Cautions": "requestEvent"},{"Function": "Event.Ext.replyEventImmediate()", "Signature": "Object replyEventImmediate(SimpleEvent request, SimpleEvent reply)", "Domain": "ACTION, BUI", "Description": "request", "Parameters": [{"Name": "request", "Type": "SimpleEvent", "Description": "The original request SimpleEvent."}, {"Name": "reply", "Type": "SimpleEvent", "Description": "The Reply SimpleEvent."}], "Returns": [{"Type": "Object", "Description": "The String JMSMessageID of the reply message in case of JMS destinations, null otherwise."}]},{"Function": "Event.Ext.assertAdvisoryEvent()", "Signature": "void assertAdvisoryEvent(String category, String type, String message)", "Domain": "ACTION, BUI", "Description": "Assert an AdvisoryEvent with user defined fields.", "Parameters": [{"Name": "category", "Type": "String", "Description": "New AdvisoryEvent's category attribute.  The broad category of advisory."}, {"Name": "type", "Type": "String", "Description": "New AdvisoryEvent's category attribute. Type of advisory within the category."}, {"Name": "message", "Type": "String", "Description": "New AdvisoryEvent's message attribute."}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Event.Ext.getByExtIdByUri()", "Signature": "SimpleEvent getByExtIdByUri (String extId, String uri)", "Domain": "ACTION, BUI", "Description": "extId", "Parameters": [{"Name": "extId", "Type": "String", "Description": "The external ID."}, {"Name": "uri", "Type": "String", "Description": "URI of the event"}], "Returns": [{"Type": "SimpleEvent", "Description": "extId"}], "Cautions": "none"},{"Function": "Event.Ext.setPayload()", "Signature": "void setPayload(SimpleEvent target, SimpleEvent source)", "Domain": "ACTION, CONDITION, BUI", "Description": "Makes the target SimpleEvent use the same payload as the source SimpleEvent.", "Parameters": [{"Name": "target", "Type": "SimpleEvent", "Description": "The SimpleEvent whose payload is being set."}, {"Name": "source", "Type": "SimpleEvent", "Description": "The SimpleEvent from which the payload is obtained"}], "Returns": [{"Type": "void"}]},{"Function": "Event.Ext.consumeEvent()", "Signature": "void consumeEvent (Event evt)", "Domain": "ACTION", "Description": "Consume the Event passed (removes the Event from working memory).", "Parameters": [{"Name": "evt", "Type": "Event", "Description": "The event to consume."}], "Returns": [{"Type": "void"}], "Cautions": "none"},{"Function": "Event.Ext.sendEventImmediate()", "Signature": "Object sendEventImmediate(SimpleEvent evt) throws Exception", "Domain": "ACTION, BUI", "Description": "evt", "Parameters": [{"Name": "evt", "Type": "SimpleEvent", "Description": "An SimpleEvent to send."}], "Returns": [{"Type": "Object", "Description": "The String JMSMessageID of the sent message in case of JMS destinations, null otherwise"}], "Cautions": "This method will fail if the SimpleEvent has not been configured with any default channel and destination information."},{"Function": "Event.Ext.assertEvent()", "Signature": "SimpleEvent assertEvent (SimpleEvent event)", "Domain": "ACTION", "Description": "Asserts a SimpleEvent into the working memory.", "Parameters": [{"Name": "event", "Type": "SimpleEvent", "Description": "The simpleEvent to be asserted."}], "Returns": [{"Type": "SimpleEvent", "Description": "The SimpleEvent. Null if there is an error, of the argument was null."}]},{"Function": "Event.Ext.serializeToJSON()", "Signature": "String serializeToJSON(SimpleEvent event, boolean pretty)", "Domain": "ACTION, CONDITION, BUI", "Description": "This function serializes the event to JSON string", "Parameters": [{"Name": "event", "Type": "SimpleEvent", "Description": "The input event"}, {"Name": "pretty", "Type": "boolean", "Description": "If true, the output will be formatted for human-readability."}], "Returns": [{"Type": "String", "Description": "Serialized JSON"}], "Cautions": "The input event cannot be null."},{"Function": "Event.Ext.getPayloadAsBytes()", "Signature": "Object getPayloadAsBytes(SimpleEvent input)", "Domain": "ACTION, CONDITION, BUI", "Description": "byte[]", "Parameters": [{"Name": "input", "Type": "SimpleEvent", "Description": "The input event"}], "Returns": [{"Type": "byte[]", "Description": "as Object"}], "Cautions": "The input event cannot be null."},{"Function": "Event.Ext.getPayload()", "Signature": "Object getPayload(SimpleEvent event)", "Domain": "ACTION, CONDITION, BUI", "Description": "Returns the payload associated with the event", "Parameters": [{"Name": "event", "Type": "SimpleEvent", "Description": "The SimpleEvent whose payload is being returned."}], "Returns": [{"Type": "Object", "Description": "Payload Object"}]},{"Function": "Event.Ext.serializeToXML()", "Signature": "String serializeToXML(SimpleEvent event)", "Domain": "ACTION, CONDITION, BUI", "Description": "This function serializes the event to XML string", "Parameters": [{"Name": "event", "Type": "SimpleEvent", "Description": "The input event"}], "Returns": [{"Type": "String", "Description": "Serialized XML"}], "Cautions": "The input event cannot be null."},{"Function": "Event.Ext.validatePayload()", "Signature": "void validatePayload(SimpleEvent event)", "Domain": "ACTION, CONDITION, BUI", "Description": "Validates the payload of the event in the current RuleSession. Validation will throw an Exception if the validation failed.", "Parameters": [{"Name": "event", "Type": "SimpleEvent", "Description": "The SimpleEvent whose payload will be validated, if present."}], "Returns": [{"Type": "void"}]},{"Function": "Event.Ext.createEvent()", "Signature": "SimpleEvent createEvent (String xslt-template)", "Domain": "ACTION, BUI", "Description": "Create a new SimpleEvent using the an XSLT EventBuilder.", "Parameters": [{"Name": "xslt-template", "Type": "String", "Description": "formed using XSLT EventBuilder."}], "Returns": [{"Type": "SimpleEvent", "Description": "The newly created SimpleEvent."}], "Cautions": "none"},{"Function": "Event.Ext.routeToExt()", "Signature": "SimpleEvent routeToExt(SimpleEvent event, String destinationPath, String properties, boolean forceImmediate) throws Exception", "Domain": "ACTION, BUI", "Description": "Sends a SimpleEvent to a Destination with custom destination properties.\nThe Destination in turn specifies the Channel where the Event will be sent.", "Parameters": [{"Name": "event", "Type": "SimpleEvent", "Description": "The simpleEvent to be sent."}, {"Name": "destinationPath", "Type": "String", "Description": "destination in it."}, {"Name": "properties", "Type": "String", "Description": "[name1=value1;name2=value2;...;]"}, {"Name": "forceImmediate", "Type": "boolean", "Description": "If true, the event will be immediately passed off to the specified destination to be sent."}], "Returns": [{"Type": "SimpleEvent", "Description": "The same value as the argument evt, or null if the event was not sent."}], "Cautions": "This method may throw an Exception.\nCustom channels may not support overriding of destination properties."},{"Function": "Event.Ext.routeTo()", "Signature": "SimpleEvent routeTo(SimpleEvent event, String destinationPath, String properties) {", "Domain": "ACTION, BUI", "Description": "Sends a SimpleEvent to a Destination with custom destination properties.\nThe Destination in turn specifies the Channel where the Event will be sent.", "Parameters": [{"Name": "event", "Type": "SimpleEvent", "Description": "The simpleEvent to be sent."}, {"Name": "destinationPath", "Type": "String", "Description": "The path to the Destination that will be used to send the Event. E.G. \"/MyChannel/MyDestination\" where MyChannel is the Channel in the model and MyDestination is the destination in it."}, {"Name": "properties", "Type": "String", "Description": "[name1=value1;name2=value2;...;]"}], "Returns": [{"Type": "SimpleEvent", "Description": "The same value as the argument evt, or null if there was an error."}], "Cautions": "Custom channels may not support overriding of destination properties."},{"Function": "Event.Ext.replyEventExt()", "Signature": "boolean replyEventExt(SimpleEvent request, SimpleEvent reply, boolean forceImmediate)", "Domain": "ACTION, BUI", "Description": "request", "Parameters": [{"Name": "request", "Type": "SimpleEvent", "Description": "The original request SimpleEvent."}, {"Name": "reply", "Type": "SimpleEvent", "Description": "The Reply SimpleEvent."}, {"Name": "forceImmediate", "Type": "boolean", "Description": "If true, the reply event will be immediately passed off to the reply destination to be sent."}], "Returns": [{"Type": "boolean", "Description": "true if the SimpleEvent is sent; false otherwise."}]},{"Function": "Event.Ext.getDestinationURI()", "Signature": "String getDestinationURI (SimpleEvent event)", "Domain": "ACTION, CONDITION, QUERY, BUI", "Description": "Returns The destination URI of the specified event.", "Parameters": [{"Name": "event", "Type": "SimpleEvent", "Description": "The event whose destination URI is to be returned."}], "Returns": [{"Type": "String", "Description": "null"}]},{"Function": "Event.Ext.sendEventExt()", "Signature": "SimpleEvent sendEventExt(SimpleEvent evt, boolean forceImmediate) throws Exception", "Domain": "ACTION, BUI", "Description": "evt", "Parameters": [{"Name": "evt", "Type": "SimpleEvent", "Description": "An SimpleEvent to send."}, {"Name": "forceImmediate", "Type": "boolean", "Description": "If true, the event will be immediately passed off to the default destination to be sent."}], "Returns": [{"Type": "SimpleEvent", "Description": "The same value as the argument evt, or null if the event was not sent."}], "Cautions": "This method will fail if the SimpleEvent has not been configured with any default channel and destination information.  This method may throw an Exception."},{"Function": "Event.Ext.createEventFromJSON()", "Signature": "Event createEventFromJSON(String uri, String json)", "Domain": "ACTION, BUI", "Description": "json", "Parameters": [{"Name": "uri", "Type": "String", "Description": "URI of the corresponding event."}, {"Name": "json", "Type": "String", "Description": "JSON string to be parsed"}], "Returns": [{"Type": "Event", "Description": "returns an event instance"}], "Cautions": "none"},{"Function": "Event.Ext.routeToImmediate()", "Signature": "Object routeToImmediate(SimpleEvent event, String destinationPath, String properties)", "Domain": "ACTION, BUI", "Description": "Sends a SimpleEvent to a Destination with custom destination properties. The Destination in turn specifies the Channel where the Event will be sent.", "Parameters": [{"Name": "event", "Type": "SimpleEvent", "Description": "The simpleEvent to be sent."}, {"Name": "destinationPath", "Type": "String", "Description": "The path to the Destination that will be used to send the Event."}, {"Name": "properties", "Type": "String", "Description": "[name1=value1;name2=value2;...;]"}], "Returns": [{"Type": "Object", "Description": "The String JMSMessageID of the sent message in case of JMS destinations, null otherwise."}], "Cautions": "Custom channels may not support overriding of destination properties."},{"Function": "Event.Ext.sendEvent()", "Signature": "SimpleEvent sendEvent (SimpleEvent evt)", "Domain": "ACTION, BUI", "Description": "evt", "Parameters": [{"Name": "evt", "Type": "SimpleEvent", "Description": "An SimpleEvent to send."}], "Returns": [{"Type": "SimpleEvent", "Description": "The same value as the argument evt, or null if there was an error."}], "Cautions": "This method will fail if the SimpleEvent has not been configured with any default channel and destination information."}]